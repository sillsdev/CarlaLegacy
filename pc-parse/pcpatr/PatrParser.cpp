// PatrParser.cpp : Implementation of CPatr100App and DLL registration.
// Copyright 1999, 2000 by SIL International.  All rights reserved.

#include "stdafx.h"
#include "patr100.h"
#include "PatrParser.h"
#include "patrdef.h"
#include <assert.h>

static const char szDefaultWordMarker_g[3]     = "\\w";
static const char szDefaultCategoryMarker_g[3] = "\\c";
static const char szDefaultFeatureMarker_g[3]  = "\\f";
static const char szDefaultGlossMarker_g[3]    = "\\g";
static const char szWhitespace_g[7] = " \t\r\n\f\v";
static unsigned char szDefaultBarcodes_g[15] = "bdefhijmrsuvyz";

#define COM_TRUE -1
#define COM_FALSE 0

///////////////////////////////////////////////////////////////////////////////
// NAME
//    PatrParser::PatrParser
// DESCRIPTION
//    constructor
// RETURN VALUE
//    none
//
PatrParser::PatrParser()
{
	memset(&m_memory, 0, sizeof(m_memory));
	memset(&m_data, 0, sizeof(m_data));
	memset(&m_sTextCtl, 0, sizeof(m_sTextCtl));

	m_memory.bPreserve = TRUE;

	m_data.bUnification      = TRUE;
	m_data.eTreeDisplay      = PATR_FULL_TREE;
	m_data.bGloss            = TRUE;
	m_data.iFeatureDisplay   = PATR_FEATURE_ON | PATR_FEATURE_TRIM;
	m_data.bCheckCycles      = TRUE;
	m_data.bTopDownFilter    = TRUE;
	m_data.iMaxAmbiguities   = 10;
	m_data.cComment          = PATR_DEFAULT_COMMENT;
	m_data.bSilent           = TRUE;
	m_data.bShowWarnings     = TRUE;
	m_data.bPromoteDefAtoms  = TRUE;
	m_data.bPropIsFeature    = FALSE;
	m_data.pszRecordMarker   = szDefaultWordMarker_g;
	m_data.pszWordMarker     = szDefaultWordMarker_g;
	m_data.pszGlossMarker    = szDefaultGlossMarker_g;
	m_data.pszCategoryMarker = szDefaultCategoryMarker_g;
	m_data.pszFeatureMarker  = szDefaultFeatureMarker_g;
	m_data.pMem              = &m_memory;
	initPATRSentenceFinalPunctuation(&m_data);

	m_sTextCtl.cFormatMark = '\\';
	m_sTextCtl.cAnaAmbig = '%';
	m_sTextCtl.cTextAmbig = '%';
	m_sTextCtl.cDecomp = '-';
	m_sTextCtl.cBarMark = '|';
	m_sTextCtl.pszBarCodes = szDefaultBarcodes_g;
	m_sTextCtl.bIndividualCapitalize = 1;
	m_sTextCtl.bCapitalize = 1;
	m_sTextCtl.uiMaxAmbigDecap = 500;

	m_ppszLexFiles = NULL;
	m_pbAnaLexFile = NULL;
	m_uiLexFileCount = 0;
	m_uiLexFileAlloc = 0;
	m_pszLogFile = NULL;

	m_pszError = NULL;

	m_iCodePage = CP_ACP;
}

///////////////////////////////////////////////////////////////////////////////
// NAME
//    PatrParser::FinalRelease
// DESCRIPTION
//    This method takes the place of a destructor in the ATL/COM scheme of
//    things.
// RETURN VALUE
//    none
//
void PatrParser::FinalRelease()
{
	Clear();

	if (m_data.pLogFP != NULL)
	{
		fclose(m_data.pLogFP);
		m_data.pLogFP = NULL;
	}
	if (m_pszLogFile != NULL)
	{
		free((void *)m_pszLogFile);
		m_pszLogFile = NULL;
	}
	if (m_data.pszRecordMarker != szDefaultWordMarker_g)
	{
		free((void *)m_data.pszRecordMarker);
		m_data.pszRecordMarker = szDefaultWordMarker_g;
	}
	if (m_data.pszWordMarker != szDefaultWordMarker_g)
	{
		free((void *)m_data.pszWordMarker);
		m_data.pszWordMarker = szDefaultWordMarker_g;
	}
	if (m_data.pszGlossMarker != szDefaultGlossMarker_g)
	{
		free((void *)m_data.pszGlossMarker);
		m_data.pszGlossMarker = szDefaultGlossMarker_g;
	}
	if (m_data.pszCategoryMarker != szDefaultCategoryMarker_g)
	{
		free((void *)m_data.pszCategoryMarker);
		m_data.pszCategoryMarker = szDefaultCategoryMarker_g;
	}
	if (m_data.pszFeatureMarker != szDefaultFeatureMarker_g)
	{
		free((void *)m_data.pszFeatureMarker);
		m_data.pszFeatureMarker = szDefaultFeatureMarker_g;
	}
	clearPATRSentenceFinalPunctuation(&m_data);
}

///////////////////////////////////////////////////////////////////////////////
// NAME
//    PatrParser::InterfaceSupportsErrorInfo
// DESCRIPTION
//    automatically generated by the ATL/COM code wizard.
// RETURN VALUE
//    S_OK or S_FALSE
//
STDMETHODIMP PatrParser::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] =
	{
		&IID_IPatrParser,
	};

	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
#ifndef hab2110
	  if (::IsEqualGUID(*arr[i],riid))  // don't have the inline version anymore?
		return S_OK;
#else
	  if (::InLineIsEqualGUID(*arr[i],riid))
		return S_OK;
#endif // hab2110
	}
	return S_FALSE;
}

///////////////////////////////////////////////////////////////////////////////
// NAME
//    PatrParser::ParseString
// DESCRIPTION
//    Parse a sentence passed in as a BSTR, and return the results as an XML
//    string stored in a BSTR.
// RETURN VALUE
//    S_OK, S_FALSE, or an appropriate COM error code
//
STDMETHODIMP PatrParser::ParseString(BSTR bstrSentence, BSTR * pbstrParse)
{
	// check for valid input
	if (bstrSentence == NULL)
	{
		return E_INVALIDARG;
	}
	if (pbstrParse == NULL)
	{
		return E_POINTER;
	}
	*pbstrParse = NULL;

	// check for valid preparation
	if (m_data.pGrammar == NULL)
	{
		return E_UNEXPECTED;
	}
	if (m_data.pLexicon == NULL)
	{
		return E_UNEXPECTED;
	}

	char * pszSentence;
	HRESULT hr = ConvertBstrToString(bstrSentence, m_iCodePage, &pszSentence);
	if (FAILED(hr))
	{
		return hr;
	}
	if (pszSentence == NULL)
	{
		return S_OK;
	}
	if (*pszSentence == '\0')
	{
		free(pszSentence);
		return S_OK;
	}

	char * psz = strdup(pszSentence + strspn(pszSentence, szWhitespace_g));
	if (psz == NULL)
	{
		free(pszSentence);
		return E_OUTOFMEMORY;
	}

	if (m_data.pLogFP != NULL)
		fprintf(m_data.pLogFP, "%s\n", pszSentence);
	//
	//  convert the flat sentence string into a linked list of words stored
	//  in PATRWord structures
	//
	markPATRParseGarbage(&m_data);
	int cErrors;
	PATRWord * pword;
	PATRWord * pSentence = convertSentenceToPATRWords(psz, NULL, NULL, TRUE,
		&m_data, &cErrors);
	if ((cErrors != 0) || (pSentence == NULL))
	{
		collectPATRParseGarbage(&m_data);
		while ((pword = pSentence) != NULL)
		{
			pSentence = pword->pNext;
			freeMemory( pword );
		}
		free(psz);
		free(pszSentence);
		return E_FAIL;
	}
	//
	//  if no errors looking up words, try to parse the sentence
	//
	int cParses = 0;
	int iStage = 0;
	char * pszXml = NULL;
	PATREdgeList * parses = parseWithPATR(pSentence, &iStage, &m_data);
	const char * pszMessage = NULL;
	PATREdgeList * pel;
	switch (iStage)
	{
	case 0:
		for ( pel = parses ; pel ; pel = pel->pNext )
			++cParses;
		break;
	case 1:
		pszMessage = "<!-- Turning off unification -->\n";
		break;
	case 2:
		pszMessage = "<!-- Turning off top-down filtering -->\n";
		break;
	case 3:
		pszMessage = "<!-- Building the largest parse \"bush\" -->\n";
		break;
	case 4:
		pszMessage = "<!-- No output available -->\n";
		break;
	case 5:
		pszMessage = "<!-- Out of Memory (after %lu edges) -->\n";
		break;
	case 6:
		pszMessage = "<!-- Out of Time (after %lu edges) -->\n";
		break;
	}
	if ((m_data.pLogFP != NULL) && (pszMessage != NULL))
	{
		fprintf(m_data.pLogFP, "<!-- Cannot parse this sentence -->\n");
		fprintf(m_data.pLogFP, pszMessage, m_data.uiEdgesAdded);
	}
	if (parses != NULL)
	{
		if (m_data.pLogFP != NULL)
		{
			writePATRParses(parses, m_data.pLogFP, &m_data);
			putc('\n', m_data.pLogFP);
		}
		if (stringifyPATRParses(parses, &m_data, pszSentence, &pszXml))
			hr = E_OUTOFMEMORY;
	}
	//
	//  erase the temporarily allocated linked list of PATRWords
	//
	collectPATRParseGarbage(&m_data);
	while ((pword = pSentence) != NULL)
	{
		pSentence = pword->pNext;
		freeMemory( pword );
	}
	free(pszSentence);
	free(psz);
	if (FAILED(hr))
		return hr;
	//
	//  convert the XML output string to Unicode
	//
	if (pszXml != NULL)
	{
		HRESULT hr = ConvertStringToBstr(pszXml, m_iCodePage, pbstrParse);
		free(pszXml);
		if (FAILED(hr))
			return hr;
	}
	return (iStage == 0) ? S_OK : S_FALSE;
}

///////////////////////////////////////////////////////////////////////////////
// NAME
//    PatrParser::ParseFile
// DESCRIPTION
//    Parse the sentences found in the given input file, writing the results to
//    the given output file.
// RETURN VALUE
//    S_OK, or an appropriate COM error code
//
STDMETHODIMP PatrParser::ParseFile(BSTR bstrInput, BSTR bstrOutput)
{
	// check for valid input
	if ((bstrInput == NULL) || (bstrOutput == NULL))
	{
		return E_INVALIDARG;
	}
	// open the files
	char * pszInput;
	HRESULT hr = ConvertBstrToString(bstrInput, CP_ACP, &pszInput);
	if (FAILED(hr))
	{
		return hr;
	}
	FILE * pfileIn = fopen(pszInput, "r");
	if (pfileIn == NULL)
	{
		free(pszInput);
		return E_FAIL;
	}
	char * pszOutput;
	hr = ConvertBstrToString(bstrOutput, CP_ACP, &pszOutput);
	if (FAILED(hr))
	{
		free(pszInput);
		fclose(pfileIn);
		return hr;
	}
	FILE * pfileOut = fopen(pszOutput, "w");
	if (pfileOut == NULL)
	{
		free(pszOutput);
		free(pszInput);
		fclose(pfileIn);
		return E_FAIL;
	}
	char * psz;
	unsigned linenum = 1;
	unsigned cSentences = 0;
	unsigned cAmbiguity;
	int i;
	int successes[11];
	for ( i = 0 ; i < 11 ; ++i )
		successes[i] = 0;
	for (;;)
	{
		psz = readLineFromFile(pfileIn, &linenum, m_data.cComment);
		if (psz == NULL)
			break;
		/*
		 *  skip any leading whitespace
		 */
		psz += strspn(psz, (char *)szWhitespace_g);
		if (*psz == NUL)
			continue;
		trimTrailingWhitespace(psz);
		if (m_data.eTreeDisplay != PATR_XML_TREE)
			fprintf(pfileOut, "%s\n", psz);
		cAmbiguity = parseWithPATRLexicon(psz, pfileOut, NULL,
			TRUE, &m_data);
		if (cAmbiguity < 10)
			++successes[cAmbiguity];
		else
			++successes[10];
		++cSentences;
	}

	fclose(pfileIn);
	free((void *)pszInput);

	fprintf(pfileOut, "\n\nFile parsing statistics: %u sentences read\n",
		cSentences);
	for ( i = 0 ; i < 10 ; ++i )
	{
		if (successes[i])
			fprintf(pfileOut, "    %8u sentence%s with %d parses\n",
				successes[i], (successes[i] == 1) ? " " : "s", i);
	}
	if (successes[10])
		fprintf(pfileOut,
			"    %8u sentence%s with 10 or more parses\n",
			successes[10], (successes[10] == 1) ? " " : "s");

	unsigned num_parsed;
	unsigned percent_parsed;
	unsigned frac_percent;
	num_parsed = cSentences - successes[0];
	if (cSentences == 0)
	{
		percent_parsed = 0;
		frac_percent   = 0;
	}
	else
	{
		percent_parsed = (100 * num_parsed) / cSentences;
		frac_percent = (100 * num_parsed) % cSentences;
		frac_percent = (frac_percent * 10) / cSentences;
	}
	fprintf(pfileOut, "%u of %u (%u.%u %%) parsed at least once\n",
		num_parsed, cSentences, percent_parsed, frac_percent);

	fclose(pfileOut);
	free((void *)pszOutput);

	return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
// NAME
//    PatrParser::LoadGrammarFile
// DESCRIPTION
//    Load a PC-PATR grammar file, erasing anything previously loaded.
// RETURN VALUE
//    S_OK or an appropriate COM error code
//
STDMETHODIMP PatrParser::LoadGrammarFile(BSTR bstrGrammarFile)
{
	// check for valid input
	if (bstrGrammarFile == NULL)
	{
		return E_INVALIDARG;
	}

	// convert the filename from 16-bit Unicode to 8-bit ANSI
	char * pszFile;
	HRESULT hr = ConvertBstrToString(bstrGrammarFile, CP_ACP, &pszFile);
	if (FAILED(hr))
	{
		return hr;
	}

	// erase the old grammar and filename
	if (m_data.pGrammar != NULL)
	{
		freePATRGrammar( &m_data );
	}

	// load the new grammar
	hr = loadPATRGrammar(pszFile, &m_data) ? S_OK : E_FAIL;
	free(pszFile);
	return hr;
}

///////////////////////////////////////////////////////////////////////////////
// NAME
//    PatrParser::LoadLexiconFile
// DESCRIPTION
//    Load a PC-PATR (word) lexicon file, erasing anything previously loaded
//    unless fAdd is TRUE.  On an error return, the entire lexicon in memory
//    may be empty, even if you were trying to add to an already loaded
//    lexicon.
// RETURN VALUE
//    S_OK or an appropriate COM error code
//
STDMETHODIMP PatrParser::LoadLexiconFile(BSTR bstrLexiconFile, BOOL fAdd)
{
	return LoadLexicon(bstrLexiconFile, fAdd, false);
}

///////////////////////////////////////////////////////////////////////////////
// NAME
//    Clear
// DESCRIPTION
//    free all the dynamically allocated memory (except for log filename)
// RETURN VALUE
//    S_OK
//
STDMETHODIMP PatrParser::Clear()
{
	freePATRGrammar(&m_data);	/* remove existing grammar */
	freePATRLexicon(&m_data);	/* remove existing lexicon */
	if (m_ppszLexFiles != NULL)
	{
		unsigned i;
		for ( i = 0 ; i < m_uiLexFileCount ; ++i )
		{
			free((void *)m_ppszLexFiles[i]);
			m_ppszLexFiles[i] = NULL;
		}
		free((void *)m_ppszLexFiles);
		free(m_pbAnaLexFile);
		m_ppszLexFiles = NULL;
		m_pbAnaLexFile = NULL;
		m_uiLexFileCount = 0;
		m_uiLexFileAlloc = 0;
	}
	freePATRInternalMemory(&m_data);

	return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
// NAME
//    PatrParser::get_GrammarFile
// DESCRIPTION
//    return (indirectly) the current grammar filename as a BSTR, or NULL if no
//    grammar is currently loaded
// RETURN VALUE
//    S_OK, or an appropriate COM error code
//
STDMETHODIMP PatrParser::get_GrammarFile(BSTR * pVal)
{
	// check for valid input
	if (pVal == NULL)
	{
		return E_POINTER;
	}
	*pVal = NULL;
	// convert the current grammar filename (if there is one) to a BSTR
	if (m_data.pszGrammarFile != NULL)
	{
		return ConvertStringToBstr(m_data.pszGrammarFile, CP_ACP, pVal);
	}
	else
	{
		return S_OK;
	}
}

///////////////////////////////////////////////////////////////////////////////
// NAME
//    PatrParser::get_LexiconFile
// DESCRIPTION
//    return (indirectly) the desired lexicon filename as a BSTR, or NULL if no
//    lexicon is currently loaded (or if iFile is out of range)
// RETURN VALUE
//    S_OK, or an appropriate COM error code
//
STDMETHODIMP PatrParser::get_LexiconFile(long iFile, BSTR * pVal)
{
	// check for valid input
	if (pVal == NULL)
		return E_POINTER;
	*pVal = NULL;
	if ((unsigned)iFile >= m_uiLexFileCount)
		return S_OK;
	// convert the current lexicon filename to a BSTR
	return ConvertStringToBstr(m_ppszLexFiles[iFile], CP_ACP, pVal);
}

///////////////////////////////////////////////////////////////////////////////
// NAME
//    PatrParser::get_Failures
// DESCRIPTION
//    get the value of m_data.bFailure
// RETURN VALUE
//    S_OK, or an appropriate COM error code
//
STDMETHODIMP PatrParser::get_Failures(BOOL * pVal)
{
	// check for valid input
	if (pVal == NULL)
	{
		return E_POINTER;
	}
	*pVal = (BOOL)m_data.bFailure;
	return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
// NAME
//    PatrParser::put_Failures
// DESCRIPTION
//    set the value of m_data.bFailure
// RETURN VALUE
//    S_OK, or an appropriate COM error code
//
STDMETHODIMP PatrParser::put_Failures(BOOL newVal)
{
	m_data.bFailure = newVal ? TRUE : FALSE;
	return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
// NAME
//    PatrParser::get_Unification
// DESCRIPTION
//    get the value of m_data.bUnification
// RETURN VALUE
//    S_OK, or an appropriate COM error code
//
STDMETHODIMP PatrParser::get_Unification(BOOL * pVal)
{
	// check for valid input
	if (pVal == NULL)
	{
		return E_POINTER;
	}
	*pVal = (BOOL)m_data.bUnification;
	return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
// NAME
//    PatrParser::put_Unification
// DESCRIPTION
//    set the value of m_data.bUnification
// RETURN VALUE
//    S_OK, or an appropriate COM error code
//
STDMETHODIMP PatrParser::put_Unification(BOOL newVal)
{
	m_data.bUnification = newVal ? TRUE : FALSE;
	return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
// NAME
//    PatrParser::get_TreeDisplay
// DESCRIPTION
//    get the value of m_data.eTreeDisplay
// RETURN VALUE
//    S_OK, or an appropriate COM error code
//
STDMETHODIMP PatrParser::get_TreeDisplay(long * pVal)
{
	// check for valid input
	if (pVal == NULL)
	{
		return E_POINTER;
	}
	*pVal = (long)m_data.eTreeDisplay;
	return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
// NAME
//    PatrParser::put_TreeDisplay
// DESCRIPTION
//    set the value of m_data.eTreeDisplay
// RETURN VALUE
//    S_OK, or an appropriate COM error code
//
STDMETHODIMP PatrParser::put_TreeDisplay(long newVal)
{
	// check for valid input
	if ((newVal < PATR_NO_TREE) || (newVal > PATR_XML_TREE))
	{
		return E_INVALIDARG;
	}
	m_data.eTreeDisplay = (char)newVal;
	return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
// NAME
//    PatrParser::get_Gloss
// DESCRIPTION
//    get the value of m_data.bGloss
// RETURN VALUE
//    S_OK, or an appropriate COM error code
//
STDMETHODIMP PatrParser::get_Gloss(BOOL * pVal)
{
	// check for valid input
	if (pVal == NULL)
	{
		return E_POINTER;
	}
	*pVal = (BOOL)m_data.bGloss;
	return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
// NAME
//    PatrParser::put_Gloss
// DESCRIPTION
//    set the value of m_data.bGloss
// RETURN VALUE
//    S_OK, or an appropriate COM error code
//
STDMETHODIMP PatrParser::put_Gloss(BOOL newVal)
{
	m_data.bGloss = newVal ? TRUE : FALSE;
	return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
// NAME
//    PatrParser::get_MaxAmbiguity
// DESCRIPTION
//    get the value of m_data.iMaxAmbiguities
// RETURN VALUE
//    S_OK, or an appropriate COM error code
//
STDMETHODIMP PatrParser::get_MaxAmbiguity(long * pVal)
{
	// check for valid input
	if (pVal == NULL)
	{
		return E_POINTER;
	}
	*pVal = (long)m_data.iMaxAmbiguities;
	return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
// NAME
//    PatrParser::put_MaxAmbiguity
// DESCRIPTION
//    set the value of m_data.iMaxAmbiguities
// RETURN VALUE
//    S_OK, or an appropriate COM error code
//
STDMETHODIMP PatrParser::put_MaxAmbiguity(long newVal)
{
	// check for valid input
	if (newVal <= 0)
	{
		return E_INVALIDARG;
	}
	unsigned short iMax = (short)newVal;
	if ((long)iMax != newVal)
		iMax = ~0;		// ASSUME 2's COMPLEMENT
	m_data.iMaxAmbiguities = iMax;
	return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
// NAME
//    PatrParser::get_CheckCycles
// DESCRIPTION
//    get the value of m_data.bCheckCycles
// RETURN VALUE
//    S_OK, or an appropriate COM error code
//
STDMETHODIMP PatrParser::get_CheckCycles(BOOL * pVal)
{
	// check for valid input
	if (pVal == NULL)
	{
		return E_POINTER;
	}
	*pVal = (BOOL)m_data.bCheckCycles;
	return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
// NAME
//    PatrParser::put_CheckCycles
// DESCRIPTION
//    set the value of m_data.bCheckCycles
// RETURN VALUE
//    S_OK, or an appropriate COM error code
//
STDMETHODIMP PatrParser::put_CheckCycles(BOOL newVal)
{
	m_data.bCheckCycles = newVal ? TRUE : FALSE;
	return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
// NAME
//    PatrParser::get_CommentChar
// DESCRIPTION
//    get the value of m_data.cComment
// RETURN VALUE
//    S_OK, or an appropriate COM error code
//
STDMETHODIMP PatrParser::get_CommentChar(long * pVal)
{
	// check for valid input
	if (pVal == NULL)
	{
		return E_POINTER;
	}
	*pVal = (long)((unsigned char)m_data.cComment);
	return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
// NAME
//    PatrParser::put_CommentChar
// DESCRIPTION
//    set the value of m_data.cComment
// RETURN VALUE
//    S_OK, or an appropriate COM error code
//
STDMETHODIMP PatrParser::put_CommentChar(long newVal)
{
	if ((newVal < 0) || (newVal > 255))
	{
		return E_INVALIDARG;
	}
	m_data.cComment = (char)newVal;
	return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
// NAME
//    PatrParser::get_TimeLimit
// DESCRIPTION
//    get the value of m_data.iMaxProcTime
// RETURN VALUE
//    S_OK, or an appropriate COM error code
//
STDMETHODIMP PatrParser::get_TimeLimit(long * pVal)
{
	// check for valid input
	if (pVal == NULL)
	{
		return E_POINTER;
	}
	*pVal = (long)m_data.iMaxProcTime;
	return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
// NAME
//    PatrParser::put_TimeLimit
// DESCRIPTION
//    set the value of m_data.iMaxProcTime
// RETURN VALUE
//    S_OK, or an appropriate COM error code
//
STDMETHODIMP PatrParser::put_TimeLimit(long newVal)
{
	m_data.iMaxProcTime = (time_t)newVal;
	return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
// NAME
//    PatrParser::get_TopDownFilter
// DESCRIPTION
//    get the value of m_data.bTopDownFilter
// RETURN VALUE
//    S_OK, or an appropriate COM error code
//
STDMETHODIMP PatrParser::get_TopDownFilter(BOOL * pVal)
{
	// check for valid input
	if (pVal == NULL)
	{
		return E_POINTER;
	}
	*pVal = (BOOL)m_data.bTopDownFilter;
	return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
// NAME
//    PatrParser::put_TopDownFilter
// DESCRIPTION
//    set the value of m_data.bTopDownFilter
// RETURN VALUE
//    S_OK, or an appropriate COM error code
//
STDMETHODIMP PatrParser::put_TopDownFilter(BOOL newVal)
{
	m_data.bTopDownFilter = newVal ? TRUE : FALSE;
	return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
// NAME
//    PatrParser::get_TrimEmptyFeatures
// DESCRIPTION
//    get the value of m_data.iFeatureDisplay & PATR_FEATURE_TRIM
// RETURN VALUE
//    S_OK, or an appropriate COM error code
//
STDMETHODIMP PatrParser::get_TrimEmptyFeatures(BOOL * pVal)
{
	// check for valid input
	if (pVal == NULL)
	{
		return E_POINTER;
	}
	*pVal = (BOOL)(m_data.iFeatureDisplay & PATR_FEATURE_TRIM ?
		COM_TRUE : COM_FALSE);
	return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
// NAME
//    PatrParser::put_TrimEmptyFeatures
// DESCRIPTION
//    set the value of m_data.iFeatureDisplay & PATR_FEATURE_TRIM
// RETURN VALUE
//    S_OK, or an appropriate COM error code
//
STDMETHODIMP PatrParser::put_TrimEmptyFeatures(BOOL newVal)
{
	if (newVal)
		m_data.iFeatureDisplay |= PATR_FEATURE_TRIM;
	else
		m_data.iFeatureDisplay &= ~PATR_FEATURE_TRIM;
	return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
// NAME
//    PatrParser::get_DebuggingLevel
// DESCRIPTION
//    get the value of m_data.iDebugLevel
// RETURN VALUE
//    S_OK, or an appropriate COM error code
//
STDMETHODIMP PatrParser::get_DebuggingLevel(long * pVal)
{
	// check for valid input
	if (pVal == NULL)
	{
		return E_POINTER;
	}
	*pVal = (long)m_data.iDebugLevel;
	return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
// NAME
//    PatrParser::put_DebuggingLevel
// DESCRIPTION
//    set the value of m_data.iDebugLevel
// RETURN VALUE
//    S_OK, or an appropriate COM error code
//
STDMETHODIMP PatrParser::put_DebuggingLevel(long newVal)
{
	// check for valid input
	if (newVal < 0)
	{
		return E_INVALIDARG;
	}
	unsigned short iDebug = (short)newVal;
	if ((long)iDebug != newVal)
		iDebug = ~0;		// ASSUME 2's COMPLEMENT
	m_data.iDebugLevel = iDebug;
	return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
// NAME
//    PatrParser::get_LexRecordMarker
// DESCRIPTION
//    return (indirectly) the current lexicon record marker as a BSTR
// RETURN VALUE
//    S_OK, or an appropriate COM error code
//
STDMETHODIMP PatrParser::get_LexRecordMarker(BSTR * pVal)
{
	// check for valid input
	if (pVal == NULL)
	{
		return E_POINTER;
	}
	*pVal = NULL;
	// convert the current lexicon record marker
	if (m_data.pszRecordMarker != NULL)
	{
		return ConvertStringToBstr(m_data.pszRecordMarker, CP_ACP, pVal);
	}
	else
	{
		return E_UNEXPECTED;
	}
}

///////////////////////////////////////////////////////////////////////////////
// NAME
//    PatrParser::put_LexRecordMarker
// DESCRIPTION
//    set the value of m_data.pszRecordMarker
// RETURN VALUE
//    S_OK, or an appropriate COM error code
//
STDMETHODIMP PatrParser::put_LexRecordMarker(BSTR newVal)
{
	// check for valid input
	if (newVal == NULL)
	{
		return E_INVALIDARG;
	}
	char * psz;
	HRESULT hr = ConvertBstrToString(newVal, m_iCodePage, &psz);
	if (FAILED(hr))
	{
		return hr;
	}
	if (m_data.pszRecordMarker != szDefaultWordMarker_g)
	{
		free((void *)m_data.pszRecordMarker);
		m_data.pszRecordMarker = NULL;
	}
	m_data.pszRecordMarker = psz;
	return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
// NAME
//    PatrParser::get_LexWordMarker
// DESCRIPTION
//    return (indirectly) the current lexicon word marker as a BSTR
// RETURN VALUE
//    S_OK, or an appropriate COM error code
//
STDMETHODIMP PatrParser::get_LexWordMarker(BSTR * pVal)
{
	// check for valid input
	if (pVal == NULL)
	{
		return E_POINTER;
	}
	*pVal = NULL;
	// convert the current lexicon word marker
	if (m_data.pszWordMarker != NULL)
	{
		return ConvertStringToBstr(m_data.pszWordMarker, CP_ACP, pVal);
	}
	else
	{
		return E_UNEXPECTED;
	}
}

///////////////////////////////////////////////////////////////////////////////
// NAME
//    PatrParser::put_LexWordMarker
// DESCRIPTION
//    set the value of m_data.pszWordMarker
// RETURN VALUE
//    S_OK, or an appropriate COM error code
//
STDMETHODIMP PatrParser::put_LexWordMarker(BSTR newVal)
{
	// check for valid input
	if (newVal == NULL)
	{
		return E_INVALIDARG;
	}
	char * psz;
	HRESULT hr = ConvertBstrToString(newVal, m_iCodePage, &psz);
	if (FAILED(hr))
	{
		return hr;
	}
	if (m_data.pszWordMarker != szDefaultWordMarker_g)
	{
		free((void *)m_data.pszWordMarker);
		m_data.pszWordMarker = NULL;
	}
	m_data.pszWordMarker = psz;
	return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
// NAME
//    PatrParser::get_LexCategoryMarker
// DESCRIPTION
//    return (indirectly) the current lexicon category marker as a BSTR
// RETURN VALUE
//    S_OK, or an appropriate COM error code
//
STDMETHODIMP PatrParser::get_LexCategoryMarker(BSTR * pVal)
{
	// check for valid input
	if (pVal == NULL)
	{
		return E_POINTER;
	}
	*pVal = NULL;
	// convert the current lexicon category marker
	if (m_data.pszCategoryMarker != NULL)
	{
		return ConvertStringToBstr(m_data.pszCategoryMarker, CP_ACP, pVal);
	}
	else
	{
		return E_UNEXPECTED;
	}
}

///////////////////////////////////////////////////////////////////////////////
// NAME
//    PatrParser::put_LexCategoryMarker
// DESCRIPTION
//    set the value of m_data.pszCategoryMarker
// RETURN VALUE
//    S_OK, or an appropriate COM error code
//
STDMETHODIMP PatrParser::put_LexCategoryMarker(BSTR newVal)
{
	// check for valid input
	if (newVal == NULL)
	{
		return E_INVALIDARG;
	}
	char * psz;
	HRESULT hr = ConvertBstrToString(newVal, m_iCodePage, &psz);
	if (FAILED(hr))
	{
		return hr;
	}
	if (m_data.pszCategoryMarker != szDefaultCategoryMarker_g)
	{
		free((void *)m_data.pszCategoryMarker);
		m_data.pszCategoryMarker = NULL;
	}
	m_data.pszCategoryMarker = psz;
	return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
// NAME
//    PatrParser::get_LexFeaturesMarker
// DESCRIPTION
//    return (indirectly) the current lexicon features marker as a BSTR
// RETURN VALUE
//    S_OK, or an appropriate COM error code
//
STDMETHODIMP PatrParser::get_LexFeaturesMarker(BSTR * pVal)
{
	// check for valid input
	if (pVal == NULL)
	{
		return E_POINTER;
	}
	*pVal = NULL;
	// convert the current lexicon features marker
	if (m_data.pszFeatureMarker != NULL)
	{
		return ConvertStringToBstr(m_data.pszFeatureMarker, CP_ACP, pVal);
	}
	else
	{
		return E_UNEXPECTED;
	}
}

///////////////////////////////////////////////////////////////////////////////
// NAME
//    PatrParser::put_LexFeatureMarker
// DESCRIPTION
//    set the value of m_data.pszFeatureMarker
// RETURN VALUE
//    S_OK, or an appropriate COM error code
//
STDMETHODIMP PatrParser::put_LexFeaturesMarker(BSTR newVal)
{
	// check for valid input
	if (newVal == NULL)
	{
		return E_INVALIDARG;
	}
	char * psz;
	HRESULT hr = ConvertBstrToString(newVal, m_iCodePage, &psz);
	if (FAILED(hr))
	{
		return hr;
	}
	if (m_data.pszFeatureMarker != szDefaultFeatureMarker_g)
	{
		free((void *)m_data.pszFeatureMarker);
		m_data.pszFeatureMarker = NULL;
	}
	m_data.pszFeatureMarker = psz;
	return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
// NAME
//    PatrParser::get_LexGlossMarker
// DESCRIPTION
//    return (indirectly) the current lexicon gloss marker as a BSTR
// RETURN VALUE
//    S_OK, or an appropriate COM error code
//
STDMETHODIMP PatrParser::get_LexGlossMarker(BSTR * pVal)
{
	// check for valid input
	if (pVal == NULL)
	{
		return E_POINTER;
	}
	*pVal = NULL;
	// convert the current lexicon gloss marker
	if (m_data.pszGlossMarker != NULL)
	{
		return ConvertStringToBstr(m_data.pszGlossMarker, CP_ACP, pVal);
	}
	else
	{
		return E_UNEXPECTED;
	}
}

///////////////////////////////////////////////////////////////////////////////
// NAME
//    PatrParser::put_LexGlossMarker
// DESCRIPTION
//    set the value of m_data.pszGlossMarker
// RETURN VALUE
//    S_OK, or an appropriate COM error code
//
STDMETHODIMP PatrParser::put_LexGlossMarker(BSTR newVal)
{
	// check for valid input
	if (newVal == NULL)
	{
		return E_INVALIDARG;
	}
	char * psz;
	HRESULT hr = ConvertBstrToString(newVal, m_iCodePage, &psz);
	if (FAILED(hr))
	{
		return hr;
	}
	if (m_data.pszGlossMarker != szDefaultGlossMarker_g)
	{
		free((void *)m_data.pszGlossMarker);
		m_data.pszGlossMarker = NULL;
	}
	m_data.pszGlossMarker = psz;
	return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
// NAME
//    PatrParser::get_TopFeatureOnly
// DESCRIPTION
//    get the value of m_data.iFeatureDisplay & PATR_FEATURE_ALL
// RETURN VALUE
//    S_OK, or an appropriate COM error code
//
STDMETHODIMP PatrParser::get_TopFeatureOnly(BOOL * pVal)
{
	// check for valid input
	if (pVal == NULL)
	{
		return E_POINTER;
	}
	*pVal = (BOOL)(m_data.iFeatureDisplay & PATR_FEATURE_ALL ?
		COM_FALSE : COM_TRUE);
	return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
// NAME
//    PatrParser::put_TopFeatureOnly
// DESCRIPTION
//    set the value of m_data.iFeatureDisplay & PATR_FEATURE_ALL
// RETURN VALUE
//    S_OK, or an appropriate COM error code
//
STDMETHODIMP PatrParser::put_TopFeatureOnly(BOOL newVal)
{
	if (newVal)
		m_data.iFeatureDisplay &= ~PATR_FEATURE_ALL;
	else
		m_data.iFeatureDisplay |= PATR_FEATURE_ALL;
	return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
// NAME
//    PatrParser::get_DisplayFeatures
// DESCRIPTION
//    get the value of m_data.iFeatureDisplay & PATR_FEATURE_ON
// RETURN VALUE
//    S_OK, or an appropriate COM error code
//
STDMETHODIMP PatrParser::get_DisplayFeatures(BOOL * pVal)
{
	// check for valid input
	if (pVal == NULL)
	{
		return E_POINTER;
	}
	*pVal = (BOOL)(m_data.iFeatureDisplay & PATR_FEATURE_ON ?
		COM_TRUE : COM_FALSE);
	return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
// NAME
//    PatrParser::put_DisplayFeatures
// DESCRIPTION
//    get the value of m_data.iFeatureDisplay & PATR_FEATURE_ON
// RETURN VALUE
//    S_OK, or an appropriate COM error code
//
STDMETHODIMP PatrParser::put_DisplayFeatures(BOOL newVal)
{
	if (newVal)
		m_data.iFeatureDisplay |= PATR_FEATURE_ON;
	else
		m_data.iFeatureDisplay &= ~PATR_FEATURE_ON;
	return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
// NAME
//    PatrParser::get_FlatFeatureDisplay
// DESCRIPTION
//    get the value of m_data.iFeatureDisplay & PATR_FEATURE_FLAT
// RETURN VALUE
//    S_OK, or an appropriate COM error code
//
STDMETHODIMP PatrParser::get_FlatFeatureDisplay(BOOL * pVal)
{
	// check for valid input
	if (pVal == NULL)
	{
		return E_POINTER;
	}
	*pVal = (BOOL)(m_data.iFeatureDisplay & PATR_FEATURE_FLAT ?
		COM_TRUE : COM_FALSE);
	return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
// NAME
//    PatrParser::put_FlatFeatureDisplay
// DESCRIPTION
//    get the value of m_data.iFeatureDisplay & PATR_FEATURE_FLAT
// RETURN VALUE
//    S_OK, or an appropriate COM error code
//
STDMETHODIMP PatrParser::put_FlatFeatureDisplay(BOOL newVal)
{
	if (newVal)
		m_data.iFeatureDisplay |= PATR_FEATURE_FLAT;
	else
		m_data.iFeatureDisplay &= ~PATR_FEATURE_FLAT;
	return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
// NAME
//    PatrParser::get_SentenceFinalPunctuation
// DESCRIPTION
//    return (indirectly) the current sentence final punctuation characters as
//    a BSTR
// RETURN VALUE
//    S_OK, or an appropriate COM error code
//
STDMETHODIMP PatrParser::get_SentenceFinalPunctuation(BSTR * pVal)
{
	// check for valid input
	if (pVal == NULL)
	{
		return E_POINTER;
	}
	*pVal = NULL;
	// convert the current set of sentence final punctuation characters
	DynString dstr = { NULL, 0, 0, 0 };
	const StringList * psl;
	for ( psl = m_data.pFinalPunc ; psl ; psl = psl->pNext )
	{
		if (dstr.pszBuffer)
			appendCharToDynString(&dstr, ' ');
		appendToDynString(&dstr, psl->pszString, strlen(psl->pszString));
	}
	if (dstr.bError)
		return E_OUTOFMEMORY;
	if (dstr.pszBuffer)
		return ConvertStringToBstr(dstr.pszBuffer, CP_ACP, pVal);
	else
		return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
// NAME
//    PatrParser::put_SentenceFinalPunctuation
// DESCRIPTION
//    set the value of m_data.pFinalPunc
// RETURN VALUE
//    S_OK, or an appropriate COM error code
//
STDMETHODIMP PatrParser::put_SentenceFinalPunctuation(BSTR newVal)
{
	// check for valid input
	if (newVal == NULL)
	{
		return E_INVALIDARG;
	}
	char * pszChars;
	HRESULT hr = ConvertBstrToString(newVal, m_iCodePage, &pszChars);
	if (FAILED(hr))
	{
		return hr;
	}
	clearPATRSentenceFinalPunctuation(&m_data);
	char * psz;
	for (psz = strtok(pszChars, (char *)szWhitespace_g) ;
		 psz ;
		 psz = strtok(NULL, (char *)szWhitespace_g) )
	{
		addPATRSentenceFinalPunctuation(&m_data, psz);
	}
	free(pszChars);
	return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
// NAME
//    PatrParser::OpenLog
// DESCRIPTION
//    open a log file for future operations.
// RETURN VALUE
//    S_OK, or an appropriate COM error code
//
STDMETHODIMP PatrParser::OpenLog(BSTR bstrLogFile)
{
	// check for valid input
	if (bstrLogFile == NULL)
	{
		return E_INVALIDARG;
	}
	char * pszFile;
	HRESULT hr = ConvertBstrToString(bstrLogFile, CP_ACP, &pszFile);
	if (FAILED(hr))
	{
		return hr;
	}
	// close the old log file (if any) and open the new
	if (m_data.pLogFP != NULL)
	{
		fclose(m_data.pLogFP);
		m_data.pLogFP = NULL;
	}
	if (m_pszLogFile != NULL)
	{
		free((void *)m_pszLogFile);
		m_pszLogFile = NULL;
	}
	FILE * pfile = fopen(pszFile, "w");
	if (pfile == NULL)
	{
		return E_FAIL;
	}
	// save the log filename and FILE pointer
	m_pszLogFile = pszFile;
	m_data.pLogFP = pfile;
	return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
// NAME
//    PatrParser::CloseLog
// DESCRIPTION
//    close any open log file
// RETURN VALUE
//    S_OK, or an appropriate COM error code
//
STDMETHODIMP PatrParser::CloseLog()
{
	if ((m_data.pLogFP == NULL) && (m_pszLogFile == NULL))
	{
		return E_UNEXPECTED;
	}
	// close the old log file
	if (m_data.pLogFP != NULL)
	{
		fclose(m_data.pLogFP);
		m_data.pLogFP = NULL;
	}
	if (m_pszLogFile != NULL)
	{
		free((void *)m_pszLogFile);
		m_pszLogFile = NULL;
	}
	return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
// NAME
//    PatrParser::get_LogFile
// DESCRIPTION
//    return (indirectly) the current log filename as a BSTR, or NULL if no
//    log file is currently open
// RETURN VALUE
//    S_OK, or an appropriate COM error code
//
STDMETHODIMP PatrParser::get_LogFile(BSTR * pVal)
{
	// check for valid input
	if (pVal == NULL)
	{
		return E_POINTER;
	}
	*pVal = NULL;
	// convert the current log filename (if there is one) to a BSTR
	if (m_pszLogFile != NULL)
	{
		return ConvertStringToBstr(m_pszLogFile, CP_ACP, pVal);
	}
	else
	{
		return S_OK;
	}
}

///////////////////////////////////////////////////////////////////////////////
// NAME
//    PatrParser::get_CodePage
// DESCRIPTION
//    get the value of m_iCodePage, used for translating between Unicode and
//    8-bit character strings
// RETURN VALUE
//    S_OK, or an appropriate COM error code
//
STDMETHODIMP PatrParser::get_CodePage(long * pVal)
{
	// check for valid input
	if (pVal == NULL)
	{
		return E_POINTER;
	}
	*pVal = (long)m_iCodePage;
	return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
// NAME
//    PatrParser::put_CodePage
// DESCRIPTION
//    set the value of m_iCodePage, used for translating between Unicode and
//    8-bit character strings
// RETURN VALUE
//    S_OK, or an appropriate COM error code
//
STDMETHODIMP PatrParser::put_CodePage(long newVal)
{
	m_iCodePage = (UINT)newVal;
	return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
// NAME
//    PatrParser::DisambiguateAnaFile
// DESCRIPTION
//    Disambiguate the word analyses in an AMPLE Analysis (.ana) file, writing
//    a new Analysis file with the disambiguated word analyses.
// RETURN VALUE
//    S_OK, or an appropriate COM error code
//
STDMETHODIMP PatrParser::DisambiguateAnaFile(BSTR bstrInput, BSTR bstrOutput)
{
	// check for valid input
	if ((bstrInput == NULL) || (bstrOutput == NULL))
	{
		return E_INVALIDARG;
	}
	// open the files
	char * pszInput;
	HRESULT hr = ConvertBstrToString(bstrInput, CP_ACP, &pszInput);
	if (FAILED(hr))
	{
		return hr;
	}
	FILE * pfileIn = fopen(pszInput, "r");
	if (pfileIn == NULL)
	{
		free(pszInput);
		return E_FAIL;
	}
	char * pszOutput;
	hr = ConvertBstrToString(bstrOutput, CP_ACP, &pszOutput);
	if (FAILED(hr))
	{
		free(pszInput);
		fclose(pfileIn);
		return hr;
	}
	FILE * pfileOut = fopen(pszOutput, "w");
	if (pfileOut == NULL)
	{
		free(pszOutput);
		free(pszInput);
		fclose(pfileIn);
		return E_FAIL;
	}

	unsigned cSentences = 0;
	unsigned cAmbiguity;
	unsigned num_sentences = 0;
	WordTemplate ** wtp;
	int i;
	unsigned successes[11];
	for ( i = 0 ; i < 11 ; ++i )
		successes[i] = 0;
	for (;;)
	{
		wtp = readSentenceOfTemplates(pfileIn, pszInput, m_data.pFinalPunc,
			&m_sTextCtl, m_data.pLogFP);
		if (wtp == NULL)
			break;
		cAmbiguity = parseAmpleSentenceWithPATR(wtp, pfileOut, pszOutput,
			FALSE, FALSE, m_bWriteAmpleParses, num_sentences + 1,
			&m_sTextCtl, &m_data);

		if (cAmbiguity < 10)
			++successes[cAmbiguity];
		else
			++successes[10];
		++cSentences;
#ifndef hab126
		++num_sentences;
#endif // hab126
	}
	fclose(pfileIn);
	free((void *)pszInput);

#ifndef hab1291
	if (m_data.pLogFP != NULL)
	{
		 fprintf(m_data.pLogFP, "\n\nFile parsing statistics: %u sentences read\n",
			 cSentences);
		 for ( i = 0 ; i < 10 ; ++i )
		 {
		  if (successes[i])
			fprintf(m_data.pLogFP, "    %8u sentence%s with %d parse%s\n",
				successes[i], (successes[i] == 1) ? " " : "s",
				i, (i == 1) ? "" : "s");
		 }
		 if (successes[10])
		   fprintf(m_data.pLogFP,
			   "    %8u sentence%s with 10 or more parses\n",
			   successes[10], (successes[10] == 1) ? " " : "s");

		 unsigned num_parsed;
		 unsigned percent_parsed;
		 unsigned frac_percent;
		 num_parsed = cSentences - successes[0];
		 if (cSentences == 0)
		 {
			  percent_parsed = 0;
		  frac_percent   = 0;
		 }
		 else
		 {
			  percent_parsed = (100 * num_parsed) / cSentences;
		  frac_percent = (100 * num_parsed) % cSentences;
		  frac_percent = (frac_percent * 10) / cSentences;
		 }
		 fprintf(m_data.pLogFP, "%u of %u (%u.%u %%) parsed at least once\n",
			 num_parsed, cSentences, percent_parsed, frac_percent);
	}
#else /* hab1291 */
	fprintf(pfileOut, "\n\nFile parsing statistics: %u sentences read\n",
		cSentences);
	for ( i = 0 ; i < 10 ; ++i )
	{
		if (successes[i])
			fprintf(pfileOut, "    %8u sentence%s with %d parse%s\n",
				successes[i], (successes[i] == 1) ? " " : "s",
				i, (i == 1) ? "" : "s");
	}
	if (successes[10])
		fprintf(pfileOut,
			"    %8u sentence%s with 10 or more parses\n",
			successes[10], (successes[10] == 1) ? " " : "s");

	unsigned num_parsed;
	unsigned percent_parsed;
	unsigned frac_percent;
	num_parsed = cSentences - successes[0];
	if (cSentences == 0)
	{
		percent_parsed = 0;
		frac_percent   = 0;
	}
	else
	{
		percent_parsed = (100 * num_parsed) / cSentences;
		frac_percent = (100 * num_parsed) % cSentences;
		frac_percent = (frac_percent * 10) / cSentences;
	}
	fprintf(pfileOut, "%u of %u (%u.%u %%) parsed at least once\n",
		num_parsed, cSentences, percent_parsed, frac_percent);
#endif /* hab1291 */

	fclose(pfileOut);
	free((void *)pszOutput);

	return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
// NAME
//    PatrParser::get_WriteAmpleParses
// DESCRIPTION
//    Get the flag whether to write syntactic parse trees to the disambiguated
//    Analysis file created by a call to the DisambiguateAnaFile method.
// RETURN VALUE
//    S_OK, or an appropriate COM error code
//
STDMETHODIMP PatrParser::get_WriteAmpleParses(BOOL * pVal)
{
	// check for valid input
	if (pVal == NULL)
	{
		return E_POINTER;
	}
	*pVal = (BOOL)(m_bWriteAmpleParses ? COM_TRUE : COM_FALSE);
	return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
// NAME
//    PatrParser::put_WriteAmpleParses
// DESCRIPTION
//    Set the flag whether to write syntactic parse trees to the disambiguated
//    Analysis file created by a call to the DisambiguateAnaFile method.
// RETURN VALUE
//    S_OK, or an appropriate COM error code
//
STDMETHODIMP PatrParser::put_WriteAmpleParses(BOOL newVal)
{
	m_bWriteAmpleParses = newVal ? TRUE : FALSE;
	return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
// NAME
//    PatrParser::LoadAnaFile
// DESCRIPTION
//    Load an AMPLE Analysis (.ana) file as a lexicon file, erasing anything
//    previously loaded unless fAdd is TRUE.  On an error return, the entire
//    lexicon in memory may be empty, even if you were trying to add to an
//    already loaded lexicon.
// RETURN VALUE
//    S_OK, or an appropriate COM error code
//
STDMETHODIMP PatrParser::LoadAnaFile(BSTR bstrAnaFile, BOOL fAdd)
{
	return LoadLexicon(bstrAnaFile, fAdd, true);
}

///////////////////////////////////////////////////////////////////////////////
// NAME
//    PatrParser::ReloadLexicon
// DESCRIPTION
//    Clear the lexicon from memory, and reload the current set of lexicon
//    files.  If any of the files fails to load, it is removed from the list
//    of loaded files.  Only if none of the files loads successfully is an
//    error returned.  If no lexicon files are currently loaded, the function
//    returns immediately, reporting success.
// RETURN VALUE
//    S_OK, or an appropriate COM error code
//
STDMETHODIMP PatrParser::ReloadLexicon()
{
	if (m_uiLexFileCount == 0)
		return S_OK;
	freePATRLexicon(&m_data);	/* remove existing lexicon */
	unsigned i;
	unsigned uiSucceed = 0;
	int bSucceed;
	for ( i = 0 ; i < m_uiLexFileCount ; ++i )
	{
		if (m_pbAnaLexFile[i])
			bSucceed = loadPATRLexiconFromAmple(m_ppszLexFiles[i], &m_sTextCtl,
				&m_data);
		else
			bSucceed = loadPATRLexicon(m_ppszLexFiles[i], &m_data);
		if (bSucceed)
		{
			++uiSucceed;
		}
		else
		{
			free((void *)m_ppszLexFiles[i]);
			m_ppszLexFiles[i] = NULL;
		}
	}
	if (uiSucceed == 0)
	{
		m_uiLexFileCount = 0;
		return E_FAIL;
	}
	if (uiSucceed < m_uiLexFileCount)
	{
		unsigned j;
		for ( j = 0, i = 0 ; i < m_uiLexFileCount ; ++i )
		{
			if (m_ppszLexFiles[i] != NULL)
			{
				if (j < i)
				{
					m_ppszLexFiles[j] = m_ppszLexFiles[i];
					m_ppszLexFiles[i] = NULL;
				}
				++j;
			}
		}
		assert(j == uiSucceed);
		m_uiLexFileCount = uiSucceed;
	}
	return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
// NAME
//    PatrParser::get_LexiconFileCount
// DESCRIPTION
//    Return (indirectly) the number of lexicon files currently loaded.
// RETURN VALUE
//    S_OK, or an appropriate COM error code
//
STDMETHODIMP PatrParser::get_LexiconFileCount(long * pVal)
{
	// check for valid input
	if (pVal == NULL)
		return E_POINTER;
	*pVal = (long)m_uiLexFileCount;
	return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
// NAME
//    PatrParser::ConvertBstrToString
// DESCRIPTION
//    convert a Unicode BSTR to a C-style string
// RETURN VALUE
//    S_OK, or an appropriate COM error code
//
HRESULT PatrParser::ConvertBstrToString(const BSTR bstr_in,
	UINT iCodePage,
	char ** ppsz_out)
{
	if ((bstr_in == NULL) || (ppsz_out == NULL))
	{
		return E_UNEXPECTED;
	}
	int cchw = SysStringLen(bstr_in);
	int cb = WideCharToMultiByte(iCodePage, 0, bstr_in, cchw, NULL, 0,
		NULL, NULL);
	if (cb == 0)
	{
		return E_INVALIDARG;
	}
	char * psz = (char *)malloc(cb + 1);
	if (psz == NULL)
	{
		return E_OUTOFMEMORY;
	}
	WideCharToMultiByte(iCodePage, 0, bstr_in, cchw, psz, cb, NULL, NULL);
	psz[cb] = '\0';
	*ppsz_out = psz;
	return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
// NAME
//    PatrParser::ConvertStringToBstr
// DESCRIPTION
//    Convert a C-style string to a Unicode BSTR.
// RETURN VALUE
//    S_OK, or an appropriate COM error code
//
HRESULT PatrParser::ConvertStringToBstr(const char * psz,
	UINT iCodePage,
	BSTR * pbstr)
{
	int cchw = MultiByteToWideChar(iCodePage, 0, psz, -1, NULL, 0);
	if (cchw == 0)
	{
		return E_UNEXPECTED;
	}
	BSTR bstr = SysAllocStringLen(NULL, cchw);
	if (bstr == NULL)
	{
		return E_OUTOFMEMORY;
	}
	MultiByteToWideChar(iCodePage, 0, psz, -1, bstr, cchw);
	bstr[cchw] = 0;
	*pbstr = bstr;
	return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
// NAME
//    PatrParser::LoadLexicon
// DESCRIPTION
//    Load either a PC-PATR (word) lexicon file or an AMPLE Analysis (.ana)
//    file into the lexicon in memory.
// RETURN VALUE
//    S_OK or an appropriate COM error code
//
HRESULT PatrParser::LoadLexicon(BSTR bstrFile, BOOL fAdd, bool bAna)
{
	// check for valid input
	if (bstrFile == NULL)
		return E_INVALIDARG;

	// convert the filename from 16-bit Unicode to 8-bit ANSI
	unsigned i;
	char * pszFile;
	HRESULT hr = ConvertBstrToString(bstrFile, CP_ACP, &pszFile);
	if (FAILED(hr))
		return hr;

	if (!fAdd)
	{
		// Erase the old lexicon.
		if (m_data.pLexicon != NULL)
		{
			freePATRLexicon( &m_data );
		}
		if (m_ppszLexFiles != NULL)
		{
			for ( i = 0 ; i < m_uiLexFileCount ; ++i )
			{
				free((void *)m_ppszLexFiles[i]);
				m_ppszLexFiles[i] = NULL;
			}
			memset(m_pbAnaLexFile, 0, m_uiLexFileAlloc);
			m_uiLexFileCount = 0;
		}
	}
	else
	{
		// Check whether this lexicon file has already been loaded.
		for ( i = 0 ; i < m_uiLexFileCount ; ++i )
		{
			if (stricmp(pszFile, m_ppszLexFiles[i]) == 0)
				return E_INVALIDARG;
		}
	}

	// Load the new lexicon.
	int bSucceed;
	if (bAna)
		bSucceed = loadPATRLexiconFromAmple(pszFile, &m_sTextCtl, &m_data);
	else
		bSucceed = loadPATRLexicon(pszFile, &m_data);
	if (bSucceed)
	{
		if (m_uiLexFileCount >= m_uiLexFileAlloc)
		{
			const char ** ppsz;
			char * pb;
			unsigned uiAlloc = (m_uiLexFileAlloc + 15) * sizeof(const char *);
			if (m_ppszLexFiles == NULL)
			{
				ppsz = (const char **)malloc(uiAlloc);
				pb = (char *)malloc(m_uiLexFileAlloc + 15);
			}
			else
			{
				ppsz = (const char **)realloc(m_ppszLexFiles, uiAlloc);
				pb = (char *)realloc(m_pbAnaLexFile, m_uiLexFileAlloc + 15);
			}
			if ((ppsz == NULL) || (pb == NULL))
			{
				// We ran out of memory!?  Get back into a deterministic state.
				if (m_ppszLexFiles == NULL)
				{
					if (ppsz)
						free((void *)ppsz);
					if (pb)
						free((void *)pb);
				}
				else
				{
					unsigned i;
					for ( i = 0 ; i < m_uiLexFileCount ; ++i )
					{
						free((void *)m_ppszLexFiles[i]);
						m_ppszLexFiles[i] = NULL;
					}
					free((void *)m_ppszLexFiles);
					free(m_pbAnaLexFile);
					m_ppszLexFiles = NULL;
					m_pbAnaLexFile = NULL;
					m_uiLexFileCount = 0;
					m_uiLexFileAlloc = 0;
				}
				freePATRLexicon( &m_data );
				free(pszFile);
				return E_OUTOFMEMORY;
			}
			else
			{
				m_ppszLexFiles = ppsz;
				m_pbAnaLexFile = pb;
				m_uiLexFileAlloc += 15;
			}
		}
		m_ppszLexFiles[m_uiLexFileCount] = pszFile;
		m_pbAnaLexFile[m_uiLexFileCount] = bAna;
		++m_uiLexFileCount;
		return S_OK;
	}
	else
	{
		free(pszFile);
		return E_FAIL;
	}
}

///////////////////////////////////////////////////////////////////////////////
// NAME
//    PatrParser::get_PromoteDefaultAtoms
// DESCRIPTION
//    Get the flag whether to promote default atomic feature values loaded from
//    the lexicon to ordinary atomic feature values before parsing.
// RETURN VALUE
//    S_OK, or an appropriate COM error code
//
STDMETHODIMP PatrParser::get_PromoteDefaultAtoms(BOOL * pVal)
{
	// check for valid input
	if (pVal == NULL)
	{
		return E_POINTER;
	}
	*pVal = (BOOL)(m_data.bPromoteDefAtoms ? COM_TRUE : COM_FALSE);
	return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
// NAME
//    PatrParser::put_PromoteDefaultAtoms
// DESCRIPTION
//    Set the flag whether to promote default atomic feature values loaded from
//    the lexicon to ordinary atomic feature values before parsing.
// RETURN VALUE
//    S_OK, or an appropriate COM error code
//
STDMETHODIMP PatrParser::put_PromoteDefaultAtoms(BOOL newVal)
{
	m_data.bPromoteDefAtoms = newVal ? TRUE : FALSE;
	return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
// NAME
//    PatrParser::get_AmplePropertyIsFeature
// DESCRIPTION
//    Get the flag whether to promote default atomic feature values loaded from
//    the lexicon to ordinary atomic feature values before parsing.
// RETURN VALUE
//    S_OK, or an appropriate COM error code
//
STDMETHODIMP PatrParser::get_AmplePropertyIsFeature(BOOL * pVal)
{
	// check for valid input
	if (pVal == NULL)
	{
		return E_POINTER;
	}
	*pVal = (BOOL)(m_data.bPropIsFeature ? COM_TRUE : COM_FALSE);
	return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
// NAME
//    PatrParser::put_AmplePropertyIsFeature
// DESCRIPTION
//    Set the flag whether to promote default atomic feature values loaded from
//    the lexicon to ordinary atomic feature values before parsing.
// RETURN VALUE
//    S_OK, or an appropriate COM error code
//
STDMETHODIMP PatrParser::put_AmplePropertyIsFeature(BOOL newVal)
{
	m_data.bPropIsFeature = newVal ? TRUE : FALSE;
	return S_OK;
}

// Local Variables:
// mode:C++
// c-file-style:"cellar"
// compile-command:"nmake -f Patr100.mak"
// End:

// EDIT HISTORY
// 15-Jun-2001  hab  - Put sentence statistics in log file not in ANA file
// [1.2.9.1]             when doing PatrParser::DisambiguateAnaFile()
