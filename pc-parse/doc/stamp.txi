\input pcparse % common TeX setup  @c -*-texinfo-*-
\input texinfo
@c %**start of header
@setfilename stamp.info
@settitle STAMP Reference Manual
@c %**end of header

@syncodeindex fn cp
@set stamp

@set TITLE STAMP Reference Manual
@set SUBTITLE Synthesizing after Transferring AMPLE Analyses
@set VERSION version 2.3.0
@set DATE June 2016
@set AUTHOR by Stephen McConnel (and H. Andrew Black for v. 2.1b1 and above)
@set COPYRIGHT Copyright @copyright{} 2000-2016 SIL International

@include front.txi

@c ----------------------------------------------------------------------------
@node    Top,       Introduction,  (dir),    (dir)
@comment node-name, next,          previous, up

@ifinfo
@ifclear txt
This is the reference manual for the STAMP program.
@end ifclear
@end ifinfo

@menu
* Introduction::
* Running STAMP::
* Standard format::
* STAMP declarations file::
* Transfer file::
* Synthesis file::
* Dictionary code table file::
* Dictionary orthography change table file::
* Dictionary files::
* Text output control file::
* Analysis files::
* Bibliography::
* Index::
@end menu

@c ----------------------------------------------------------------------------
@node    Introduction, Running STAMP, Top,      Top
@comment node-name,    next,            previous, up
@chapter Introduction to the STAMP program

This manual describes STAMP, a computer program for adapting text in
conjunction with the AMPLE program.  This combination falls under the
Analysis Transfer Synthesis (ATS) paradigm.  It involves the following
steps:

(1) AMPLE is a morphological parser that is applied to source language
	text to analyze each word into morphemes.

(2) STAMP is applied to these analyses to make changes that will produce
	the corresponding target language word.

(3) An interactive editor is applied to STAMP output to correct the
	words that AMPLE failed to analyze and for which AMPLE and STAMP
	produced multiple possibilities.  The result is a word-for-word draft
	of the source language text in the target language.

(4) After eliminating analysis failures and ambiguities, the text must be
	checked and corrected by a competent speaker of the target language.

STAMP incorporates no language-specific facts; the user makes linguistic
facts known to STAMP entirely through external files.  STAMP is
sufficiently general to serve over a wide range of language families.
(However, AMPLE and STAMP do not adequately handle highly isolating
languages, that is, languages which have virtually no morphology.)

The name STAMP is derived by taking AMP from AMPLE, and T and S from
STAMP's main modules, TRANSFER and SYNTHESIS, which are applied in
succession to the output of AMPLE.  Thus one can think of STAMP as
S(T(AMP)), or more explicitly as:
@example

@r{adapted text = Synthesis[Transfer[AMPLE[source text]]]}

@end example

Note: much of this reference manual is based almost verbatim on the book
published in 1990 (Weber, Black, McConnel, and Buseman), without explicit
permission from the coauthors.

@c Following added by hab 14-May-1999
@subsubheading New features
@table @asis

@item 1. Version 2.1 (May 1999) introduced punctuation environment constraints in the allomorph fields of the dictionary files.  These are handled by a new built-in test called PEC_ST.  This version also added two punctuation-oriented clauses to user-written tests.

@item 2. Version 2.1b17 (October 2003) filled out several sections which previously had missing content.

@item 3. Version 2.2.0 (January 2004) added negative string environment constraints.

@end table

@c ----------------------------------------------------------------------------
@node Running STAMP, Standard format, Introduction, Top
@chapter Running STAMP

STAMP is a batch process oriented program.  It reads a number of control
files, and then processes one or more input analysis files to produce an
equal number of output files.

@menu
* Command options::
* Interaction::
@end menu

@c ----------------------------------------------------------------------------
@node Command options, Interaction, Running STAMP, Running STAMP
@section STAMP Command Options

The STAMP program uses an old-fashioned command line interface
following the convention of options starting with a dash character
(@samp{-}).  The available options are listed below in alphabetical
order.  Those options which require an argument have the argument type
following the option letter.

@ftable @code
@item -a
causes all possible syntheses to be generated.

@item -c character
selects the control file comment character.  The default is the vertical
bar (@code{|}).

@item -d number
selects the maximum dictionary trie depth.  The default is 2, which
favors reduced memory needs over speed.

@item -f filename
opens a command file containing the names of the control and data
files.  The default is to read those names from the standard input
(keyboard); see
@ifset txt
`Program Interaction' below.
@end ifset
@ifclear txt
@ref{Interaction}.
@end ifclear

@item -i filename
selects a single input analysis file.

@item -m
monitors progress of an analysis: @code{*} means an analysis failure,
@code{.} means a single analysis, @code{2}@value{endash}@code{9} means
2@value{endash}9 ambiguities, and @code{>} means 10 or more ambiguities.
This is not compatible with the @samp{-q} option.

@item -n
prevents root categories from being checked.

@item -o filename
selects a single output text (or analysis if the @samp{-x} option is also
selected) file.

@item -q
causes AMPLE to operate ``quietly'' with minimal screen output.  This
is not compatible with the @samp{-m} option.

@item -r
causes morphnames that are not found in the dictionary to be reported.

@item -t
causes the transfer and synthesis processes to be traced.  This produces
a huge amount of output.
@c Repeating the @code{-t} option causes SGML style trace output to be
@c produced.

@item -u
signals that dictionaries are unified, not split into prefix, infix,
suffix, and root files.

@item -v
verifies tests by pretty printing the parse trees.

@item -x
restricts STAMP to only the transfer process.
@end ftable

The following options exist only in beta-test versions of the program,
since they are used only for debugging.

@ftable @code
@item -/
increments the debugging level.  The default is zero (no debugging output).

@item -z filename
opens a file for recording a memory allocation log.

@item -Z address,count
traps the program at the point where @code{address} is allocated or
freed for the @code{count}'th time.
@end ftable

@c ----------------------------------------------------------------------------
@node Interaction, , Command options, Running STAMP
@section Program Interaction

If the @samp{-f}, @samp{-i}, and @samp{-o} command options are not
used, STAMP prompts for a number of file names, reading the standard
input for the desired values.  The interactive dialog goes like this:
@example

@group
C> stamp
STAMP: Synthesis(Transfer(AMPle(text))) = adapted text
Version 2.0b1 (July 21, 1998), Copyright 1998 SIL, Inc.
Beta test version compiled Jul 27 1998 16:04:11
	   Transfer/Synthesis Performed Tue Jul 28 14:54:04 1998
STAMP declarations file (zzSTAMP.DEC): pnstamp.dec
Transfer file (xxzzTR.CHG) [none]: hgpntr.chg
Synthesis file (zzSYNT.CHG) [none]: pnsynt.chg
Dictionary code table (zzSYCD.TAB): pnsycd.tab
Dictionary orthography change table (zzORDC.TAB) [none]: pnordc.tab
	10 changes loaded from suffix dictionary code table.
Suffix dictionary file (zzSF01.DIC): pnsf01.dic
		SUFFIX DICTIONARY: Loaded 137 records
	10 changes loaded from root dictionary code table.
Root dictionary file (xxRTnn.DIC): pnsyrt.dic
		ROOT DICTIONARY: Loaded 176 records
Next Root dictionary file (xxRTnn.DIC) [no more]:
Output text control file (zzOUTTX.CTL) [none]: pnoutx.ctl
10 output orthography changes were loaded from pnoutx.ctl

First Input file: pntest.ana
Output file: pntest.syn

Next Input file (or RETURN if no more):
C>
@end group

@end example
@noindent
Note that each prompt contains a reminder of the expected form of the
answer in parentheses and ends with a colon.  Several of the prompts
also contain the default answer in brackets.

Using the command options does not change the appearance of the program
screen output significantly, but the program displays the answers to
each of its prompts without waiting for input.  Assume that the file
@file{pntest.cmd} contains the following, which is the same as the
answers given above:
@example

@group
pnstamp.dec
hgpntr.chg
pnsynt.chg
pnsycd.tab
pnordc.tab
pnsf01.dic
pnsyrt.dic

pnoutx.ctl
@end group

@end example
@noindent
Then running STAMP with the command options produces screen output like
the following:
@example

@group
C> stamp -f pntest.cmd -i pntest.ana -o pntest.syn
STAMP: Synthesis(Transfer(AMPle(text))) = adapted text
Version 2.0b1 (July 21, 1998), Copyright 1998 SIL, Inc.
Beta test version compiled Jul 27 1998 16:04:11
	   Transfer/Synthesis Performed Tue Jul 28 14:59:34 1998
STAMP declarations file (zzSTAMP.DEC): pnstamp.dec
Transfer file (xxzzTR.CHG) [none]: hgpntr.chg
Synthesis file (zzSYNT.CHG) [none]: pnsynt.chg
Dictionary code table (zzSYCD.TAB): pnsycd.tab
Dictionary orthography change table (zzORDC.TAB) [none]: pnordc.tab
	10 changes loaded from suffix dictionary code table.
Suffix dictionary file (zzSF01.DIC): pnsf01.dic
		SUFFIX DICTIONARY: Loaded 137 records
	10 changes loaded from root dictionary code table.
Root dictionary file (xxRTnn.DIC): pnsyrt.dic
		ROOT DICTIONARY: Loaded 176 records
Next Root dictionary file (xxRTnn.DIC) [no more]:
Output text control file (zzOUTTX.CTL) [none]: pnoutx.ctl
10 output orthography changes were loaded from pnoutx.ctl

C>
@end group

@end example
@noindent
The only difference in the screen output is that the prompts for the
input text file and the output analysis file are not displayed.

@c ----------------------------------------------------------------------------
@node Standard format, STAMP declarations file, Running STAMP, Top
@chapter Standard format
@include stdfmt.txi

@c ----------------------------------------------------------------------------
@node STAMP declarations file, Transfer file, Standard format, Top
@chapter STAMP Declarations File

The fields that STAMP recognizes in its "declarations file" are described
below.  Fields that start with any other backslash codes are ignored by
STAMP.

@c \maxprops and \pcl added by hab 14-May-1999
@menu
* \ambig (zzSTAMP.DEC)::  Analytic ambiguity delimiter
* \ap::                   Allomorph property declaration
* \ca::                   Category declarations
* \cat (zzSTAMP.DEC)::    Category output control
* \ccl::                  Category class declaration
* \maxprops::             Maximum number of properties
* \mcl::                  Morpheme class declaration
* \mp::                   Morpheme property declaration
* \pcl::                  Punctuation class
* \rd::                   Root delimiter
* \scl (zzSTAMP.DEC)::    String class declaration
* \strcheck::             Valid allomorph and string environment characters
@end menu

@c ----------------------------------------------------------------------------
@node \ambig (zzSTAMP.DEC), \ap, STAMP declarations file, STAMP declarations file
@section Analytic ambiguity delimiter: \ambig
@findex \ambig

When AMPLE produces more than one analysis, each analysis is set off by a
unique character.  Likewise, when AMPLE fails to analyze a source
language word, it flags this word with the same character, the default
for which is a percent sign (@code{%}).  However, a user may override
AMPLE's default.

Like AMPLE, STAMP assumes this delimiter to be a percent sign.  If an
analyzed text does not use this character, STAMP must be informed as to
what character was used.  To do this, use the \ambig field to define the
desired character.  For example, the following would change the analytic
ambiguity delimiter to @code{@@}:
@example

\ambig @@

@end example

@c ----------------------------------------------------------------------------
@c Edited slightly by hab 14-May-1999 to reflect \maxprops
@node \ap, \ca, \ambig (zzSTAMP.DEC), STAMP declarations file
@section Allomorph property declaration: \ap
@findex \ap

Allomorph properties are defined by the field code @code{\ap} followed
by one or more allomorph property names.  An allomorph property name
must be a single, contiguous sequence of printing characters.
Characters and words which have special meanings in tests should not be
used.  For example, the following would declare the allomorph properties
@code{deletedK}, @code{deletedG}, and @code{underlyingV}:

@example

@group
\ap deletedK deletedG  | elided morpheme final velars
\ap underlyingV        | underlying long vowel
@end group

@end example

A maximum of 255 properties (including both allomorph and morpheme
properties) may be defined unless the @code{\maxprops} field is used to
define a larger number.  Any number of @code{\ap} fields may be
used so long as the number of property names does not exceed 255 (or the
number defined by the @code{\maxprops} field).  Note that any
@code{\maxprops} field must occur before any @code{\ap} or @code{\mp}
fields.

@c ----------------------------------------------------------------------------
@node \ca, \cat (zzSTAMP.DEC), \ap, STAMP declarations file
@section Category declarations: \ca
@findex \ca

Categories are defined by the field code @code{\ca} followed by one or
more category names.  A category name must be a single, contiguous
sequence of printing characters.  Characters and words which have
special meanings in tests should not be used.

A maximum of 255 categories may be defined.  Any number of @code{\ca}
fields may be used so long as the number of category names does not
exceed 255.

@c ----------------------------------------------------------------------------
@node \cat (zzSTAMP.DEC), \ccl, \ca, STAMP declarations file
@section Category output control: \cat
@findex \cat

The category information to write to the analysis output file is
defined by the field code @code{\cat} followed by one or two words.
The first word must be either @code{prefix} or @code{suffix} (or an
abbreviation of one of those words), either capitalized or lowercase.

The @code{\cat} field may appear any number of times, but once is
enough.  If more than one such field occurs, the last one is the one
that is used.

NOTE: at present, this does not do anything in the code.  Is this a
feature that has never been used?  When was it introduced?  I'd be quite
willing to rip it out of the code.

@c ----------------------------------------------------------------------------
@node \ccl, \maxprops, \cat (zzSTAMP.DEC), STAMP declarations file
@section Category class declaration: \ccl
@findex \ccl

A category class declaration has three parts: the field code @code{\ccl},
the name of the class, and the list of categories in the class (separated
by spaces).  For example, the following defines the class @code{IVERB}
containing the categories @code{V1X} and @code{V1Y}:
@example

\ccl IVERB V1X V1Y

@end example
@noindent
The class name must be a single, contiguous sequence of printing
characters.  Characters and words which have special meanings in tests
should not be used.  The category names must have been defined by an
earlier @code{\ca} field; see
@ifset txt
`Category declarations' above.
@end ifset
@ifclear txt
@ref{\ca}.
@end ifclear

In transfer, category classes can only be used in the match strings of
lexical changes; see
@ifset txt
`Lexical change' below.
@end ifset
@ifclear txt
@ref{\lc}.
@end ifclear

Each @code{\ccl} field defines a single category class.  Any number of
@code{\ccl} fields may appear in the file.

@c ----------------------------------------------------------------------------
@c Following added by hab 14-May-1999
@node \maxprops, \mcl, \ccl, STAMP declarations file
@section Maximum number of properties: \maxprops
@findex \maxprops

The maximum number of properties that can be defined can be increased
from the default of 255 by giving the @code{\maxprops} field code
followed by a number greater than or equal to 255 but less than 65536.

The @code{\maxprops} field may appear any number of times, but once is
enough.  If more than one such field occurs, the one containing the
largest valid value is the one that is used.

The @code{\maxprops} must be used before any properties are defined.
This is the case for both morpheme and allomorph properties.

If no @code{\maxprops} fields appear in the declarations file, then
STAMP limits the number of properties which can be defined to 255.

@c ----------------------------------------------------------------------------
@node \mcl, \mp, \maxprops, STAMP declarations file
@section Morpheme class declaration: \mcl
@findex \mcl

A morpheme class declaration has three parts: the field code @code{\mcl},
the name of the class, and the list of morphnames in the class (separated
by spaces).  For example, a morpheme class @code{DIRECTION} could be
defined as follows:
@example

\mcl DIRECTION UP DOWN IN OUT

@end example
@noindent
Such a class could be used in conditioning environments for lexical
changes, insertion rules, or substitution rules.  For example, the
following environment would limit the rule to apply only preceding one
of the directional morphemes:
@example

/ _ [DIRECTION]

@end example

The class name must be a single, contiguous sequence of printing
characters.  Characters and words which have special meanings in tests
should not be used.  The morpheme names should be defined by an entry
in one of the dictionary files.

Each @code{\mcl} field defines a single morpheme class.  Any number of
@code{\mcl} fields may appear in the file.

@c ----------------------------------------------------------------------------
@c Edited slightly by hab 14-May-1999 to reflect \maxprops
@node \mp, \pcl, \mcl, STAMP declarations file
@section Morpheme property declaration: \mp
@findex \mp

Morpheme properties are defined by the field code @code{\mp} followed by
one or more morpheme property names.  A morpheme property name must be a
single, contiguous sequence of printing characters.  Characters and words
which have special meanings in tests should not be used.  For example,
the following would declare the morpheme properties @code{XYZ},
@code{ABC}, and @code{DEF}:
@example

@group
\mp XYZ
\mp ABC DEF
@end group

@end example

A maximum of 255 properties (including both allomorph and morpheme
properties) may be defined unless the @code{\maxprops} field is used to
define a larger number.  Any number of @code{\mp} fields may be
used so long as the number of property names does not exceed 255 (or the
number defined by the @code{\maxprops} field).  Note that any
@code{\maxprops} field must occur before any @code{\mp} or @code{\ap}
fields.

@c ----------------------------------------------------------------------------
@c Following added by hab 14-May-1999
@node \pcl, \rd, \mp, STAMP declarations file
@section Punctuation class: \pcl
@findex \pcl

A punctuation class is defined by the field code @code{\pcl} followed
by the class name, which is followed in turn by one or more
punctuation characters or (previously defined) punctuation class
names.  A punctuation class name used as part of the class definition
must be enclosed in square brackets.

The class name must be a single, contiguous sequence of printing
characters.  The individual members of the class are separated by
spaces, tabs, or newlines.

Each @code{\pcl} field defines a single punctuation class.  Any number of
@code{\pcl} fields may appear in the file.

If no @code{\pcl} fields appear in the declarations file, then STAMP
does not allow any punctuation classes in tests, and does not allow any
punctuation classes in punctuation environment constraints.

@c ----------------------------------------------------------------------------
@node \rd, \scl (zzSTAMP.DEC), \pcl, STAMP declarations file
@section Root delimiter: \rd
@findex \rd

For each analysis, the root (or roots), and the category of the first
root, are delimited by a pair of reserved characters.  By default, AMPLE
uses wedges (@code{<} and @code{>}).  If some characters other than
wedges are used for this purpose, they must be declared using the
@code{\rd} field.  (@code{\rd} is mnemonic for "root delimiter".)  For
example, the following line might be included in the input control file:
@example

\rd ( )

@end example
@noindent
Two characters are expected after the field code, optionally separated by
white space.  The first is taken to be the opening (that is, left)
delimiter and the second is taken to be the closing (that is, right)
delimiter.  Different characters must be used for the opening and
closing delimiters.

The delimiters used to set off the root should not be used for any other
purpose in the analysis field.  The following may not be used for a
delimiter: the backslash (@code{\}), whatever character is used to
indicate analytic failures and ambiguities, or any orthographic
character.

The @code{\rd} field may appear any number of times, but once is
enough.  If more than one such field occurs, the last one is the one
that is used.

If no @code{\rd} fields appear in the declarations file, then STAMP uses
the delimiter characters @code{<} and @code{>}.

@c ----------------------------------------------------------------------------
@node \scl (zzSTAMP.DEC), \strcheck, \rd, STAMP declarations file
@section String class declaration: \scl
@findex \scl

A string class declaration has three parts: the field code @code{\scl},
the name of the class, and the list of strings in the class (separated by
spaces).  String classes are used in synthesis in specifying string
environment constraints on regular sound changes and on allomorph entries
in the dictionaries.

The class name must be a single, contiguous sequence of printing
characters.  Characters and words which have special meanings in tests
should not be used.  The actual character strings have no such
restrictions.  The individual members of the class are separated by
spaces, tabs, or newlines.

Each @code{\scl} field defines a single string class.  Any number of
@code{\scl} fields may appear in the file.

@c ----------------------------------------------------------------------------
@node \strcheck, , \scl (zzSTAMP.DEC), STAMP declarations file
@section Valid allomorph and string environment characters: \strcheck
@findex \strcheck

The characters considered to be valid for allomorph strings and string
environment constraints are defined by a @code{\strcheck} field code
followed by the list of characters.  Spaces are not significant in this
list.

The @code{\strcheck} field may appear any number of times, but once is
enough.  If more than one such field occurs, the last one is the one
that is used.

If no @code{\strcheck} fields appear in the analysis data file, then
STAMP does not check allomorph strings and string environment
constraints for containing only valid characters.

@c ----------------------------------------------------------------------------
@node Transfer file, Synthesis file, STAMP declarations file, Top
@chapter Transfer Control File

The transfer control file for the STAMP program is a standard format
file containing a single data record.  The fields that STAMP
recognizes in its ``transfer control file'' are described below. Fields that
start with any other backslash codes are ignored by STAMP


@c commented off by hab 2003.10.27
@c @menu
@c * Transfer file fields::
@c * Syntax of transfer rules::
@c * Syntax of lexical changes::
@c @end menu
@c
@c @c ----------------------------------------------------------------------------
@c @node Transfer file fields, Syntax of transfer rules, Transfer file, Transfer file
@c @section Transfer file fields
@c

@c \maxprops and \pcl added by hab 14-May-1999
@menu
* \ambig (xxzzTR.CHG)::     Analytic ambiguity delimiter *
* \ap (xxzzTR.CHG)::        Allomorph property declaration *
* \ca (xxzzTR.CHG)::        Category declarations *
* \ccl (xxzzTR.CHG)::       Category class declaration *
* \cr::                     Copy rule
* \fl::                     Flag rule
* \ir::                     Insertion rule
* \lc::                     Lexical change
* \maxprops (xxzzTR.CHG)::  Maximum number of properties *
* \mcl (xxzzTR.CHG)::       Morpheme class declaration *
* \mp (xxzzTR.CHG)::        Morpheme property declaration *
* \pcl (xxzzTR.CHG)::       Punctuation class *
* \rd (xxzzTR.CHG)::        Root delimiter *
* \scl (xxzzTR.CHG)::       String class declaration *
* \sr::                     Substitution rule
@end menu

@ifinfo
@ifclear txt
The fields marked with an asterisk above can appear in the STAMP
declarations file or the synthesis control file instead.
@end ifclear
@end ifinfo

@node \ambig (xxzzTR.CHG), \ap (xxzzTR.CHG), Transfer file, Transfer file
@section Analytic ambiguity delimiter: \ambig
@findex \ambig

This field can also occur in the STAMP declarations file or the STAMP
synthesis control file instead; see
@ifset txt
`Analytic ambiguity delimiter' in the chapter `STAMP declarations file' above.
@end ifset
@ifclear txt
@ref{\ambig (zzSTAMP.DEC)}.
@end ifclear

@c ----------------------------------------------------------------------------
@node \ap (xxzzTR.CHG), \ca (xxzzTR.CHG), \ambig (xxzzTR.CHG), Transfer file
@section Allomorph property declaration: \ap
@findex \ap

This field can also occur in the STAMP declarations file or the STAMP
synthesis control file instead; see
@ifset txt
`Allomorph property declaration' in the chapter `STAMP declarations file'
above.
@end ifset
@ifclear txt
@ref{\ap}.
@end ifclear

@c ----------------------------------------------------------------------------
@node \ca (xxzzTR.CHG), \ccl (xxzzTR.CHG), \ap (xxzzTR.CHG), Transfer file
@section Category declarations: \ca
@findex \ca

This field can also occur in the STAMP declarations file or the STAMP
synthesis control file instead; see
@ifset txt
`Category declarations' in the chapter `STAMP declarations file' above.
@end ifset
@ifclear txt
@ref{\ca}.
@end ifclear

@c ----------------------------------------------------------------------------
@node \ccl (xxzzTR.CHG), \cr, \ca (xxzzTR.CHG), Transfer file
@section Category class declaration: \ccl
@findex \ccl

This field can also occur in the STAMP declarations file or the STAMP
synthesis control file instead; see
@ifset txt
`Category class declaration' in the chapter `STAMP declarations file' above.
@end ifset
@ifclear txt
@ref{\ccl}.
@end ifclear

@c ----------------------------------------------------------------------------
@node \cr, \fl, \ccl (xxzzTR.CHG), Transfer file
@section Copy rule: \cr
@findex \cr

Suppose that a single source language morpheme corresponds to either of
two target language morphemes, where the choice between them is not
determined by any contextual factor within the word.  For example,
Huallaga Quechua -ra `PAST' (simple past) corresponds to two suffixes in
Pasco Quechua, in some cases to -rqU `RECPST' (recent past) and in other
cases to -rqa `REMPST' (remote past).  Whether the recent or remote past
tense is appropriate is a semantic matter, not determinable by any
structural factor, morphological or syntactic.

The best one can do in such a case is to create ambiguous output for
every instance of the past tense morpheme and leave the choice between
them to the person who edits the computer-adapted text.  Thus, for every
Huallaga Quechua word containing -ra `PAST' (as in 1 below) the program
should produce two Pasco Quechua words (as in 2), one with -rqU `RECPST'
and the other with -rqa `SIMPST':
@example

@group
1. aywaran
2. %2%aywarqun%aywarqan%
@end group

@end example
@noindent
This can be accomplished by means of a copying rule.  A copying rule
produces two output analyses.  It produces a copy of the input and then
the result of applying the rule as though it were a substitution rule;
see
@ifset txt
`Substitution rule' below.
@end ifset
@ifclear txt
@ref{\sr}.
@end ifclear
The only syntactic difference between a copying rule and a substitution
rule is that the former begins with the field code @code{\cr} and the
latter begins with a @code{\sr}.

@c commented off hab 2003.10.27
@c  See
@c @ifset txt
@c `Syntax of transfer rules' below
@c @end ifset
@c @ifclear txt
@c @ref{Syntax of transfer rules}
@c @end ifclear
@c for a description of the syntax for these rules.

Returning to the Quechua example, the copying rule in 3 would apply to
the analysis in 4 to produce the two analyses in 5:
@example

@group
3. \cr "PAST" "REMPST"
4. < V1 *aywa > PAST 3
5. %2%< V1 *aywa > PAST 3%< V1 *aywa > REMPST 3%
@end group

@end example

Copying rules apply to the output of previous rules in the transfer file,
and subsequent rules apply to each of the outputs.  Because subsequent
rules apply to each of the outputs of a copying rule, it is possible for
copying rules to feed copying rules.  For example, consider the two
hypothetical copying rules in a below.  If these are applied to a single
analysis containing A and Q (as schematized in 7 below), they would
produce the four analyses shown in 9.
@example

@group
6. \cr "A" "B"
   \cr "Q" "R"
7. ...A...Q...
8. %2%...A...Q...%...B...Q...%
9. %4%...A...Q...%...A...R...%...B...Q...%...B...R...%
@end group

@end example
@noindent
That is, the first rule of a produces the two analyses in 8.  Then the
the second rule of a applies to each of these outputs, producing two
outputs for each as in 9.

Note that if the original analysis had been ambiguous (with two analyses
each containing A and Q), the two copying rules would have produced an
eight-way ambiguity.  The moral: if copying rules are used too liberally,
there might be a dramatic increase in the levels of ambiguity produced.
Let the user beware!

@c ----------------------------------------------------------------------------
@node \fl, \ir, \cr, Transfer file
@section Flag rule: \fl
@findex \fl

Flags are a mechanism for temporarily remembering some information about
an analysis.  A rule conditioned by one or more flags affects an analysis
only if all the conditions implied by those flags are true for that
analysis.  Flags make it possible to "insulate" source language phenomena
from target language phenomena.

The definition of a flag has three obligatory parts: (1) the field code
@code{\fl}, (2) the name of the flag, and (3) the list of morphnames
which trigger the raising of that flag.  For example, consider the
following definition:
@example

\fl PLURAL PLIMPF PLDIR PLSTAT

@end example
@noindent
The name of the flag is @code{PLURAL}.  The morphnames whose presence
causes the flag to be raised are @code{PLIMPF}, @code{PLDIR}, and
@code{PLSTAT}.

Flag definitions are a type of rule.  Recall that rules are applied in
the order in which they are given in the transfer file.  (This excludes
lexical changes, which are applied before all rules.)  Thus, a flag is
raised only if one of the morphnames in its definition is present in the
analysis resulting from all previous rules (in the order they are given
in the transfer file).  For example, the plural flag defined above would
be raised only if @code{PLIMPF}, @code{PLDIR}, or @code{PLSTAT} were
present in an analysis at the point where the rule is defined in the
transfer file.

Suppose there are two rules.  The first deletes @code{PLIMPF}.  The next
one is a flag definition which raises the @code{PLURAL} flag whenever
@code{PLIMPF} is present in an analysis.  This flag-raising rule only
sees the result of all previous rules.  Thus it would never raise the
@code{PLURAL} flag in this case, since @code{PLIMPF} would always have
been deleted by the preceding rule.  To get the proper effect, the flag
definition rule should be ordered before the rule which deletes the
morphname that causes the flag to be raised.

Flags cannot be used in a rule until they have been defined with a
@code{\fl} field.  Sometimes it is conceptually simpler to define all the
flags at the beginning of the transfer file; in other cases it is
advantageous to define each of them close to---but preceding---the rules
which use them.

Flags may be tested in copy and substitution rules following the match
and substitution strings, or in insertion rules following the string to
be inserted.  The flag names must always precede any conditioning
environments.  A flag name can be preceded by tilde to complement the
sense of the flag; that is, a rule so modified applies only if the named
flag is not raised.

When a particular analysis has undergone all the rules of the transfer
file, all the flags are automatically lowered before another analysis is
considered.  To put it another way, flags do not stay raised from one
word to another.  Many flags are raised and never lowered until the next
word, but in some cases it is desirable to have the flags lowered before
some subsequent rule.

Whenever an analysis changes as the result of a rule that tests a flag
(or flags), then that rule's flags are automatically lowered.  The user
does not have to do anything because TRANSFER is designed to
automatically lower flags under this condition.  This avoids the
application of subsequent rules on the basis of the same flag.  For
example, consider the following rules.  (Insertion rules are discussed in
the next section.)
@example

@group
\fl XFLG M1 M2       |raise flag when M1 or M2 present
\ir "X1" XFLG / M1 _ |insert X1 after M1 when XFLG up
\ir "X2" XFLG / _ M2 |insert X2 before M2 when XFLG up
@end group

@end example
@noindent
Given an analysis with the sequence @code{M1 M2}, the result of these
changes is @code{M1 X1 M2}.  It would not be @code{M1 X1 X2 M2} because,
when the first insertion rule applies, it lowers @code{XFLG}.
Consequently, the second insertion rule does not apply.

Suppose one wished to drop a flag (say @code{PFLG}) whenever a particular
morpheme (say @code{XY}) is present in an analysis.  The following rule
would do it.  (Substitution rules are discussed below.)
@example

\sr "XY" "XY" PFLG |substitute XY for XY when PFLG up

@end example
@noindent
When this rule applies, it produces no net change in the analysis, but it
has the important side effect of dropping the @code{PFLG} flag.

Consider the following substitution rule, where the @code{FLG} flag is
followed by three environments:
@example

\sr "XX" "YY" FLG / M1 _ / M2 _ / M3 _

@end example
@noindent
This is equivalent to the following sequence of rules:
@example

@group
\sr "XX" "YY" FLG / M1 _
\sr "XX" "YY" FLG / M2 _
\sr "XX" "YY" FLG / M3 _
@end group

@end example
@noindent
Note that if the first applies, @code{FLG} is lowered so the second and
third could not apply.  Likewise, if the second applies, the third could
not apply.  Only one rule could possibly apply; transfer's behavior is
the same even when multiple environments are included in a single rule or
spread across several rules.

It is possible to limit a rule by a complemented flag, in which case the
rule applies only if the flag is not raised.  For example, definition 1
would raise the flag @code{KUFLAG} when @code{REFL}, @code{INTNS}, or
@code{CMPLT} were present, and rule 2 would insert @code{KU} when
@code{KUFLAG} is not raised and @code{INSERTKUFLAG} is raised:
@example

@group
1. \fl KUFLAG REFL INTNS CMPLT
2. \ir "KU" ~KUFLAG INSERTKUFLAG
@end group

@end example
@noindent
Note that the constraint imposed by each of these flags must be
simultaneously met for the rule to apply.

In general, a flag automatically lowers whenever a rule constrained by
that flag applies.  Note, however, that the converse is not true for a
complemented flag that constrains a rule that applies.  If rule 2 above
were to apply, then @code{INSERTKUFLAG} would be lowered but
@code{KUFLAG} would not be affected, that is, it would remain lowered.

Flags and morpheme classes have some interesting similarities and
differences.  Both are defined in the same way (but with different field
codes), and both are used as conditions on rules.  They differ, however,
in where they are used in rules: morpheme classes occur in environments,
whereas flags occur between the rule's main part and before any
conditioning environments.  Perhaps the most important difference is one
of persistence.  Once defined, a morpheme class persists until STAMP
finishes; there is simply no way to "undefine" a class.  But flags are
volatile: they are raised when certain morphemes are present in an
analysis and lowered when a rule having the flag applies effectively.

@c ----------------------------------------------------------------------------
@node \ir, \lc, \fl, Transfer file
@section Insertion rule: \ir
@findex \ir

Insertion rules insert morphnames into an analysis.  An insertion rule
may have (in order):
@enumerate

@item the field code @code{\ir},
@item the morphname to be inserted,
@item optionally one or more flags,
@item optionally one or more environments into which the morphname should be inserted, and
@item a comment.
@end enumerate
@noindent
The insertion string is delimited by some printing character.  The
morphname is inserted into an analysis if all the rule's flags are
raised (or, for complemented flags, not raised) and at least one of
its environments is satisfied (if any are specified).

Of the five parts listed above, only the first two are obligatory.
However, an insertion rule comprised only of a field code and the
morphname (without any conditioning flags or environments) would insert
the morphname into every analysis.  The following example has the first
three parts; it would insert @code{PL} whenever the @code{PLFLG} flag is
up:
@example

\ir "PL" PLFLG

@end example
@noindent
(How transfer determines where to insert @code{PL} is discussed
below.)  The following inserts @code{PXT} immediately after @code{BDJ}:
@example

\ir "PXT" / BDJ _

@end example
@noindent
The following inserts @code{PLDIR} whenever both the @code{PLURAL} flag
is up and a directional suffix (that is, a member of the class
@code{DIR}) is present.  @code{PLDIR} is inserted immediately following
the directional morpheme.
@example

\ir "PLDIR" PLURAL / [DIR] _

@end example

When an insertion rule has multiple environments, it applies only for the
first environment satisfied by a given analysis.  For example, consider
the following:
@example

\ir "PXT" / BDJ _  / QMR _

@end example
@noindent
This rule is applied in the following way.  Potential insertion sites in
the current analysis are considered in order from left to right.  At the
first one, if @code{BDJ} occurs to the left, @code{PXT} is inserted, and
nothing more is done by this rule.  If @code{BDJ} does not occur there
but @code{QMR} does, @code{PXT} is inserted and nothing more is done by
this rule.  Failing to find either @code{BDJ} or @code{QMR} to the left,
the potential insertion site is shifted one place to the right and the
process is repeated.  In this way, all potential insertion sites in the
analysis are evaluated until either an insertion is made or there are no
more potential insertion sites in the analysis.  When one of these
conditions is met, the next rule in the transfer file is applied.

Each insertion rule may affect an analysis only once.  This prevents
multiple insertions in cases where more than one environment is
satisfied.  For example, consider the following rule:
@example

\ir "X" / _ Y / Z _

@end example
@noindent
Consider how this affects an analysis with the sequence @code{Z Y}.  Both
environments are satisfied, so if multiple insertions were permitted by a
single rule, the result would be @code{Z X X Y}.  However, the desired
result is more likely to be @code{Z X Y}, which is what the program will
produce.  Note, it is possible to get the former result by using two
rules:
@example

@group
\ir "X" / _ Y
\ir "X" / Z _
@end group

@end example
@noindent
Since there are two rules, both would apply to @code{Z Y}, the first
producing @code{Z X Y}, the second applying to @code{Z X Y} to produce
@code{Z X X Y}.

@subsection Flags in insertion rules

Insertion rules are frequently conditioned by flags; thus some comments
about them are in order.  First, recall the discussion above:
the application of a rule automatically results in the lowering of any
flags in that rule.

Second, flags may be complemented by prefixing a tilde (@code{~}).  The
following set of rules illustrates the use of a complemented flag.  It is
motivated by a situation in Quechua, where pluralization with -pakU
occurs only in the absence of other morphemes which have kU.
@example

@group
\fl KUFLG REFL CMPL INTNS |flag for suffixes with kU
\fl PLFLG PL1 PL2         |flag for pluralizers
\sr "PL1" ""              |remove PL1
\sr "PL2" ""              |remove PL2
\ir "PLKU" PLFLG ~KUFLG   |insert if plural and no kU
@end group

@end example
@noindent
The first line defines a flag for suffixes containing kU; the second
defines a flag for pluralizers.  The third and fourth lines delete the
pluralizers.  The last line is a rule that inserts @code{PLKU} if the
@code{PLFLG} is up and the @code{KUFLG} is down, that is, the original
analysis had a pluralizer and no suffix with kU is now present in the
analysis.  If @code{PLKU} is ever inserted by this rule, @code{PLFLG}
will be lowered.

@subsection Determining the site for insertion
@c @unnumberedsubsec Determining the site for insertion

If an insertion rule has an environment with a simple environment bar,
then the position of the bar defines the site for insertion.  But when
the rule has no environment, or when the environment bar has ellipsis
marking, then the insertion site is not explicitly defined.  TRANSFER has
mechanisms for treating these cases.

Generally, the items to be inserted are either prefixes or suffixes.  In
the absence of an explicit environment statement, prefixes are inserted
somewhere before the leftmost root and suffixes are inserted somewhere
after the rightmost root.  TRANSFER determines whether the morpheme to be
inserted is a prefix or a suffix by determining which dictionary it
occurs in.  (For this reason each affix should have a unique morphname.)
Then it uses the orderclass of the morpheme, as defined in the dictionary
entry, to determine exactly where to insert the morpheme.

Consider an insertion rule with no environment, such as the following one
which inserts @code{ABC} whenever @code{XYZFLAG} is raised:
@example

\ir "ABC" XYZFLAG

@end example
@noindent
TRANSFER determines the orderclass of @code{ABC} from the affix
dictionaries of the target language.  Given an analysis, if the
@code{XYZFLAG} is up at the point this insertion rule is applied,
TRANSFER searches for an acceptable place to put @code{ABC}, attempting
to place it as far right as possible without violating orderclass, that
is, without placing it after an affix with a greater orderclass.  To
illustrate, consider an analysis like the following (with the
orderclasses given below each morphname):
@example

@group
< C1 root > M1 M2 M3 M4 M5
			10 20 30 40 50
@end group

@end example
@noindent
Assuming that the orderclass of @code{ABC} is 40, the result of the
insertion rule would be the following:
@example

< C1 root > M1 M2 M3 M4 ABC M5

@end example

If it is necessary to insert a sequence of morphnames, they can be
inserted by a sequence of insertion rules.  For example, the following
three rules insert @code{ABC DEF GHI} when @code{XYZFLAG} is up:
@example

@group
\ir "ABC" XYZFLAG
\ir "DEF" / ABC _
\ir "GHI" / DEF _
@end group

@end example
@noindent
(A slightly more complicated solution would be needed if there were
analyses containing @code{ABC} or @code{DEF} into which these rules would
incorrectly insert @code{DEF} or @code{GHI}.)  Applied to the previous
example, the result would be:
@example

< C1 root > M1 M2 M3 M4 ABC DEF GHI M5

@end example

Whenever the insertion site is not precisely defined by the environment
bar, insertion will be based on orderclass.  Therefore, ellipsis marking
can be used to constrain an insertion by the presence of one or more
morphnames and yet have the insertion based on orderclass.  For example,
either of the following rules inserts @code{PQR} as far right as possible
without violating orderclass whenever @code{M4} occurs in an analysis:
@example

@group
\ir "PQR" / _... M4
\ir "PQR" / M4 ..._
@end group

@end example

@c ----------------------------------------------------------------------------
@c Added by hab 27-Oct-2003
@node \lc, \maxprops (xxzzTR.CHG), \ir, Transfer file
@section Lexical change: \lc
@findex \lc

@menu
* Morphnames in lexical changes::
* Categories in lexical changes::
* Delimiters and type in lexical changes::
* Environment conditions on lexical changes::
* Which change applies?::
* Common errors in lexical changes::
* Two examples::
* Where should lexical changes be made?::
@end menu

Lexical changes are similar to the string changes described in the
AMPLE Reference manual section 8.5 or Weber, Black, and McConnel
(1988:79ff), but they differ in several respects.  First, changes are
made to sequences of morphnames rather than to strings.
(Nevertheless, we use ``string'' in referring to parts of a lexical
change.)  Second, lexical changes must match at least one root.  (In
this they differ from substitution rules, discussed in
@ifset txt
`Substitution rules' below,
@end ifset
@ifclear txt
@ref{\sr},
@end ifclear
which do not have this limitation.)  Third, lexical changes use a
different type of environment condition: whereas string changes may be
constrained with respect to character strings, lexical changes are
constrained with respect to morphnames.

A lexical change may have (in order):
@enumerate

@item
the field code @code{\lc};

@item the match string, that is, the sequence to be replaced;

@item
the substitution string, that is, what should be put in place of the match
string;
@cindex substitution string
@cindex lexical changes:substitution string

@item
one or more environments in which the change is to be made; and

@item
a comment, initiated by the comment character.
@end enumerate
@noindent
The first three elements are obligatory; the remainder are optional.
For example, the following is an acceptable lexical change:
@example

\lc "sha" "shamu" / _... AFAR |to reorder -mu

@end example
@noindent
This would change the root sha to shamu whenever it was followed by
the suffix @code{AFAR} somewhere in the analysis.

The match and substitution strings must be enclosed by delimiter
characters.  Any printing character can be used as the delimiter (see
Weber, Black, and McConnel 1988:80); the first printable character
after the field code is taken to be the delimiter.  The same delimiter
must be used for both the match and substitution strings.  For
example, the change given above could just as well be expressed as
follows:
@example

\lc @@sha@@ @@shamu@@ / _... AFAR |to reorder -mu

@end example
@noindent
Below, we will use the double quote mark as the delimiter.

Only one lexical change is ever made to a given root.  If an
applicable change is discovered, the substitution is made and TRANSFER
proceeds to the next root, if any.  When there are no more roots,
TRANSFER goes on to consider rules.

A lexical change must mention at least one root.  (It may have more
than one.)  The change applies only if the root portion of the match
string and the root of an analysis are identical.  Lexical changes
never apply to anything less than a complete morphname, so there is
never a danger of matching a proper substring of a morphname.  For
example, if the root in the match string is ka, this would have no
effect on the root kanta.  Likewise, a change where the match string
contains the root allpa would have no effect on the root
wallpa.

Lexical changes included in the transfer file should express facts
about the relationship between the source and target languages; this
is discussed further in
@ifset txt
`Where should lexical changes be made?' below.
@end ifset
@ifclear txt
@ref{Where should lexical changes be made?}.
@end ifclear

Lexical changes make it possible to handle lexical shifts.  For
example, consider adaptation from Huaraz to Huallaga Quechua.  Both
languages have verbs @code{urya-}, @code{aru-}, and @code{yanukU-} but
their meanings have shifted, so that the following lexical changes are
appropriate:
@example

\lc "yapya"  "urya"    |cultivate
\lc "urya"   "aru"     |work
\lc "aru"    "yanukU"  |cook

@end example
@noindent
(Subsequently, in SYNTHESIS it is necessary to consult a dictionary
entry for @code{yanukU}, which has allomorphs @code{yanuku} and
@code{yanuka}, the choice being determined by properties and tests.)

@c ----------------------------------------------------------------------------
@node Morphnames in lexical changes, Categories in lexical changes, \lc, \lc
@subsection Morphnames in lexical changes

The match string of a lexical change must match --- morphname by
morphname --- the portion of any analysis to which it should apply.
Whenever there is some doubt about the exact form of morphnames in the
analysis of some word, the user should inspect an actual analysis
produced by AMPLE.

It is possible to use morpheme classes in the match string of a
lexical change.  This is useful to change various forms of a root into
a single form.  For example, in Huallaga Quechua,
`write' is written in at least four different ways; therefore changing
these to a single target language form could be accomplished by four
lexical changes.
@example

\lc "eskirbi" "*qillqa" |write
\lc "eskribi" "*qillqa" |write
\lc "iskirbi" "*qillqa" |write
\lc "iskribi" "*qillqa" |write

@end example
@noindent
However, if a morpheme class @code{WRITE} contains @code{eskirbi},
@code{eskribi}, @code{iskirbi}, and @code{iskribi}, then the changes
can be made by a single lexical change which uses the class name
enclosed in square brackets:
@example

\lc "[WRITE]" "*qillqa" |write

@end example

Morpheme classes can also be used in morpheme environment constraints,
as illustrated below.  They cannot be used in the substitution string,
since the desired result of the change would not be uniquely
determined.

@c ----------------------------------------------------------------------------
@node Categories in lexical changes, Delimiters and type in lexical changes, Morphnames in lexical changes, \lc
@subsection Categories in lexical changes

Each root may be accompanied in the match string by a category.  An
analysis will be changed only if explicit categories in the match
string are identical to those of the corresponding roots in the
analysis.

For example, consider Huallaga Quechua @code{muru}, an ``ambivalent''
root: as a noun it means `seed', but as a verb it means `to plant
seeds'.  In some other Quechua languages, these correspond to the noun
root @code{semi:lla} `seed' (where colon represents vowel length) and
the verb root @code{muru} `plant or scatter seeds'.  The change of
@code{muru} to @code{semi:lla} must therefore be conditioned to apply
only when @code{muru} is a noun:
@example

\lc "N0 *muru" "semi:lla"

@end example
@noindent
If the category had not been included in the match string, all cases
of @code{muru} would be changed, giving many incorrect results.

The category is generally optional.  Therefore to change a sequence of
roots, the category between them may be present or absent.  For
example, to change @code{bathroom} (analyzed as in @i{a}) to @code{john},
either @i{b} or @i{c} would work:
@example

a. < N bath N room >
b. \lc "bath N room" "john"
c. \lc "bath room" "john"

@end example
@noindent
Here --- as elsewhere --- if the category is not stated, the change is
simply not constrained by category; thus, @i{b} would apply only when
room was analyzed as a noun (category @code{N}) whereas @i{c} would
change room regardless of its category.

It is possible to include category classes in the match strings of
lexical changes. Before the class can be used, the categories it
contains must be declared (see
@ifset txt
`Category declarations: \ca' above).
@end ifset
@ifclear txt
@ref{\ccl})
@end ifclear
and the class must be
defined (see
@ifset txt
`Category class declaration: \ccl' above).
@end ifset
@ifclear txt
@ref{\ca})
@end ifclear
For example, suppose that @code{kalap}
could be a noun (@code{N}), an intransitive verb (@code{V1}), or a
transitive verb (@code{V2}), and suppose that we wish to change
@code{kalap} to @code{pakla} only when it is a verb.  Further assume
that the category class @code{VERB} has been defined in the STAMP
declarations file as follows:
@example

\ccl VERB V1 V2

@end example
@noindent
Then the lexical change @i{a} (below) would apply to the analyses of
@i{b} and @i{c}, but not to that of @i{d}:
@example

a. \lc "[VERB] kalap" "pakla"
b. < V1 kalap >
c. < V2 kalap >
d. < N kalap >

@end example

It is possible to change a root's category by including a new category
in the substitution string.  This might be useful when the target
language does not make the same categorial distinctions as the source
language.  For example, if the source language distinguishes nouns and
adjectives but the target language has a single class of substantives,
the following change might be useful:
@example

\lc "A0 hatun" "S0 hatun" |big

@end example
@noindent
Note that neither categories nor category classes can be included in
an environment conditioning a lexical change.

In the substitution string, when a root is given without an
accompanying category, the following rules determines its category:
@enumerate
@item If it corresponds to a root in the match string, assign it the
category of that root.
@item If not, and if there are one or more roots in the match string, assign
it the category of the first one.
@item If there are no roots in the match string, assign it the first
category declared with @code{\ca}.
@end enumerate
@noindent
For example, consider the following lexical changes:
@example

a. \lc "< N aibcud > SX1" "paqur"
b. \lc "< N aibcud > SX1" "PSTPRF paqur"
c. \lc "> SX1 SX2" "< paqur >"

@end example
@noindent
In @i{a}, @code{paqur} would be assigned category @code{N} by the
first rule above because it corresponds to @code{aibcud}, which has
category @code{N}.  In @i{b}, @code{PSTPRF} would be taken as a root
corresponding to @code{aibcud} and assigned the category @code{N} by
the first rule above.  By conventions explained in
@ifset txt
`Delimiters and type in lexical changes' below,
@end ifset
@ifclear txt
@ref{Delimiters and type in lexical changes},
@end ifclear
@code{paqur} would also be taken to be a root; since it does not
correspond to a root in the match string, the second rule above
assigns it the category of the first root in the match string, namely,
@code{N}.  In @i{c}, @code{paqur} is a root (as forced by the wedges,
see
@ifset txt
`Delimiters and type in lexical changes' below)
@end ifset
@ifclear txt
@ref{Delimiters and type in lexical changes})
@end ifclear
but there is no root in the match string;
therefore, by the third rule above, @code{paqur} would be assigned
whatever category was declared first.

Note that mentioning a category always forces the following morphname
to be a root of the given category.  Thus, if the substitution string
contains ``@code{...Npaqur...}'', where @code{N} is a category,
then no matter what the match string is, or what precedes or follows
it in the substitution string, @code{paqur} is a root of category
@code{N}.

@c ----------------------------------------------------------------------------
@node Delimiters and type in lexical changes, Environment conditions on lexical changes,  Categories in lexical changes, \lc
@subsection Delimiters and type in lexical changes

The match string of a lexical change may contain the characters that
mark the boundaries between prefixes and roots, for which ``<'' is the
default, and between roots and suffixes, for which ``>'' is the
default.  (In the following discussion we simply use these default
values.)  For example, in some Quechua languages, `to leave' is
expressed by the root @code{ya-} followed by the suffix @code{-rqU}
`OUT', whereas others use the root @code{lluqshi-}.  Either of the
following would make this change:
@example

\lc "ya > OUT" "lluqshi" |leave
\lc "ya OUT"   "lluqshi" |leave

@end example
@noindent
Likewise, if a prefix is included, the wedge and intervening category
may be included:
changes;
@example

\lc "CAUSE < Vi die" "Vt kill"

@end example
@noindent
Note that it is not necessary to keep these delimiters balanced; this
change is acceptable even though the match string does not have a
corresponding right wedge.

Using wedges in the match string forces the morphnames to be assigned
a type (prefix, root, or suffix) according to the following rules:
@enumerate
@item Any morphname to the left of @code{<} is a prefix.
@item Any morphname to the right of @code{>} is a suffix.
@item Otherwise, a morphname is a root.
@end enumerate
@noindent
For a lexical change to apply, the morphnames matched in the analysis
must be consistent as to type with the corresponding morphnames in the
match string.  Furthermore, the boundaries must be present in the
analysis at the place indicated by the delimiter in the match string.
For example, consider the following:
@example

a. \lc "room" "chamber"
b. \lc "N room" "chamber"
c. \lc "< N room >" "chamber"
d. < N room >
e. < N bath N room >

@end example
@noindent
Changes @i{a}, @i{b}, and @i{c} would apply to the analysis in @i{d},
changing @code{room} to @code{chamber}.  However, if @code{bathroom}
is analyzed as in @i{e}, only @i{a} and @i{b} would change it to
@code{bathchamber}.  Change @i{c} does not apply because the left
wedge in the change does not correspond to a wedge in the analysis.

We now turn to the substitution string and how its morphemes are
assigned type.  The general rule is this: counting from the left, the
morphnames of the substitution string are assigned the type of the
corresponding morphname in the match string.  For example, consider
the following lexical change:
@example

\lc "PX < N abcd > SX1" "PY efg SY1 SY2"

@end example
@noindent
@code{PY} is a prefix because @code{PX} (the corresponding morphname
in the match string) is a prefix; @code{efg} is a root because
@code{abcd} is a root; and @code{SY1} is a suffix because @code{SX1}
is a suffix.

And what of @code{SY2}?  For such cases there is another rule:
morphnames in a substitution string for which there are no
corresponding morphnames in the match string (which arise when the
substitution string is longer than the match string) are assigned the
type of the last morphname in the match string.  Thus, since
@code{SX1} is a suffix, @code{SY2} is also a suffix.

Wedges can be used in the substitution string to force morphnames to a
particular type.  The rules are the same as those given above for the
match string: anything to the left of @code{<} is a prefix, and anything to
the right of @code{>} is a suffix.

In formulating lexical changes, it is probably wise to err on the side
of being too specific (that is, to include wedges and categories where
they are not necessarily needed) rather than to depend entirely on
STAMP's built-in rules.  Explicitness makes the user's intentions more
intelligible to those who must subsequently read and understand the
data files, including the person who first created them!

@c ----------------------------------------------------------------------------
@node Environment conditions on lexical changes, Which change applies?,  Delimiters and type in lexical changes, \lc
@subsection Environment conditions on lexical changes

A lexical change may be restricted by a morpheme environment
constraint; see Weber, Black, and McConnel (1988:74).  For example,
the following would change @code{allcha} to @code{kacha} only if
@code{PASS} (a passive suffix) immediately follows:
@example

\lc "allcha" "kacha" / _ PASS |get well

@end example
@noindent
The environment may contain multiple conditions; for example, in the
following, @code{hata} becomes @code{shaya} if followed by the
morphname @code{UP} or by @code{SUD}:
@example

\lc "hata" "shaya" / _ UP  |hata-rI-  to shaya-rI-
				   / _ SUD |hata-ykU- to shaya-ykU-

@end example
@noindent
And environments may contain morpheme classes; for example, if a
morpheme class called @code{FORCE} contains @code{UP} and @code{SUD},
then the previous change could be stated as follows:
@example

\lc "hata" "shaya" / _ [FORCE] |hata-rI-, hata-ykU-

@end example
@noindent
An environment may not contain a category, a category class, or a
wedge.  To change @code{bath} to @code{wash} only in the context of
@code{room} (whereby @code{bathroom} would become @code{washroom}),
one is tempted to formulate the change as follows:
@example

\lc "bath" "wash" / _ N room |**INCORRECT**

@end example
@noindent
However, this is not correct because the environment contains the
category @code{N}.  The change must be given as follows:
@example

\lc "bath N room" "wash N room"

@end example
@noindent
One might also be tempted to write a rule like the following:
@example

\lc "bath N" "wash" / _ room |**INCORRECT**

@end example
@noindent
This, too, is not correct because a category can be used only
accompanied by the root for which it is a category.  In this rule,
@code{N} occurs in the match string without the word for which it is
the category.

@c ----------------------------------------------------------------------------
@node Which change applies?, Common errors in lexical changes, Environment conditions on lexical changes, \lc
@subsection Which change applies?

If two or more lexical changes could apply to the same analysis, the
most specific should apply.  STAMP determines the most specific change
by assigning each change a weight as follows.  For each morpheme in
the match string (whether a root or an affix), add 100 points.  For
each root, add 50 if it is accompanied by a category or 25 if it is
accompanied by a category class.  Finally, add 150 if the change
contains one or more morpheme environment constraints.  The change
with the greatest number of points is judged to be the most specific,
and is thus applied in preference to changes with fewer
points.

For example, the following changes would have the number of points indicated:
@example

\lc "igmo" "ingo"               |total points = 100
\lc "[AMBIV] igmo" "vago"       |total points = 125
\lc "N0 igmo" "vago"            |total points = 150
\lc "igmo > BEC" "vago BEC"     |total points = 200
\lc "igmo" "vago" / _ BEC       |total points = 250
\lc "N anza V misi" "V anzasi"  |total points = 300

@end example

Only one lexical change ever applies to a single root.  However, if an
analysis has multiple roots, each could be modified by a different
lexical change.  For example, given changes @i{a} and @i{b}, analysis
@i{c} would become @i{d}:
@example

a. \lc "alla" "oqti"  |dig
b. \lc "papa" "aqshu" |potato
c. < N papa V alla > PROG PAST 3
d. < N aqshu V oqti > PROG PAST 3

@end example
@noindent

@c ----------------------------------------------------------------------------
@node Common errors in lexical changes, Two examples, Which change applies?, \lc
@subsection Common errors in lexical changes

Capitalization is significant.  Roots must be in upper or lower case,
exactly as they appear in the analysis.  (This usually comes from the
etymology field of the source language dictionary.)  Likewise, affix
morphnames must be upper or lower case, exactly as they appear in the
analysis.  Users will make fewer errors of case if they follow some
convention, such as putting all roots entirely in lower case and all
affix morphnames entirely in upper case.

If the root of an analysis has a regular sound change identifier (see
section 7.2.3.2), then the match string of a change applying to it
must include that character.  Conversely, if the root does not have
such a character, the match string of a change applying to the
analysis must not have it.  For example, consider an analysis as in
@i{a} and changes as in @i{b} through @i{e}:
@example

a. < N0 *qasqu >
b. \lc       "qasqu"        "pe:chu"
c. \lc      "*qasqu"        "pe:chu"
d. \lc   "N0 *qasqu"     "N0 pe:chu"
e. \lc "< N0 *qasqu >" "< N0 pe:chu >"

@end example
@noindent
The change in @i{b} cannot apply because its match string does not
contain an asterisk, while the analysis in @i{a} does.  By contrast,
any of changes @i{c} through @i{e} would match the analysis in @i{a}
and change the root.

@c ----------------------------------------------------------------------------
@node Two examples, Where should lexical changes be made?, Common errors in lexical changes, \lc
@subsection Two examples

This section contains two examples.  The first serves to review many
points about lexical changes.  The second is a complete list of the
lexical changes for an actual language pair.

For the first example, consider the analysis in @i{a}:
@example

a. M1 <C1 root1 C2 root2> M2

@end example
@noindent
Either @i{b} or @i{c} would change this to @i{d}:
@example

b. \lc "root2 > M2" "root3 > M2"
c. \lc "root2" "root3" / _ M2
d. M1 < C1 root1 C2 root3 > M2

@end example
@noindent
Any of @i{e} through @i{j} (among other possibilities) would change
the two roots of @i{a} to @code{root3}, yielding the analysis in
@i{k}:
@example

e. \lc "root1 root2"           "root3"
f. \lc "< root1 root2 >"       "root3"
g. \lc "C1 root1 root2"        "root3"
h. \lc "< root1 C2 root2"      "root3"
i. \lc "C1 root1 C2 root2"     "root3"
j. \lc "< C1 root1 C2 root2 >" "root3"
k. M1 < C1 root3 > M2

@end example
@noindent
Change @i{l} would change @i{a} to the analysis in @i{m}, in which the
second root and the first suffix become a single root, namely,
@code{root3}:
@example

l. \lc "root2 > M2" "root3"
m. M1 < C1 root1 C2 root3 >

@end example
@noindent
Likewise, @i{n} would change the analysis to @i{o}, in which the second root
and the first suffix become a single suffix, namely, @code{MX}:
@example

n. \lc "root2 > M2" "> MX"
o. M1 < C1 root1 > MX

@end example
@noindent
Note that the wedge (@code{>}) in the substitution string of @i{n}
forces TRANSFER to treat @code{MX} as a suffix.  If this wedge were
omitted, @code{MX} would be treated as a root, since counting from the
left it corresponds to a root.

Either @i{p} or @i{q} would change @i{a} to the analysis in @i{r}, in
which the second prefix and the first root become a single root
(namely, @code{root4}):
@example

p. \lc "M1 < root1"    "root4"
q. \lc "M1 < C1 root1" "root4"
r. <C1 root4 C2 root2 > M2

@end example
@noindent
Note that the category of @code{root4} is the same as that of
@code{root1}, since no category is given in the substitution string of
these changes.

The second example is given below, which contains
the lexical changes used to adapt from Huallaga Quechua to Huamalies
Quechua.  To facilitate managing these changes, it is convenient to
organize them alphabetically by the root of the match string.  This is
achieved by aligning the first character of the roots (excluding the
asterisk identifying Proto-Quechua roots) and thenperiodically
sorting the list on the column in which the roots begin (using the
appropriate switch with a sort program).

@example
TRANSFER lexical changes for Huallaga to Huamalies Quechua

\co Huallaga to Huamalies Quechua lexical changes
\lc    "[WRITE]"      "*qillqa"          |eskirbi eskribi etc.
\lc "N0  a:bi"        "*pishqu"          |bird
\lc    "*allcha"      "*katra" / _ PASS  |get well
\lc     "awturida:"   "awturda:"         |authority
\lc "N0  corte"       "konsehu"          |council
\lc     "empleada"    "ashmay"           |servant
\lc     "fista"       "fyesta"           |fiesta
\lc "N0  fiyu > GEN"  "R0 siqaypa"       |really
\lc "N0  ga:llu"      "kakash"           |rooster
\lc "V1 *hata > PNCT" "*shaya > UP"      |hata-rI- > sha-rkU-
\lc "V1 *hata"        "*itri" / _ UP     |hata-rkU- > ichi-rkU-
\lc    "*hawa"        "*waqta"           |outside
\lc    "*huknaylla"   "*hukllaylla"      |unique
\lc "V2  insulta"     "*ashlli"          |insult
\lc "V2 *kama"        "alista"           |prepare
\lc "N0  kantu"       "kuchu"            |bank
\lc "N0  korte"       "konsehu"          |council
\lc "N0 *llachapa"    "mu:dana"          |clothes
\lc    "*lluqshi"     "*ya > OUT"        |leave
\lc "V1 *mallwa"      "*hama"            |sit
\lc    "*manacha:"    "manasay"          |(contrastive)
\lc "V2 *matanka"     "umbru"            |carry on shoulder
\lc     "mawka"       "makwa"            |worn out
\lc     "mayistru"    "mayestru"         |teacher
\lc     "mu:su"       "maqta"            |young man
\lc     "pakilla:"    "pa:kila:"         |thanks
\lc     "parasimri"   "imayyaqpis"       |forever, eternal
\lc     "pare:hu"     "patinti"          |be similar
\lc     "patinti"     "patenti"          |tax
\lc    "*patra"       "posa:da" / _ CAUS |give lodging
\lc     "primer"      "punta > OBJ"      |first
\lc "N0 *puyn~u"      "*uyllu"           |jug
\lc    "*qaqlla"      "ka:ra"            |face
\lc "V1 *qatrwa"      "tu*na"            |dance (verb)(u* = uu)
\lc "N0 *qatrwa"      "tushu"            |dance (noun)
\lc     "reda"        "red"              |net
\lc     "rey"         "ray"              |king
\lc    "*rima"        "parla"            |say
\lc    "*siksik"      "suksuk"           |tremble
\lc     "tra:pu"      "ratash"           |rag
\lc     "tu:ka"       "tuka"             |to play (instrument)
\lc "V2 *uywa"        "*ashma"           |to raise
\lc     "werta"       "*qintra"          |garden
\lc    "*yanqa"       "wala:"            |in vain
\lc    "*yarqa:"      "*miku > DES"      |be hungry
\lc    "*yaykU"       "*ya > IN"         |enter
@end example

Note that the order in which the lexical changes are listed in the
file is not relevant to the program.  Recall, from
@ifset txt
`Insertion rule: \ir' above,
@end ifset
@ifclear txt
@ref{\ir},
@end ifclear
that if more than one lexical change could match the current analysis,
the most specific one is applied.

@c ----------------------------------------------------------------------------
@node Where should lexical changes be made?, , Two examples, \lc
@subsection Where should lexical changes be made?

It is natural to ask why lexical changes can be made both by TRANSFER
and by SYNTHESIS.  The reason lies in how we wish to organize the
data.  A reasonable distribution of the data to the transfer and
synthesis files can make these files much more linguistically and
computationally useful.

For linguistic purposes, the files are more useful if all information
of a certain type, or about a certain topic, is localized in a single
place.  It would be unfortunate, for example, if information about the
target language were distributed through transfer and synthesis files,
or if information about the relationship of the source and target
languages were mixed in with the synthesis files.

For computational purposes, a careful distribution of information can
make the files more reusable.  The same synthesis file can be used
when adapting from different source languages if it contains only
information about the target language.  The transfer file can be more
easily reversed when adapting in the other direction if it includes
only information about the relationship between the source and target
languages.

Lexical changes can be used to express two types of fact: facts about
the relationship between two languages, and facts about the
distinctives of the target language.  The former should be given in
the transfer file and the latter should be given in the synthesis
file.  For example, the following are about the relationship between
two languages, so they should be given in the transfer file:
@example

\lc "V1 *aru"    "V1 *urya" |work
\lc "V2 *yanuku" "V2 *aru"  |cook
\lc "*lluqshi"   "*ya OUT"  |go out

@end example
@noindent
These change one root to another.  Of course, this list would be quite
different for each pair of source and target languages.

By contrast, the following express facts about the distinctives of the
target language, so they should be given in the synthesis file:
@example

\lc "eskwela"    "eskuyla"        |exceptional loan
\lc "V1 GETWELL" "V1 *kacha PASS" |recover from illness
\lc "*killa"     "killa"          |block *ll to l

@end example
@noindent
The first indicates the peculiar borrowing of Spanish @code{escuela},
where closely-related languages have @code{eskwela}.  The second
indicates how this language expresses `recovery from illness'.  The
third indicates that @code{*killa} is an exception to the RSC
@code{ll} to @code{l} (a case to which we return later).  Note that
these changes are likely to be relevant no matter what the source
language is, and thus belong in the synthesis file.

The following subsections give guidelines for determining where a
change should be placed.  For many cases, the decision may seem rather
subjective, but with experience the user will gain an understanding of
the distinction.

@subsubsection In the transfer file

When considering the inclusion of a change in the transfer file, the following questions should be asked:
@enumerate

@item Does the change express a fact about the relationship between
languages?  If so, then it belongs in the transfer file.  If, however,
it expresses a fact about the target language (for example, how a loan
has been assimilated in the target language or an exception to a
regular sound change in the target language) then the change belongs
in the synthesis file.

@item Does the change mediate between pan-dialectal normal forms?  For
native vocabulary, the pan-dialectal normal forms might be
reconstructed proto-forms; for borrowed vocabulary, they might be the
forms of the language from which each word is borrowed.  Changes
mediating between pan-dialectal normal forms belong in the transfer
file.

@item Is the change reversible?  That is, if the match and substitution
strings were reversed, would the change serve for adapting in the
other direction?  By and large, changes which belong in the transfer
file are reversible.  However, this criterion is not absolute; for
example, if two lexical items are changed to a single one, simply
reversing both changes will probably not give the desired result in
the reverse adaptation path.

@end enumerate

For example, suppose that for `money', the source language has
@code{qillay} and the target has @code{qullqi}, which is not cognate
with @code{qillay}.  To introduce this change, the following lexical
change would be used:
@example

\lc "*qillay" "*qullqi"

@end example
@noindent
By all the above-mentioned criteria, the change of @code{*qillay} to
@code{*qullqi} belongs in the transfer file: it expresses a fact about
the relationship between the two languages, it mediates between two
pan-Quechua normal forms, and it is reversible.

By the way, it would be possible to make @code{qillay} become
@code{qullqi} by giving @code{*qullqi} as the etymology for
@code{qillay} in the source language dictionary.  However, this would
be an extremely bad solution because, first, it would distort the
etymology of @code{qillay} in the source language dictionary since
@code{qullqi} is not the etymology of @code{qillay}, and second, it
would keep a fact about the relationship between the source and target
languages from being given in the transfer file.

@subsubsection In the synthesis file

 When considering the inclusion of a change in the synthesis file, the
following questions should be asked:
@enumerate

@item Does it express a fact about a distinctive of the target language?  Or
to put it another way, does the change mediate between a pan-dialectal
normal form and the corresponding form in the target language?  If so,
the change belongs in the synthesis file.

@item Does the change contain any information about the source language?  If
so, it does not belong in the synthesis file.  The synthesis file
should not contain information about the source language because
ideally it would be used regardless of the language from which texts
are being adapted.

@item Would the change be appropriate for adapting from a language to
itself?  Imagine analyzing a text, whereby each root comes to be
represented by its pan-dialectal normal form, and then synthesizing
the text back to the same language, using only SYNTHESIS and TEXTOUT.
(That is, no transfer file would be loaded.)  If the change under
consideration would not contribute to this process, it probably
belongs in the transfer file.

@end enumerate

Returning to the case of @code{qellay} discussed in the previous
section, it would be possible to include the change of @code{*qillay}
to @code{*qullqi} in the synthesis file.  However, this would violate
all the above-mentioned criteria.

@subsubsection Using both the transfer and synthesis files

The previous sections describe criteria for whether a change should be
made in the transfer file or in the synthesis file.  In this section
we will show that even for a single change it is sometimes best to
distribute the information across both files.  To show this, we
consider a single example, that of adapting North Junin Quechua
@code{yarpun} `he goes down' to Wanka Quechua, where the corresponding
form is @code{hiyalpun}.

If there were nothing to consider beyond getting the change made,
there would be many ways to do it.  But if we consider factors such as
the flexibility for adapting to and from other languages, the ease of
reversing the direction of adaptation, and the value of the data files
as representing linguistic realities, then we are lead to one solution
which seems better than the rest.

North Junin @code{yarpu-} analyzes as @code{ya DWN} (that is, as
@code{ya-rpU-}).  One possibility is to make the following change in
the transfer file:
@example

\lc "*ya DWN" "hiyalpu"

@end example
@noindent
However, this would not be reversible, since Wanka @code{hiyalpu-}
should analyze as the root @code{hiya-} and the suffix @code{-lpu}
`DWN'.  So let's consider another possibility:
@example

\lc "*ya DWN" "hiya DWN"

@end example
@noindent
However, this fails to capture a significant fact, namely, that
@code{hiya} is the Wanka reflex of Proto-Quechua @code{*hiqa}.  (Wanka
has undergone RSCs which eliminate /@code{*q}/; /@code{y}/ is inserted
between /@code{i}/ and /@code{a}/ to maintain syllable structure.)  In
light of this, another way to make the change is as follows:
@example

\lc "*ya DWN" "*hiqa DWN"

@end example
@noindent
We count on the Wanka synthesis file to contain whatever is necessary
to produce Wanka @code{hiya} from Proto-Quechua @code{*hiqa} (for
example, a RSC which deletes @code{q} followed by a change of
@code{ia} to @code{iya}).  Of course, such changes would be needed
independently.

The example below summarizes the steps by which @code{yarpun} becomes
@code{hiyalpun} using this final formulation.  This approach is
superior to the former ones because it meets our criteria of
flexibility, reversibility, and linguistic integrity.
@example

North Junin yarpun to Wanka hiyalpun
		North Junin Quechua input:          yarpun
											  |
		ANALYSIS                              v
										  *ya  DWN 3
		TRANSFER                              v
										 *hiqa DWN 3
				  |regular sound change       v
		SYNTHESIS |                       hiya DWN 3
				  |allomorph selection        |
											  v
		Wanka Quechua output:              hiyalpun

@end example

@c ----------------------------------------------------------------------------
@c Added by hab 14-May-1999
@node \maxprops (xxzzTR.CHG), \mcl (xxzzTR.CHG), \lc, Transfer file
@section Maximum number of properties: \maxprops
@findex \maxprops

This field can also occur in the STAMP declarations file or the STAMP
synthesis file instead; see
@ifset txt
`Maximum number of properties' in the chapter `STAMP declarations file'
above.
@end ifset
@ifclear txt
@ref{\maxprops}.
@end ifclear

@c ----------------------------------------------------------------------------
@node \mcl (xxzzTR.CHG), \mp (xxzzTR.CHG), \maxprops (xxzzTR.CHG), Transfer file
@section Morpheme class declaration: \mcl
@findex \mcl

This field can also occur in the STAMP declarations file or the STAMP
synthesis control file instead; see
@ifset txt
`Morpheme class declaration' in the chapter `STAMP declarations file' above.
@end ifset
@ifclear txt
@ref{\mcl}.
@end ifclear

@c ----------------------------------------------------------------------------
@node \mp (xxzzTR.CHG), \pcl (xxzzTR.CHG), \mcl (xxzzTR.CHG), Transfer file
@section Morpheme property declaration: \mp
@findex \mp

This field can also occur in the STAMP declarations file or the STAMP
synthesis control file instead; see
@ifset txt
`Morpheme property declaration' in the chapter `STAMP declarations file'
above.
@end ifset
@ifclear txt
@ref{\mp}.
@end ifclear

@c ----------------------------------------------------------------------------
@c Added by hab 14-May-1999
@node \pcl (xxzzTR.CHG), \rd (xxzzTR.CHG), \mp (xxzzTR.CHG), Transfer file
@section Punctuation class: \pcl
@findex \pcl

This field can also occur in the STAMP declarations file or the STAMP
synthesis file instead; see
@ifset txt
`Punctuation class' in the chapter `STAMP declarations file'
above.
@end ifset
@ifclear txt
@ref{\pcl}.
@end ifclear

@c ----------------------------------------------------------------------------
@node \rd (xxzzTR.CHG), \scl (xxzzTR.CHG), \pcl (xxzzTR.CHG), Transfer file
@section Root delimiter: \rd
@findex \rd

This field can also occur in the STAMP declarations file or the STAMP
synthesis control file instead; see
@ifset txt
`Root delimiter' in the chapter `STAMP declarations file' above.
@end ifset
@ifclear txt
@ref{\rd}.
@end ifclear

@c ----------------------------------------------------------------------------
@node \scl (xxzzTR.CHG), \sr, \rd (xxzzTR.CHG), Transfer file
@section String class declaration: \scl
@findex \scl

This field can also occur in the STAMP declarations file or the STAMP
synthesis control file instead; see
@ifset txt
`String class declaration' in the chapter `STAMP declarations file'
above.
@end ifset
@ifclear txt
@ref{\scl (zzSTAMP.DEC)}.
@end ifclear

@c ----------------------------------------------------------------------------
@c Added by hab 27-Oct-2003
@node \sr, , \scl (xxzzTR.CHG), Transfer file
@section Substitution rule: \sr
@findex \sr

Substitution rules are similar to the string changes described in
Weber, Black, and McConnel (1988:79ff), but they differ in two
respects.  First, changes are made to sequences of morphnames rather
than to strings.  (Nevertheless, we use ``string'' in referring to
parts of a substitution rule.)  Second, they use a different type of
environment condition.  Whereas string changes may be constrained with
respect to character strings, conditions on substitution rules may be
constrained with respect to morphnames, flags, or some combination of
these.

Substitution rules may have (in order):
@enumerate

@item the field code @code{\sr},

@item the match string,

@item the substitution string

@item one or more flags,

@item one or more environments, and

@item a comment.
@end enumerate
@noindent
The match and substitution strings are delimited by some printing
character, as described above in
@ifset txt
`Lexical change: \lc' above
@end ifset
@ifclear txt
@ref{\lc}
@end ifclear
(see also Weber, Black, and McConnel (1988:80).  When the match string
is found in an analysis, it is replaced by the substitution string if
all the rule's flags are raised (or, for complemented flags, not
raised) and at least one of its environments is satisfied (if any are
specified).

Of the six parts listed above, only the first three are obligatory.
Thus the following is an acceptable rule to change every instance of
@code{3PST} (in every analysis) to @code{PAST3}:
@example

\sr "3PST" "PAST3"

@end example
@noindent
Here, every case of @code{3PST} is changed because the rule is not
conditioned.  Such rules are useful in cases where affixes which
correspond between the source and target languages have different
morphnames.

Anything between the match and substitution strings is ignored.
Therefore, any characters may be included there, such as the word
``becomes'' or an arrow:
@example

\sr "3PST" --> "PAST3"

@end example

As with lexical changes, the match and substitution strings of
substitution rules may contain the markers indicating the beginning or
end of the root portion of an analysis (for which the defaults are
@code{<} and @code{>}).  These can be used to force morphnames to be
assigned a certain type: prefix, root, or suffix.  For example, rule
@i{a} would apply to a root and a suffix, while rules @i{b} and @i{c}
would apply to a prefix and a root:
@example

a. \sr "*ya > OUT" "*lluqshi"
b. \sr "PST < *gaga" "bukaga"
c. \sr "PST < *gaga" "< bukaga"

@end example
@noindent
Rules @i{b} and @i{c} differ in that @code{bukaga} in @i{b} would be
interpreted as a prefix, whereas in @i{c} it would be interpreted as a
root.

The rules by which a type is assigned to a morphname are as follows:
@enumerate
@item Any morphname to the left of @code{<} is a prefix.

@item Any morphname to the right of @code{>} is a suffix.

@item All morphnames between @code{<} and  @code{>} are roots.

@item If the only delimiter in the match string is @code{<}, every morphname
after it is a root.  Likewise, if the only delimiter is @code{>},
every morphname preceding it is a root.
@end enumerate
@noindent
Recall that in lexical changes, morphnames that are not forced to be
prefixes or suffixes are assumed to be roots.  This is not the case
for substitution rules: if the match string does not contain a
delimiter, the type of each morphname is free to vary (that is, it can
be taken as either a prefix, a root, or a suffix) and type identity is
not imposed in determining a match to some portion of an analysis.
When a match is achieved, the morphnames of the match string inherit
the types of the matched morphnames in the analysis.  These types may
then influence the types assigned to the substitution string,
following the rules outlined in
@ifset txt
`Delimiters and type in lexical changes' above
@end ifset
@ifclear txt
@ref{Delimiters and type in lexical changes}
@end ifclear
for lexical changes.

It is possible to make lexical changes with substitution rules; for
example,
@example

\sr "*wishlla" "kucha:ra"

@end example
@noindent
However, substitution rules are computationally more time consuming
than lexical changes, so they should be used only if there is good
reason to do so.  Here are two possible motivations for using a
substitution rule rather than a lexical change.  First, it may be
necessary to order the change after other rules of the transfer file
(for example, an insertion rule); recall that the lexical changes
apply before all other rules, so there is no control on their
ordering.  Second, it may be necessary to condition the change with a
flag; flags are not available for lexical changes.

We now proceed to illustrate some of the flexibilities afforded by
substitution rules.  The match and substitution strings may have
multiple morphnames.  For example, the following is used between
Quechua languages to reorder the pluralizer @code{-rka} `PLIMPF'
and the imperfective @code{-yka:} `IMPFV':
@example

\sr "PLIMPF IMPFV" "IMPFV PLIMPF"

@end example

The match and substitution strings need not contain the same number of
morphnames.  For example, suppose --- as is the case in some Quechua
languages --- that in one language the reflex of @code{-ra} `PST3'
indicates both past tense and third person, whereas in another
language the cognate @code{-rqa} indicates just past tense, with third
person indicated by a following third person marker.  The following
makes the appropriate change:
@example

\sr "PST3" "PST 3P" |-ra (PST3) to -rqa-n (PST 3)

@end example
@noindent
Whereas in this case the substitution string is longer than the match
string, in the following example it is shorter.  In San Martin
Quechua, the adverbializer @code{-shpa} may be inflected to reflect
the person of the subject, whereas in Cuzco Quechua it is never so
inflected.  For example, San Martin @code{-shpa-yki} `ADVSS2P' should
become Cuzco @code{-spa} `ADV'.  One way to do this would be to write
a substitution rule for each case:
@example

\sr "ADVSS  1P" "ADV"
\sr "ADVSS  2P" "ADV"
\sr "ADVSS  3P" "ADV"
\sr "ADVSS 12P" "ADV"

@end example
@noindent
Alternatively, one could use a morpheme class and a single rule.  If
the morpheme class @code{POSS} contains @code{1P}, @code{2P},
@code{3P}, and @code{12P}, then the following would make the desired
change:
@example

\sr "ADVSS [POSS]" "ADV"

@end example

The substitution string may even be empty, in which case the morphname
sequence in the match string is simply deleted.  (The converse, that
is, changing an empty match string into some morphnames, is not
acceptable.  Insertion rules are provided for that purpose.)  Consider
two examples:
@enumerate

@item Some Quechua languages have a future suffix @code{-paq} `FUT', which
is simply absent in others.  To adapt to the latter languages from
ones that have @code{-paq}, the following change is appropriate:
@example

\sr "FUT" "" |delete -paq FUT

@end example

@item

Campa languages have considerable epenthesis phenomena at morpheme
boundaries.  To adapt across these, the strategy that has been taken
is to analyze the epenthesized phonemes as separate morphemes (named
``&'') and then to delete them in TRANSFER with the following rule:
@example

\sr "&" "" |remove epenthesis

@end example
@noindent
Epenthesis is then reintroduced as appropriate for the target language
by SYNTHESIS.
@end enumerate

Substitution rules may be conditioned by one or more flags (discussed
in
@ifset txt
`Flag rule: \fl').
@end ifset
@ifclear txt
@ref{\fl}).
@end ifclear
For example, the following would substitute @code{-rpa} `PLSTAT' for
@code{-ra:} `STAT' whenever the PLURAL flag is up:
@example

\sr "STAT" "PLSTAT" PLURAL

@end example
@noindent

Substitution rules may also be conditioned by one or more environments
like those described in Weber, Black, and McConnel (1988:74ff).  An
environment must contain an environment bar and at least one
morphname, root, morpheme class, or the complement of one of these.

Let us consider three examples, each used in adapting from San Martin
to Cajamarca Quechua:
@enumerate
@item Following @code{-rqa} `PST', some Quechua languages use @code{-yki}
`2P', the possessive form of the second person, whereas others use
@code{-nki} `2', the verbal form.  Therefore it is sometimes necessary
to change one into the other.  To avoid changing the second person
suffix everywhere, the rule must be constrained to apply only after
@code{PST}:
@example

\sr "2" "2P" / PST _ |-rqa-yki to -rqa-nki

@end example

@item The following substitution rule is also used:
@example

\sr "2" "3" / 2O PST _ |-shu-rqa-nki to -shu-rqa-n

@end example
@noindent
The order of this change and the preceding change of @code{2} (verbal)
to @code{2P} (possessive) is critical.  Since both deal with morphname
@code{2} following @code{PST}, the one with the more specific
environment, that is, the one changing @code{2} to @code{3}, must be
put first.  Otherwise we have the undesirable situation in which the
more general rule would always apply, destroying the environment of
the more specific rule.

@item

The following rule assumes that the morpheme class @code{POSS}
containing @code{1P}, @code{2P}, @code{3P}, and @code{12P} has been
defined in the STAMP declarations file, and uses this class in a
morpheme environment constraint:
@example

\sr "PLUR PUR" "PUR PL1" / NOM [POSS] _
		 |-NOM-POSS-PLUR-PUR --> -NOM-POSS-PUR-PL1
		 |-na -yki -kuna-pa  --> -na -yki -paq-llapa
		 |-na -n   -kuna-pa  --> -na -n   -paq-llapa
		 |etc.

@end example
@end enumerate

@c ----------------------------------------------------------------------------
@c commented off hab 2003.10.27
@c @node Syntax of transfer rules, Syntax of lexical changes, Transfer file, Transfer file
@c @section Syntax of transfer rules
@c
@c FIX ME!
@c
@c @node Syntax of lexical changes, , Syntax of transfer rules, Transfer file
@c @section Syntax of lexical changes
@c
@c FIX ME!
@c

@c ----------------------------------------------------------------------------
@node Synthesis file, Dictionary code table file, Transfer file, Top
@chapter Synthesis Control File

@c \maxprops and \pcl added by hab 14-May-1999
@menu
* \ambig (zzSYNT.CHG)::     Analytic ambiguity delimiter
* \ap (zzSYNT.CHG)::        Allomorph property declaration
* \ca (zzSYNT.CHG)::        Category declarations
* \ccl (zzSYNT.CHG)::       Category class declaration
* \lc (zzSYNT.CHG)::        Lexical change
* \maxprops (zzSYNT.CHG)::  Maximum number of properties
* \mcl (zzSYNT.CHG)::       Morpheme class declaration
* \mp (zzSYNT.CHG)::        Morpheme property declaration
* \pcl (zzSYNT.CHG)::       Punctuation class
* \rd (zzSYNT.CHG)::        Root delimiter
* \rsc::                    Regular sound change
* \rscid::                  Regular sound change identifiers
* \scl (zzSYNT.CHG)::       String class declaration
* \test::                   Synthesis test
@end menu

@c ----------------------------------------------------------------------------
@node \ambig (zzSYNT.CHG), \ap (zzSYNT.CHG), Synthesis file, Synthesis file
@section Analytic ambiguity delimiter: \ambig
@findex \ambig

This field can also occur in the STAMP declarations file or the STAMP
transfer control file instead; see
@ifset txt
`Analytic ambiguity delimiter' in the chapter `STAMP declarations file'
above.
@end ifset
@ifclear txt
@ref{\ambig (zzSTAMP.DEC)}.
@end ifclear

@c ----------------------------------------------------------------------------
@node \ap (zzSYNT.CHG), \ca (zzSYNT.CHG), \ambig (zzSYNT.CHG), Synthesis file
@section Allomorph property declaration: \ap
@findex \ap

This field can also occur in the STAMP declarations file or the STAMP
transfer control file instead; see
@ifset txt
`Allomorph property declaration' in the chapter `STAMP declarations file'
above.
@end ifset
@ifclear txt
@ref{\ap}.
@end ifclear

@c ----------------------------------------------------------------------------
@node \ca (zzSYNT.CHG), \ccl (zzSYNT.CHG), \ap (zzSYNT.CHG), Synthesis file
@section Category declarations: \ca
@findex \ca

This field can also occur in the STAMP declarations file or the STAMP
transfer control file instead; see
@ifset txt
`Category declarations' in the chapter `STAMP declarations file' above.
@end ifset
@ifclear txt
@ref{\ca}.
@end ifclear

@c ----------------------------------------------------------------------------
@node \ccl (zzSYNT.CHG), \lc (zzSYNT.CHG), \ca (zzSYNT.CHG), Synthesis file
@section Category class declaration: \ccl
@findex \ccl

This field can also occur in the STAMP declarations file or the STAMP
transfer control file instead; see
@ifset txt
`Category class declaration' in the chapter `STAMP declarations file' above.
@end ifset
@ifclear txt
@ref{\ccl}.
@end ifclear

@c ----------------------------------------------------------------------------
@node \lc (zzSYNT.CHG), \maxprops (zzSYNT.CHG), \ccl (zzSYNT.CHG), Synthesis file
@section Lexical change: \lc
@findex \lc

The lexical changes of SYNTHESIS are like those of TRANSFER both with
respect to notation and program behavior (see
@ifset txt
`Lexical changes' in the chapter `STAMP transfer file' above.)
@end ifset
@ifclear txt
@ref{\lc}.)
@end ifclear
The difference is that lexical changes included in the synthesis file
should express distinctives of the target language; this is discussed
further in
@ifset txt
`Where should lexical changes be made?' in the chapter `STAMP transfer file' above.
@end ifset
@ifclear txt
@ref{Where should lexical changes be made?}.
@end ifclear
The example below contains lexical changes used for synthesizing to
Huamalies Quechua.  All lexical changes apply before any other changes
of the synthesis file.

@example

SYNTHESIS lexical changes for adapting to Huamalies Quechua

\co exceptional changes from proto, not handled below
\lc "*illaqa:"    "elaqa:"      |disappear
\lc "*illaqpita"  "elaqpita"    |surprisingly
\lc "V1 *pa:ri"   "V1 paha"     |fly

\co words in which proto /s/ is lost:
\lc "*wasi"       "wayi"        |house
\lc "*masi"       "mayi"        |paisano
\lc "*masa"       "maha"        |mate

\co words which do not undergo */ll/ > /l/
\lc "N0 *qillay"  "N0 qellay"   |money
\lc "*llan~u"     "llanu"       |thin

\co words which do not undergo */n~/ > /n/
\lc "*pin~a"      "pin~a"       |bad, angry

\co words which do not undergo */ch/ > /ts/ > /s/
\lc "V1 *wacha"   "V1 wacha"    |give:birth
\lc "N0 *ichik"   "N0 ichik"    |small

\co words which have /sh/ from /*s/
\lc "*sumaq"      "shumaq"      |pretty

\co words with /e/ for /*i/, not due to phonetic lowering
\lc "*wira"       "wera"        |fat

\co words which have */aya/ > /a:/
\lc "V1 *tiya"    "V1 ta:"      |reside
\lc "V1 *traya"   "V1 cha:"     |arrive
\lc "V1 *shaya"   "V1 sha:"     |stand

\co Exceptions to phonetic lowering following /q/:
\lc "V2 *ruqu"    "V2 roqu"     |sever

\co Spanish loans handled differently:
\lc "kri*yi"      "krigi"       |believe
\lc "inri*ga"     "entriga"     |turn over to
@end example
@noindent
As illustrated above, synthesis lexical changes allow one to handle
exceptions to regular sound changes (RSCs) discussed in
@ifset txt
`Regular sound change: \rsc' below.
@end ifset
@ifclear txt
@ref{\rsc}.
@end ifclear
For example, suppose that an RSC generally makes @code{ll} into
@code{l} but should not apply to @code{*qillay} for the target
language.  This form can be ``exempted'' from the application of RSCs
by omitting the RSC identifier (@code{*}) from the output of the
lexical change, as in the following:
@example

\lc "N0 *qillay"  "N0 qellay"   |money

@end example

The greatest source of errors in lexical changes (both in TRANSFER and
SYNTHESIS) is the omission of the RSC identifier.  For example,
consider the following change:
@example

\lc "papa" "aqshu" | potato

@end example
@noindent
This will not work if the entry for @code{papa} in the source language
dictionary is either of the following, which are equivalent (see
Weber, Black, and McConnel 1988:128):
@example

\w papa                \w papa
\p N0                  \p N0
\ge potato             \ge potato
\e *                   \e *papa

@end example
@noindent
The reason is that an analysis with the root papa will come through as
follows:
@example

\a < N0 *papa > ...

@end example
@noindent
The solution is to make the left side of the transfer change
@code{*papa} rather than simply @code{papa}.


@c ----------------------------------------------------------------------------
@c Added by hab 14-May-1999
@node \maxprops (zzSYNT.CHG), \mcl (zzSYNT.CHG), \lc (zzSYNT.CHG), Synthesis file
@section Maximum number of properties: \maxprops
@findex \maxprops

This field can also occur in the STAMP declarations file or the STAMP
transfer control file instead; see
@ifset txt
`Maximum number of properties' in the chapter `STAMP declarations file'
above.
@end ifset
@ifclear txt
@ref{\maxprops}.
@end ifclear

@c ----------------------------------------------------------------------------
@node \mcl (zzSYNT.CHG), \mp (zzSYNT.CHG), \maxprops (zzSYNT.CHG), Synthesis file
@section Morpheme class declaration: \mcl
@findex \mcl

This field can also occur in the STAMP declarations file or the STAMP
transfer control file instead; see
@ifset txt
`Morpheme class declaration' in the chapter `STAMP declarations file' above.
@end ifset
@ifclear txt
@ref{\mcl}.
@end ifclear

@c ----------------------------------------------------------------------------
@node \mp (zzSYNT.CHG), \pcl (zzSYNT.CHG), \mcl (zzSYNT.CHG), Synthesis file
@section Morpheme property declaration: \mp
@findex \mp

This field can also occur in the STAMP declarations file or the STAMP
transfer control file instead; see
@ifset txt
`Morpheme property declaration' in the chapter `STAMP declarations file'
above.
@end ifset
@ifclear txt
@ref{\mp}.
@end ifclear

@c ----------------------------------------------------------------------------
@c Added by hab 14-May-1999
@node \pcl (zzSYNT.CHG), \rd (zzSYNT.CHG), \mp (zzSYNT.CHG), Synthesis file
@section Punctuation class: \pcl
@findex \pcl

This field can also occur in the STAMP declarations file or the STAMP
transfer control file instead; see
@ifset txt
`Punctuation class' in the chapter `STAMP declarations file'
above.
@end ifset
@ifclear txt
@ref{\pcl}.
@end ifclear

@c ----------------------------------------------------------------------------
@node \rd (zzSYNT.CHG), \rsc, \pcl (zzSYNT.CHG), Synthesis file
@section Root delimiter: \rd
@findex \rd

This field can also occur in the STAMP declarations file or the STAMP
transfer control file instead; see
@ifset txt
`Root delimiter' in the chapter `STAMP declarations file' above.
@end ifset
@ifclear txt
@ref{\rd}.
@end ifclear

@c ----------------------------------------------------------------------------
@node \rsc, \rscid, \rd (zzSYNT.CHG), Synthesis file
@section Regular sound change: \rsc
@findex \rsc

The second part of a synthesis file defines regular sound changes
(RSCs).  The definition of an rsc may have five parts:
@enumerate

@item the field code @code{\rsc},
@item a match string,
@item a substitution string,
@item optionally, one or more one-character RSC identifiers, and
@item optionally, one or more string environment constraints.
@end enumerate
@noindent
RSCs are string changes as described in Weber, Black, and McConnel
(1988:80ff), except that RSCs may have identifiers following the
substitution string.

It is possible to have different sets of regular sound changes apply
to different roots.  The rules of each set must be identified by a
distinguishing character, called an RSC identifier, and all roots
undergoing each set must also be marked with the same identifier by
putting that character in front of the etymology in the source
language dictionary.  When SYNTHESIS sees a root beginning with an RSC
identifier, it strips it off (since it is not really part of the
string), remembering the type of RSC identifier it had.  Subsequently,
only RSCs of that type are applied to it.

Any character used as an RSC identifier must be declared in the
synthesis file with the @code{\rscid} field.  For
instance,
@example
\rscid * +
@end example
@noindent
declares @code{*} and @code{+} as RSC identifiers.

There are three things to know about the @code{\rscid} field:
@enumerate
@item There may be at most four classes of RSCs, so the @code{\rscid} field
may contain no more than four characters.

@item
If the @code{\rscid} field is not declared, SYNTHESIS assumes that there is a single class identified by an asterisk (@code{*}).  That is, no declaration is equivalent to the following declaration:
@example
\rscid *
@end example

@item
An RSC identifier should not be a character that could begin a word
(although it could be a character used only medially or finally within
words), nor should it be @code{/} because in the RSCs this is
interpreted as initiating a string environment constraint.
@end enumerate

The identifiers in an RSC indicate the roots to which the change
should be applied.  The RSC applies only to roots marked by one of its
identifiers.  For example, the root in analysis @i{a} would undergo
the RSC defined in @i{b} because it is marked by the identifier
(namely, @code{+}) in @i{b}:
@example
a. < N +auricula >
b. \rsc "au" "o" +
@end example
@noindent
Likewise, the rsc in @i{e} would apply to both @i{c} and @i{d}, since both @code{*} and @code{+}
occur as identifiers in @i{e}:
@example
c. < N +gzudu >
d. < field V *mido >
e. \rsc "d" "r" * + / [V] _ [V]
@end example

RSCs are applied to etymological forms to generate target language
roots in the following way:
@enumerate
@item
An etymological form is stored in the source language dictionary.
Ordinarily, this would be a reconstructed proto form.  This form would
bear the appropriate RSC identifier.

@item
The etymology is put into analyses (by assigning the field code of
etymologies to internal code @code{M} ) and passes unchanged to the
point where RSCs apply.  (This would be the case if in TRANSFER it is
not changed by any lexical changes, if in SYNTHESIS no dictionary
entry is found for it, and if it is not changed by any synthesis
lexical changes.)

@item
RSCs apply, recapitulating the sound changes by which the target
language form evolved from the proto-form.  Unlike lexical changes,
only one of which ever applies to a given root, all RSCs are applied
to each susceptible root.  The RSCs are applied in the order they are
defined, with each change applying to the output of all previous ones.
And unlike lexical changes, which must match the entire root, RSCs
apply whenever they match any portion of a root.
@end enumerate
@noindent
For example, consider the following set of rules (which assume the
default RSC identifier of @code{*}):
@example

\rsc "ch" > "ts" |(1) laminal to apical
\rsc "ts" > "s"  |(2) deaffrication
\rcs "ll" > "l"  |(3) depalatalization of *ll
\rcs "n~" > "n"  |(4) depalatalization of *n~

@end example
@noindent
Consider their effect on roots like @code{*chaki-} and @code{*llan~u}.
@example

input  :   *chaki     *llan~u
after 1:    tsaki      llan~u
after 2:    saki       llan~u
after 3:    saki       lan~u
after 4:    saki       lanu
@end example
@noindent
Note that each rule applies to the output of the previous rule.  (The
reader may wonder why two rules (@code{ch} to @code{ts} and then
@code{ts} to @code{s}) are used here instead of a direct change of
@code{ch} to @code{s}.  If the proto-language had @code{*ts} and the
change of @code{ts} to @code{s} were needed regardless of cases
produced by the first rule, this would be necessary.  However, this is
not the case in Quechua.  A single rule could have been used; two were
used for reasons of linguistic integrity: this models the actual
historical steps through which the language evolved; neighboring
dialects have undergone the first, more widespread change of @code{ch}
to @code{ts}, but not the more local change of @code{ts} to @code{s}.)

With the possible exception of a few loan words, many languages draw
their vocabulary from a single source language.  For such languages,
only one set of RSCs would be needed.  In other cases, the vocabulary
is drawn from multiple parents, and for each it might be useful to
derive target language words with different sets of RSCs.  For
Quechua, for example, in addition to deriving native roots from
Proto-Quechua forms, one could use RSCs to derive words borrowed from
Spanish, where RSCs carry out loan processes, such as changing mid
vowels to high vowels, stressed vowels to long vowels, vowel sequences
to vowel semivowel sequences, and so on.  In this case, since there
would be two sets of RSCs, it would be necessary to declare two rsc
identifiers, perhaps @code{*} for changes applied to Proto-Quechua
roots and @code{+} for changes applied to Spanish roots.

As is the case for string changes in general, RSCs may be conditioned.
The conditioning environments may make use of string classes, which
must be defined before being used.

The final example below gives the RSCs used to synthesize
Asheninca Campa:
@example

Regular sound changes for Asheninca Campa

   \rsc "hi"  "ii" / #_
   \rsc "h"   " "   /a_a / a_i / e_e / i_i / o_o / o_i / a_e
   \rsc "iha" "yaa"
   \rsc "ih"  "y"
   \rsc "eh"  "y"

   \rsc "g"   ""   / a_a / o_i
   \rsc "g"   "y"  / a_i / i_ / e_
   \rsc "g"   "k"  / _o

   \rsc "iy"  "y"   |ohig > oig > oiy > oy
					  |and rig > riy > ry
   \rsc "io"  "oo"  |Asheninca's Great Vowel Shift
   \rsc "oa"  "aa"
   \rsc "ei"  "ee"
   \rsc "ae"  "ai"  |so ahe > ae > ai
   \rsc "ch"  "tsy"
   \rsc "sh"  "sy"
   \rsc "se"  "sye"
@end example

@c ----------------------------------------------------------------------------
@node \rscid, \scl (zzSYNT.CHG), \rsc, Synthesis file
@section Regular sound change identifiers: \rscid
@findex \rscid

The @code{\rscid} field defines an RSC identifier.  See
@ifset txt
`Regular sound changes: \rsc' above.
@end ifset
@ifclear txt
@ref{\rsc}.
@end ifclear


@c ----------------------------------------------------------------------------
@node \scl (zzSYNT.CHG), \test, \rscid, Synthesis file
@section String class declaration: \scl
@findex \scl

This field can also occur in the STAMP declarations file or the STAMP
transfer control file instead; see
@ifset txt
`String class declaration' in the chapter `STAMP declarations file'
above.
@end ifset
@ifclear txt
@ref{\scl (zzSTAMP.DEC)}.
@end ifclear

@c ----------------------------------------------------------------------------
@node \test, Campa epenthesis revisited, \scl (zzSYNT.CHG), Synthesis file
@section Synthesis test: \test
@findex \test

@menu
* Campa epenthesis revisited::
* Reporting conditions::
* Test syntax::
@end menu


Some of the test mechanisms of AMPLE (Weber, Black, and McConnel
1988:149ff) have been incorporated into SYNTHESIS.  Only three of
AMPLE's built-in tests (Weber, Black, and McConnel 1988:150ff) apply
in SYNTHESIS.  These are string environment constraints (SEC_ST's,
Weber, Black, and McConnel 1988:74, 151), morpheme environment
constraints (MEC_FT's, Weber, Black, and McConnel 1988:74,
152), and punctuation environment constraints (PEC-ST's).


Like AMPLE, SYNTHESIS allows the user to define tests in terms of
information associated with a morpheme or allomorph.  The test
definitions must conform to the syntax detailed in 
@ifset txt
`Test Syntax' below.
@end ifset
@ifclear txt
@ref{Test syntax}.
@end ifclear
User-defined tests can be employed to constrain the selection of
allomorphs in cases that are too complex for string or morpheme
environment constraints.  Whenever a morpheme has two or more
allomorphs, the first one that passes all environmental conditions, as
well as all built-in and user-defined tests, is the one chosen as the
realization of that morpheme.  The order of tests in the synthesis
file determines the order in which they are applied.

If SYNTHESIS cannot parse a user-defined test, it reports this to
standard output as a ``syntax error,'' followed by an identification
of the offending test.

Every test begins with a field code and must be followed by a name,
either the name of a built-in test or a user-given name.  Unless it is
a built-in test, the name must be followed by the definition of the
test.  In test definitions, @code{current} refers to the morpheme
whose allomorph is currently being considered, while @code{left}
refers to the previous morpheme and @code{right} refers to the
following one.  @code{LEFT} and @code{RIGHT} refer to some (or all) of
the units to the left or right, respectively, as represented in the
following diagram:
@example

 MORPHNAMES:    M(1)  M(2)  M(3)  M(4) ... M(k)  M(k+1) ...
				 |     |     |     |        |      |
 CHOSEN          |     |     |     |        |      |
 ALLOMORPHS:    abc   def   ghi    ?   ...  ?      ?    ...
					 left current right
				 <---LEFT         RIGHT--->

@end example
@noindent
For details, see Weber, Black, and McConnel 1988:164ff.

A test definition may be followed by an action to be taken whenever
the test succeeds.  Actions have two uses:
@enumerate
@item
They can make late modifications to a synthesized target language word
(for example, handle Campa's epenthesis as illustrated below in
@ifset txt
`Campa epenthesis revisited').
above.
@end ifset
@ifclear txt
@ref{Campa epenthesis revisited}).
@end ifclear

@item
They can monitor a particular condition (defined by the user) and,
whenever it is found, make a report to standard output (usually
redirected to a log file).
@end enumerate
@noindent
Note that it is possible to write a test that is true for all
analyses; an action associated with such a test would apply to every
analysis.

The definition of an action must directly follow that of a test; it is
delimited by curly braces, that is, opened by @code{@{} and closed by @code{@}}.
Thus, a typical test with an action has the following form:
@example

\test NAME
	 (...definition of test...)
	 @{...definition of action...@}
@end example

There are two kinds of actions, insertion actions and report actions.  An insertion action has one of the following forms:
@example
@{ insert <string> before <position> @}
@{ insert <string> after  <position> @}
@end example
@noindent
where @code{<string>} is what is to be inserted and @code{<position>}
indicates the position with a keyword like current.  As explained
below, insertion actions should be used only under exceptional
circumstances.

A report action has one of the following forms:
@example

@{ report @}
@{ report "<message>" @}

@end example
@noindent
A report always outputs the test name and the offending analysis.  The
text of @code{<message>} is output as well, if supplied as part of the
report action.  Either double quotes, periods, or apostrophes may be
used to delimit the message.

We now illustrate the use of actions.


@c ----------------------------------------------------------------------------
@node Campa epenthesis revisited, Reporting conditions, \test, \test
@subsection Campa epenthesis revisited

In synthesizing Campa words, after all allomorphs have been chosen, an
epenthetic @code{t} must be inserted at boundaries which satisfy certain
phonological conditions.  These conditions are defined in a test which
has an action to insert the epenthetic @code{t} if the conditions are met.
This test is as follows:
@example

\test EPEN_t_FT
  (    NOT (left is PREFIX)
   AND (    NOT (left string matches #)
		AND NOT (right string matches #)
	   )
   AND (   (        (left string matches [V])
			AND NOT (left property is gdeleted)
			AND NOT (left property is FUC)
		   )
		OR (left string matches "N")
	   )
   AND (        (current string matches [V])
		AND NOT (current property is PUC)
	   )
  )
  @{ insert "t" before current @}

@end example

An alternative approach to Campa epenthesis is possible.  The
@code{EPEN_t_FT} test and its insertion action could be dispensed with
if allomorphs incorporating the epenthetic segment were added to the
dictionaries, and conditions for their selection were given with
string environment constraints or tests.  This would be more in line
with STAMP's overall design, and would make it possible to simplify
the handling of epenthesis both in analysis and synthesis.

However, putting these allomorphs into the dictionaries manually would
be very tedious.  A nice alternative would be to introduce them
computationally before the dictionary is loaded.  This could be done
by the PhonRule program, for example.

An insertion action is justified in the case of Campa epenthesis
because the phenomenon is superficial (indeed, it can apply after
allomorph selection) and because it is regular and pervasive (indeed,
it would require thousands of allomorphs to handle without an
insertion rule).  Insertion actions should be used only under such
exceptional circumstances.  We strongly encourage the user to use the
allomorph selection method wherever possible.

@c ----------------------------------------------------------------------------
@node Reporting conditions, Test syntax, Campa epenthesis revisited, \test
@subsection Reporting conditions

A test may be used as a monitor for violations of a particular
condition, reporting these to the standard output.  For example,
suppose one suspects errors in the order of morphemes for the target
language.  Assume that orderclasses for morphemes are defined in the
target language dictionaries, and that the condition should always
hold that a lesser orderclass never follows a greater one.  The
following test would monitor for violations of this
condition:
@example

\test ORDER_REPORT_ST
	(left orderclass > current orderclass)
	@{ report "Orderclass violation" @}

@end example
@noindent
This test would cause a message like the following to be printed to
standard output, where the first line gives the test name and the
second line gives the offending analysis:
@example

Report from test  ORDER_REPORT_ST
< V1 aka > MU IMPFV
Orderclass violation

@end example
@noindent
Note that when the report action includes a message, the message is
printed at the end of the report.

@c ----------------------------------------------------------------------------
@node Test syntax, , Reporting conditions, \test
@subsection Test syntax
@include usertest.txi


@c hab 14-May-1999 need to also add <punc_expr> to <factor>, add
@c <neighbor>, and insert <punc_expr> itself.

@c ----------------------------------------------------------------------------
@node Dictionary code table file, Dictionary orthography change table file, Synthesis file, Top
@chapter Dictionary Code Table File
@include dictcode.txi

@c ----------------------------------------------------------------------------
@node Dictionary orthography change table file, Dictionary files, Dictionary code table file, Top
@chapter Dictionary Orthography Change Table File
@include dictochg.txi

@c ----------------------------------------------------------------------------
@node Dictionary files, Text output control file, Dictionary orthography change table file, Top
@chapter Dictionary Files
@clear ample
@clear ampletxt
@clear amplentext
@include dictfile.txi

@c ----------------------------------------------------------------------------
@node Text output control file, Analysis files, Dictionary files, Top
@chapter Text Output Control File
@include textout.txi
@set textout-title Text Output Control File

@c ----------------------------------------------------------------------------
@node Analysis files, Bibliography, Text output control file, Top
@chapter Input Analysis Files
@cindex input analysis file
@cindex analysis input file
@include anafiles.txi

@c ----------------------------------------------------------------------------
@node Bibliography, Index, Analysis files, Top
@unnumbered Bibliography

@enumerate

@item
Weber, David J., H. Andrew Black, and Stephen R. McConnel. 1988.
@cite{AMPLE: a tool for exploring morphology}.
Occasional Publications in Academic Computing No.@: 12.
Dallas, TX: Summer Institute of Linguistics.

@item
Weber, David J., H. Andrew Black, Stephen R. McConnel, and Alan Buseman. 1990.
@cite{STAMP: a tool for dialect adaptation}.
Occasional Publications in Academic Computing No.@: 15.
Dallas, TX: Summer Institute of Linguistics.

@end enumerate

@c ----------------------------------------------------------------------------
@node Index, , Bibliography, Top
@chapter Index

@printindex cp

@c ----------------------------------------------------------------------------
@contents
@bye

@c field       dec   tra   syn   description
@c -----       ---   ---   ---   -----------
@c \ambig      yes   yes   yes   Ambiguity Marker
@c \ap         yes   yes   yes   Allomorph Property
@c \ca         yes   yes   yes   Category
@c \cat        yes   no    no    Prefix- or Suffix- Driven
@c \ccl        yes   yes   yes   Category Class
@c \cr         no    yes   no    Copy Rule
@c \fl         no    yes   no    Flag Rule
@c \ir         no    yes   no    Insertion Rule
@c \lc         no    yes   yes   Lexical Change
@c \maxprops   yes   yes   yes   Maximum number of properties
@c \mcl        yes   yes   yes   Morpheme Class
@c \mp         yes   yes   yes   Morpheme Property
@c \pcl        yes   yes   yes   Punctuation Class
@c \rd         yes   yes   yes   Root Delimiters
@c \rsc        no    no    yes   Regular Sound Change
@c \rscid      no    no    yes   Regular Sound Change Markers
@c \scl        yes   yes   yes   String Class
@c \sr         no    yes   no    Substitution Rule
@c \strcheck   yes   no    no    Character list for string checks
@c \test       no    no    yes   Synthesis Test
