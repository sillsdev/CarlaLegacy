<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.52
	 from ample.txi on 2 June 2006 -->

<TITLE>AMPLE Reference Manual</TITLE>
</HEAD>
<BODY>
<H1>AMPLE Reference Manual</H1>
<H2>A Morphological Parser for Linguistic Exploration</H2>
<H2>version 3.12</H2>
<H2>June 2006</H2>
<ADDRESS>by Stephen McConnel, H. Andrew Black, and Marius Doornenbal</ADDRESS>
<P>
<P><HR><P>
<H1>Table of Contents</H1>
<UL>
<LI><A NAME="TOC1" HREF="ample.html#SEC1">1  Introduction to the AMPLE program</A>
<LI><A NAME="TOC2" HREF="ample.html#SEC2">2  Running AMPLE</A>
<UL>
<LI><A NAME="TOC3" HREF="ample.html#SEC3">2.1  AMPLE Command Options</A>
<LI><A NAME="TOC4" HREF="ample.html#SEC4">2.2  Program Interaction</A>
</UL>
<LI><A NAME="TOC5" HREF="ample.html#SEC5">3  Standard format</A>
<LI><A NAME="TOC6" HREF="ample.html#SEC6">4  Analysis Data File</A>
<UL>
<LI><A NAME="TOC7" HREF="ample.html#SEC7">4.1  Analysis Data File Fields</A>
<UL>
<LI><A NAME="TOC8" HREF="ample.html#SEC8">4.1.1  Allomorphs Never Co-occur Constraint: \ancc</A>
<LI><A NAME="TOC9" HREF="ample.html#SEC9">4.1.2  Allomorph properties: \ap</A>
<LI><A NAME="TOC10" HREF="ample.html#SEC10">4.1.3  Categories: \ca</A>
<LI><A NAME="TOC11" HREF="ample.html#SEC11">4.1.4  Category output control: \cat</A>
<LI><A NAME="TOC12" HREF="ample.html#SEC12">4.1.5  Category output control for compound roots: \catcr</A>
<LI><A NAME="TOC13" HREF="ample.html#SEC13">4.1.6  Category class: \ccl</A>
<LI><A NAME="TOC14" HREF="ample.html#SEC14">4.1.7  Compound root category pair: \cr</A>
<LI><A NAME="TOC15" HREF="ample.html#SEC15">4.1.8  Dictionary decapitalization control: \dicdecap</A>
<LI><A NAME="TOC16" HREF="ample.html#SEC16">4.1.9  Final test: \ft</A>
<LI><A NAME="TOC17" HREF="ample.html#SEC17">4.1.10  Infix ad hoc pair: \iah</A>
<LI><A NAME="TOC18" HREF="ample.html#SEC18">4.1.11  Infix successor test: \it</A>
<LI><A NAME="TOC19" HREF="ample.html#SEC19">4.1.12  Maximum number of infixes: \maxi</A>
<LI><A NAME="TOC20" HREF="ample.html#SEC20">4.1.13  Maximum number of interfixes: \maxn</A>
<LI><A NAME="TOC21" HREF="ample.html#SEC21">4.1.14  Maximum number of null allomorphs: \maxnull</A>
<LI><A NAME="TOC22" HREF="ample.html#SEC22">4.1.15  Maximum number of prefixes: \maxp</A>
<LI><A NAME="TOC23" HREF="ample.html#SEC23">4.1.16  Maximum number of properties: \maxprops</A>
<LI><A NAME="TOC24" HREF="ample.html#SEC24">4.1.17  Maximum number of roots: \maxr</A>
<LI><A NAME="TOC25" HREF="ample.html#SEC25">4.1.18  Maximum number of suffixes: \maxs</A>
<LI><A NAME="TOC26" HREF="ample.html#SEC26">4.1.19  Morpheme Co-occurrence Constraint: \mcc</A>
<LI><A NAME="TOC27" HREF="ample.html#SEC27">4.1.20  Morpheme class: \mcl</A>
<LI><A NAME="TOC28" HREF="ample.html#SEC28">4.1.21  Morpheme properties: \mp</A>
<LI><A NAME="TOC29" HREF="ample.html#SEC29">4.1.22  Interfix ad hoc pair: \nah</A>
<LI><A NAME="TOC30" HREF="ample.html#SEC30">4.1.23  Interfix successor test: \nt</A>
<LI><A NAME="TOC31" HREF="ample.html#SEC31">4.1.24  Prefix ad hoc pair: \pah</A>
<LI><A NAME="TOC32" HREF="ample.html#SEC32">4.1.25  Word parser parameter settings: \patr</A>
<LI><A NAME="TOC33" HREF="ample.html#SEC33">4.1.26  Punctuation class: \pcl</A>
<LI><A NAME="TOC34" HREF="ample.html#SEC34">4.1.27  Prefix successor test: \pt</A>
<LI><A NAME="TOC35" HREF="ample.html#SEC35">4.1.28  Root ad hoc pair: \rah</A>
<LI><A NAME="TOC36" HREF="ample.html#SEC36">4.1.29  Root Delimiter Characters: \rd</A>
<LI><A NAME="TOC37" HREF="ample.html#SEC37">4.1.30  Root successor test: \rt</A>
<LI><A NAME="TOC38" HREF="ample.html#SEC38">4.1.31  Suffix ad hoc pair: \sah</A>
<LI><A NAME="TOC39" HREF="ample.html#SEC39">4.1.32  String class: \scl</A>
<LI><A NAME="TOC40" HREF="ample.html#SEC40">4.1.33  Suffix successor test: \st</A>
<LI><A NAME="TOC41" HREF="ample.html#SEC41">4.1.34  Valid allomorph and string environment characters: \strcheck</A>
</UL>
<LI><A NAME="TOC42" HREF="ample.html#SEC42">4.2  Test Syntax</A>
<LI><A NAME="TOC43" HREF="ample.html#SEC43">4.3  Morpheme Co-occurrence Constraint Syntax</A>
<LI><A NAME="TOC44" HREF="ample.html#SEC44">4.4  Allomorphs Never Co-occur Constraint Syntax</A>
</UL>
<LI><A NAME="TOC45" HREF="ample.html#SEC45">5  Dictionary Code Table File</A>
<UL>
<LI><A NAME="TOC46" HREF="ample.html#SEC46">5.1  Change standard format marker to internal code: \ch</A>
<LI><A NAME="TOC47" HREF="ample.html#SEC47">5.2  Infix dictionary fields: \infix</A>
<LI><A NAME="TOC48" HREF="ample.html#SEC48">5.3  Prefix dictionary fields: \prefix</A>
<LI><A NAME="TOC49" HREF="ample.html#SEC49">5.4  Root dictionary fields: \root</A>
<LI><A NAME="TOC50" HREF="ample.html#SEC50">5.5  Suffix dictionary fields: \suffix</A>
<LI><A NAME="TOC51" HREF="ample.html#SEC51">5.6  Unified dictionary fields: \unified</A>
</UL>
<LI><A NAME="TOC52" HREF="ample.html#SEC52">6  Dictionary Orthography Change Table File</A>
<UL>
<LI><A NAME="TOC53" HREF="ample.html#SEC53">6.1  Dictionary Orthography Change: \ch</A>
<LI><A NAME="TOC54" HREF="ample.html#SEC54">6.2  String class: \scl</A>
</UL>
<LI><A NAME="TOC55" HREF="ample.html#SEC55">7  Dictionary Files</A>
<UL>
<LI><A NAME="TOC56" HREF="ample.html#SEC56">7.1  Allomorph (internal code A)</A>
<LI><A NAME="TOC57" HREF="ample.html#SEC57">7.2  Category (internal code C)</A>
<LI><A NAME="TOC58" HREF="ample.html#SEC58">7.3  Elsewhere Allomorph (internal code E)</A>
<LI><A NAME="TOC59" HREF="ample.html#SEC59">7.4  Feature Descriptor (internal code F)</A>
<LI><A NAME="TOC60" HREF="ample.html#SEC60">7.5  Root Gloss (internal code G)</A>
<LI><A NAME="TOC61" HREF="ample.html#SEC61">7.6  Infix location (internal code L)</A>
<LI><A NAME="TOC62" HREF="ample.html#SEC62">7.7  Morphname (internal code M)</A>
<LI><A NAME="TOC63" HREF="ample.html#SEC63">7.8  Order class (internal code O)</A>
<LI><A NAME="TOC64" HREF="ample.html#SEC64">7.9  Morpheme property (internal code P)</A>
<LI><A NAME="TOC65" HREF="ample.html#SEC65">7.10  Morpheme type (internal code T)</A>
<LI><A NAME="TOC66" HREF="ample.html#SEC66">7.11  Underlying Form (internal code U)</A>
<LI><A NAME="TOC67" HREF="ample.html#SEC67">7.12  Morpheme Co-occurrence Constraint (internal code Z)</A>
<LI><A NAME="TOC68" HREF="ample.html#SEC68">7.13  Do not load (internal code !)</A>
</UL>
<LI><A NAME="TOC69" HREF="ample.html#SEC69">8  Text Input Control File</A>
<UL>
<LI><A NAME="TOC70" HREF="ample.html#SEC70">8.1  Input text files</A>
<LI><A NAME="TOC71" HREF="ample.html#SEC71">8.2  Ambiguity Marker Character: \ambig</A>
<LI><A NAME="TOC72" HREF="ample.html#SEC72">8.3  Bar code format marker character: \barchar</A>
<LI><A NAME="TOC73" HREF="ample.html#SEC73">8.4  Bar Code Format Code Characters: \barcodes</A>
<LI><A NAME="TOC74" HREF="ample.html#SEC74">8.5  Text Orthography Change: \ch</A>
<UL>
<LI><A NAME="TOC75" HREF="ample.html#SEC75">8.5.1  Basic changes</A>
<LI><A NAME="TOC76" HREF="ample.html#SEC76">8.5.2  Environmentally constrained changes</A>
<LI><A NAME="TOC77" HREF="ample.html#SEC77">8.5.3  Using text orthography changes</A>
<LI><A NAME="TOC78" HREF="ample.html#SEC78">8.5.4  Where orthography changes apply</A>
<LI><A NAME="TOC79" HREF="ample.html#SEC79">8.5.5  A sample orthography change table</A>
<LI><A NAME="TOC80" HREF="ample.html#SEC80">8.5.6  Syntax of Orthography Changes</A>
</UL>
<LI><A NAME="TOC81" HREF="ample.html#SEC81">8.6  Decomposition Separation Character: \dsc</A>
<LI><A NAME="TOC82" HREF="ample.html#SEC82">8.7  Fields to Exclude: \excl</A>
<LI><A NAME="TOC83" HREF="ample.html#SEC83">8.8  Primary format marker character: \format</A>
<LI><A NAME="TOC84" HREF="ample.html#SEC84">8.9  Fields to Include: \incl</A>
<LI><A NAME="TOC85" HREF="ample.html#SEC85">8.10  Lowercase/uppercase character pairs: \luwfc</A>
<LI><A NAME="TOC86" HREF="ample.html#SEC86">8.11  Multibyte lowercase/uppercase character pairs: \luwfcs</A>
<LI><A NAME="TOC87" HREF="ample.html#SEC87">8.12  Maximum number of decapitalizations: \maxdecap</A>
<LI><A NAME="TOC88" HREF="ample.html#SEC88">8.13  Prevent Any Decapitalization: \nocap</A>
<LI><A NAME="TOC89" HREF="ample.html#SEC89">8.14  Prevent Decapitalization of Individual Characters: \noincap</A>
<LI><A NAME="TOC90" HREF="ample.html#SEC90">8.15  String class: \scl</A>
<LI><A NAME="TOC91" HREF="ample.html#SEC91">8.16  Caseless word formation characters: \wfc</A>
<LI><A NAME="TOC92" HREF="ample.html#SEC92">8.17  Multibyte caseless word formation characters: \wfcs</A>
<LI><A NAME="TOC93" HREF="ample.html#SEC93">8.18  A sample text input control file</A>
</UL>
<LI><A NAME="TOC94" HREF="ample.html#SEC94">9  Output Analysis Files</A>
<UL>
<LI><A NAME="TOC95" HREF="ample.html#SEC95">9.1  Analysis file fields</A>
<UL>
<LI><A NAME="TOC96" HREF="ample.html#SEC96">9.1.1  Analysis field: \a</A>
<LI><A NAME="TOC97" HREF="ample.html#SEC97">9.1.2  Decomposition field: \d</A>
<LI><A NAME="TOC98" HREF="ample.html#SEC98">9.1.3  Category field: \cat</A>
<LI><A NAME="TOC99" HREF="ample.html#SEC99">9.1.4  Properties field: \p</A>
<LI><A NAME="TOC100" HREF="ample.html#SEC100">9.1.5  Feature Descriptors field: \fd</A>
<LI><A NAME="TOC101" HREF="ample.html#SEC101">9.1.6  Underlying form field: \u</A>
<LI><A NAME="TOC102" HREF="ample.html#SEC102">9.1.7  Word field: \w</A>
<LI><A NAME="TOC103" HREF="ample.html#SEC103">9.1.8  Formatting field: \f</A>
<LI><A NAME="TOC104" HREF="ample.html#SEC104">9.1.9  Capitalization field: \c</A>
<LI><A NAME="TOC105" HREF="ample.html#SEC105">9.1.10  Nonalphabetic field: \n</A>
</UL>
<LI><A NAME="TOC106" HREF="ample.html#SEC106">9.2  Ambiguous analyses</A>
<LI><A NAME="TOC107" HREF="ample.html#SEC107">9.3  Analysis failures</A>
</UL>
<LI><A NAME="TOC108" HREF="ample.html#SEC108">Bibliography</A>
<LI><A NAME="TOC109" HREF="ample.html#SEC109">10  Index</A>
</UL>
<P><HR><P>


<H1><A NAME="SEC1" HREF="ample.html#TOC1">1  Introduction to the AMPLE program</A></H1>

<P>
Since it was released in 1988, the AMPLE program has been used for
morphological analysis in many different languages.  It is a complex
program designed to tackle a complex problem.  This manual is intended
for reference purposes, to clarify fine points of input and behavior.
It is not designed as a tutorial or as a "cookbook" of how to use
AMPLE.

</P>
<P>
AMPLE uses a plethora of input files to control its behavior.  These
include two mandatory control files (the analysis data file and
dictionary code table file), two optional control files (the dictionary
orthography change table file and text control file), and a set of
dictionary files.  The format of each of these files is described in
this manual.

</P>

<H4>1.0.0.1  New features</H4>
<DL COMPACT>

<DT>1. Version 3.1 (July 1998) introduced enhanced multibyte character
<DD>
handling, especially with regard to capitalization.

<DT>2. Version 3.2 (October 1998) introduced reduplication patterns in
<DD>
the allomorph fields of the dictionary files.

<DT>3. Version 3.3 (May 1999) introduced punctuation environment
<DD>
constraints in the allomorph fields of the dictionary files.
These are handled by a new built-in test called PEC_ST.
This version also added two punctuation-oriented clauses to user-written tests.

<DT>4. Version 3.3.4 (November 1999) added XAMPLE compilation to the
<DD>
standard distribution, and added the <CODE>\patr</CODE> field to the analysis
data file for use by XAMPLE in controlling the PC-PATR word parser.

<DT>5. Version 3.3.7 (January 2000) added the <CODE>PromoteDefAtoms</CODE>
<DD>
value to the <CODE>\patr</CODE> field in the analysis data file for use by
XAMPLE in controlling the PC-PATR word parser.

<DT>6. Version 3.3.10 (April 2000) added the <CODE>PropertyIsFeature</CODE>
<DD>
value to the <CODE>\patr</CODE> field in the analysis data file for use by
XAMPLE in controlling the PC-PATR word parser.

<DT>7. Version 3.4.0 (July 2001) added the <CODE>\\catcr</CODE>
<DD>
field in the analysis data file for words which consist solely of
compound roots (i.e. no affixes).  It indicates whether the category of
the word (i.e. the content of the <CODE>\\cat</CODE> field in the analysis
file) should come from the leftmost or the rightmost root in the
compound.  The field content should be either <CODE>left</CODE> or
<CODE>right</CODE>.

<DT>8. Version 3.5.0 (March 2002) added the <CODE>\\ancc</CODE>
<DD>
field in the analysis data file for use by
XAMPLE for handling allomorphs never co-occur constraints.

<DT>9. Version 3.6.0 (June 2002) allows for an orderclass
<DD>
pair (min, max) which delimits the order class span of the affix.

<DT>10. Version 3.8.0 (January 2004) allows for negative string environment constraints.
<DD>
<DT>11. Version 3.9.0 (December 2004) allows for "interfixes" (affixes which appear between roots).
<DD>
<DT>12. Version 3.10.0 (October 2005) allows the final category output in the analysis output file to be computed.
<DD>
<DT>13. Version 3.11.0 (December 2005) added "recognize only"capability for XAMPLE (-j option).  When "true", the
<DD>
PC-PATR parse results are neither stored nor written to the analysis output.
Only for XAmple.

<DT>14. Version 3.12.0 (February 2006) allows for full reduplication.
<DD>
</DL>



<H1><A NAME="SEC2" HREF="ample.html#TOC2">2  Running AMPLE</A></H1>

<P>
AMPLE is a batch process oriented program.  It reads a number of
control files, and then processes one or more input text files to
produce an equal number of output analysis files.

</P>

<UL>
<LI><A HREF="ample.html#SEC3">Command options</A>
<LI><A HREF="ample.html#SEC4">Interaction</A>
</UL>



<H2><A NAME="SEC3" HREF="ample.html#TOC3">2.1  AMPLE Command Options</A></H2>

<P>
The AMPLE program uses an old-fashioned command line interface
following the convention of options starting with a dash character
(<SAMP>`-'</SAMP>).  The available options are listed below in alphabetical
order.  Those options which require an argument have the argument type
following the option letter.

</P>
<DL COMPACT>

<DT><CODE>-a</CODE>
<DD>
<A NAME="IDX1"></A>
causes debugging output for allomorph conditions.

<DT><CODE>-b</CODE>
<DD>
<A NAME="IDX2"></A>
allows the allomorph identifiers to be stored in memory.  (This feature
was added to support LinguaLinks.)

<DT><CODE>-c character</CODE>
<DD>
<A NAME="IDX3"></A>
selects the control file comment character.  The default is the vertical
bar (<CODE>|</CODE>).

<DT><CODE>-d number</CODE>
<DD>
<A NAME="IDX4"></A>
selects the maximum dictionary trie depth.  The default is 3, which
favors reduced memory needs over speed.

<DT><CODE>-e filename</CODE>
<DD>
<A NAME="IDX5"></A>
selects the PC-PATR grammar file for XAMPLE to use.  (XAMPLE is a version
of AMPLE that adds a PC-PATR style word parser to AMPLE.)  This option is
not recognized by AMPLE.

<DT><CODE>-f filename</CODE>
<DD>
<A NAME="IDX6"></A>
opens a command file containing the names of the control and data
files.  The default is to read those names from the standard input
(keyboard); see
section <A HREF="ample.html#SEC4">2.2  Program Interaction</A>.

<DT><CODE>-g</CODE>
<DD>
<A NAME="IDX7"></A>
causes root glosses to be output in the analysis file, and enables the
internal code <CODE>G</CODE> in the dictionary code table.

<DT><CODE>-i filename</CODE>
<DD>
<A NAME="IDX8"></A>
selects a single input text file.

<DT><CODE>-j</CODE>
<DD>
<A NAME="IDX9"></A>
enables "Recognize Only" mode for XAMPLE.  (This option is not
recognized by AMPLE.)  In this mode, the PC-PATR parse results are
neither stored nor written to the analysis output.  This greatly
reduces the memory consumption required to use the internal PC-PATR
engine to parse words for XAMPLE.  (Even with this option, the memory
required to parse a single word in XAMPLE can exceed 250MB when the
grammar and lexicon allow a large number of alternative parses!)

<DT><CODE>-m</CODE>
<DD>
<A NAME="IDX10"></A>
monitors progress of an analysis: <CODE>*</CODE> means an analysis failure,
<CODE>.</CODE> means a single analysis, <CODE>2</CODE>-<CODE>9</CODE> means
2-9 ambiguities, and <CODE>&#62;</CODE> means 10 or more ambiguities.
This is not compatible with the <SAMP>`-q'</SAMP> option.

<DT><CODE>-n number</CODE>
<DD>
<A NAME="IDX11"></A>
sets the maximum recommended morphname length.  Any morphnames longer
than <CODE>number</CODE> characters are truncated (with a warning message).

<DT><CODE>-o filename</CODE>
<DD>
<A NAME="IDX12"></A>
selects a single output analysis file.

<DT><CODE>-q</CODE>
<DD>
<A NAME="IDX13"></A>
causes AMPLE to operate "quietly" with minimal screen output.  This
is not compatible with the <SAMP>`-m'</SAMP> option.

<DT><CODE>-p</CODE>
<DD>
<A NAME="IDX14"></A>
causes ambiguous word percentages to be reported.

<DT><CODE>-r</CODE>
<DD>
<A NAME="IDX15"></A>
checks references to morphnames in all tests.

<DT><CODE>-s filename</CODE>
<DD>
<A NAME="IDX16"></A>
opens a file contains morphnames (or allomorphs) for a selective
analysis.  This is usually used together with the <SAMP>`-t'</SAMP> (trace)
option.

<DT><CODE>-t</CODE>
<DD>
<A NAME="IDX17"></A>
causes analyses to be traced.  This produces a huge amount of output.
Repeating the <CODE>-t</CODE> option causes SGML style trace output to be
produced.  Repeating the <CODE>-t</CODE> option three times
(i.e. as <CODE>-ttt</CODE>) causes XML style trace output to be
produced.

<DT><CODE>-u</CODE>
<DD>
<A NAME="IDX18"></A>
signals that dictionaries are unified, not split into prefix, infix,
suffix, and root files.

<DT><CODE>-w fields</CODE>
<DD>
<A NAME="IDX19"></A>
selects one or more of these optional output fields for writing to the
analysis file:

<CODE>d</CODE> enables writing the <CODE>\d</CODE> (morpheme decomposition) field<BR>
<CODE>p</CODE> enables writing the <CODE>\p</CODE> (properties) field<BR>
<CODE>w</CODE> enables writing the <CODE>\w</CODE> (original word) field

The default is to ask interactively about the <CODE>\d</CODE> and <CODE>\w</CODE>
fields, and to write the <CODE>\p</CODE> field without asking.  All three
fields can be selected for output by <SAMP>`-w dpw'</SAMP> or by
<SAMP>`-w d -w p -w w'</SAMP>.

<DT><CODE>-x fields</CODE>
<DD>
<A NAME="IDX20"></A>
prevents one or more of these optional output fields from being written
to the analysis file:

<CODE>d</CODE> disables writing the <CODE>\d</CODE> (morpheme decomposition) field<BR>
<CODE>p</CODE> disables writing the <CODE>\p</CODE> (properties) field<BR>
<CODE>w</CODE> disables writing the <CODE>\w</CODE> (original word) field

The default is to ask interactively about the <CODE>\d</CODE> and <CODE>\w</CODE>
fields, and to write the <CODE>\p</CODE> field without asking.  All three
fields can be excluded from output by <SAMP>`-x dpw'</SAMP> or by
<SAMP>`-x d -x p -x w'</SAMP>.

<DT><CODE>-v</CODE>
<DD>
<A NAME="IDX21"></A>
verifies tests by pretty printing the parse trees.
</DL>

<P>
The following options exist only in beta-test versions of the program,
since they are used only for debugging.

</P>
<DL COMPACT>

<DT><CODE>-/</CODE>
<DD>
<A NAME="IDX22"></A>
increments the debugging level.  The default is zero (no debugging output).

<DT><CODE>-z filename</CODE>
<DD>
<A NAME="IDX23"></A>
opens a file for recording a memory allocation log.

<DT><CODE>-Z address,count</CODE>
<DD>
<A NAME="IDX24"></A>
traps the program at the point where <CODE>address</CODE> is allocated or
freed for the <CODE>count</CODE>'th time.
</DL>



<H2><A NAME="SEC4" HREF="ample.html#TOC4">2.2  Program Interaction</A></H2>

<P>
If the <SAMP>`-f'</SAMP>, <SAMP>`-i'</SAMP>, and <SAMP>`-o'</SAMP> command options are not
used, AMPLE prompts for a number of file names, reading the standard
input for the desired values.  The interactive dialog goes like this:

<PRE>

C&#62; ample
AMPLE: A Morphological Parser for Linguistic Exploration
Version 3.0b9 (April 4, 1997), Copyright 1997 SIL, Inc.
Beta test version compiled Apr  4 1997 12:18:27
				Analysis Performed Wed Apr  4 14:41:02 1997
Analysis data file (xxAD01.CTL): hgad01.ctl
Dictionary code table (xxANCD.TAB or xxGyCD.TAB): hgancd.tab
Dictionary orthography change table (xxORDC.TAB) [none]:

Suffix dictionary file (xxSF01.DIC): hgsf01.dic
		8 changes loaded from suffix dictionary code table.
		SUFFIX DICTIONARY: Loaded 116 records

Root dictionary file (xxRTnn.DIC): hgrt01.dic
		7 changes loaded from root dictionary code table.
		ROOT DICTIONARY: Loaded 43 records
Next Root dictionary file (xxRTnn.DIC) [no more]:
Text Control File (xxINTX.CTL) [none]: hgintx.ctl
Include the original word in the output (Y or N) [n]? y
Include the morpheme decomposition in the output (Y or N) [n]? y

First Input file: hgtest.txt
Output file: hgtest.ana

INPUT: 78 words processed.

Next Input file [no more]:
C&#62;

</PRE>

<P>
Note that each prompt contains a reminder of the expected form of the
answer in parentheses and ends with a colon.  Several of the prompts
also contain the default answer in brackets.

</P>
<P>
Using the command options does not change the appearance of the program
screen output significantly, but the program displays the answers to
each of its prompts without waiting for input.  Assume that the file
<TT>`hgtest.cmd'</TT> contains the following, which is the same as the
answers given above:

<PRE>

hgad01.ctl
hgancd.tab

hgsf01.dic
hgrt01.dic

hgintx.ctl
y
y

</PRE>

<P>
Then running AMPLE with the command options produces screen output like
the following:

<PRE>

C&#62; ample -f hgtest.cmd -i hgtest.txt -o hgtest.ana
AMPLE: A Morphological Parser for Linguistic Exploration
Version 3.0b9 (April 4, 1997), Copyright 1997 SIL, Inc.
Beta test version compiled Apr  4 1997 12:18:27
				Analysis Performed Wed Apr  4 14:41:32 1997
Analysis data file (xxAD01.CTL): hgad01.ctl
Dictionary code table (xxANCD.TAB or xxGyCD.TAB): hgancd.tab
Dictionary orthography change table (xxORDC.TAB) [none]:

Suffix dictionary file (xxSF01.DIC): hgsf01.dic
		8 changes loaded from suffix dictionary code table.
		SUFFIX DICTIONARY: Loaded 116 records

Root dictionary file (xxRTnn.DIC): hgrt01.dic
		7 changes loaded from root dictionary code table.
		ROOT DICTIONARY: Loaded 43 records
Next Root dictionary file (xxRTnn.DIC) [no more]:
Text Control File (xxINTX.CTL) [none]: hgintx.ctl
Include the original word in the output (Y or N) [n]? y
Include the morpheme decomposition in the output (Y or N) [n]? y

INPUT: 78 words processed.
C&#62;

</PRE>

<P>
The only difference in the screen output is that the prompts for the
input text file and the output analysis file are not displayed.

</P>


<H1><A NAME="SEC5" HREF="ample.html#TOC5">3  Standard format</A></H1>
<P>
<A NAME="IDX25"></A>

</P>
<P>
The input control files
that AMPLE reads
and the output analysis files that AMPLE writes
are all <EM>standard format</EM> files.  This means that the files are
divided into records and fields.  Each file contains at least one
record, and some files may contain a large number of records.  Each
record contains one or more fields.  Each field occupies at least one
line, and is marked by a <EM>field code</EM> at the beginning of the
line.  A field code begins with a backslash character (<CODE>\</CODE>), and
contains 1 or more printing characters (usually alphabetic) in
addition.

</P>
<P>
If the file is designed to have multiple records, then one of the field
codes must be designated to be the <EM>record marker</EM>, and every
record begins with that field, even if it is empty apart from the field
code.  If the file contains only one record, then the relative order of
the fields is constrained only by their semantics.

</P>
<P>
It is worth emphasizing that field codes must be at the
<EM>beginning</EM> of a line.  Even a single space before the backslash
character prevents it from being recognized as a field code.

</P>
<P>
It is also worth emphasizing that record markers <EM>must</EM> be present
even if that field has no information for that record.  Omitting the
record marker causes two records to be merge into a single record, with
unpredictable results.

</P>


<H1><A NAME="SEC6" HREF="ample.html#TOC6">4  Analysis Data File</A></H1>
<P>
<A NAME="IDX26"></A>

</P>
<P>
The primary control file for the AMPLE program is called the
<EM>analysis data file</EM>.  It is a standard format file containing a
single data record.

</P>

<UL>
<LI><A HREF="ample.html#SEC7">Analysis data file fields</A>
<LI><A HREF="ample.html#SEC42">Test syntax</A>
<LI><A HREF="ample.html#SEC43">MCC syntax</A>
<LI><A HREF="ample.html#SEC44">ANCC syntax</A>
</UL>



<H2><A NAME="SEC7" HREF="ample.html#TOC7">4.1  Analysis Data File Fields</A></H2>

<P>
The fields that AMPLE recognizes for the analysis data file are
described below.  Fields that start with any other backslash codes are
ignored by AMPLE.

</P>

<UL>
<LI><A HREF="ample.html#SEC8">\ancc</A>: Allomorphs never co-occur constraint
<LI><A HREF="ample.html#SEC9">\ap</A>: Allomorph properties
<LI><A HREF="ample.html#SEC10">\ca</A>: Categories
<LI><A HREF="ample.html#SEC11">\cat (xxAD01.CTL)</A>: Category output control
<LI><A HREF="ample.html#SEC12">\catcr</A>: Category output control for compound roots
<LI><A HREF="ample.html#SEC13">\ccl</A>: Category class
<LI><A HREF="ample.html#SEC14">\cr</A>: Compound root category pair
<LI><A HREF="ample.html#SEC15">\dicdecap</A>: Dictionary decapitalization control
<LI><A HREF="ample.html#SEC16">\ft</A>: Final test
<LI><A HREF="ample.html#SEC17">\iah</A>: Infix ad hoc pair
<LI><A HREF="ample.html#SEC18">\it</A>: Infix successor test
<LI><A HREF="ample.html#SEC19">\maxi</A>: Maximum number of infixes
<LI><A HREF="ample.html#SEC20">\maxn</A>: Maximum number of interfixes
<LI><A HREF="ample.html#SEC21">\maxnull</A>: Maximum number of null allomorphs
<LI><A HREF="ample.html#SEC22">\maxp</A>: Maximum number of prefixes
<LI><A HREF="ample.html#SEC23">\maxprops</A>: Maximum number of properties
<LI><A HREF="ample.html#SEC24">\maxr</A>: Maximum number of roots
<LI><A HREF="ample.html#SEC25">\maxs</A>: Maximum number of suffixes
<LI><A HREF="ample.html#SEC26">\mcc</A>: Morpheme co-occurrence constraint
<LI><A HREF="ample.html#SEC27">\mcl</A>: Morpheme class
<LI><A HREF="ample.html#SEC28">\mp</A>: Morpheme properties
<LI><A HREF="ample.html#SEC29">\nah</A>: Interfix ad hoc pair
<LI><A HREF="ample.html#SEC30">\nt</A>: Interfix successor test
<LI><A HREF="ample.html#SEC31">\pah</A>: Prefix ad hoc pair
<LI><A HREF="ample.html#SEC32">\patr</A>: PC-PATR word parser control setting
<LI><A HREF="ample.html#SEC33">\pcl</A>: Punctuation class
<LI><A HREF="ample.html#SEC34">\pt</A>: Prefix successor test
<LI><A HREF="ample.html#SEC35">\rah</A>: Root ad hoc pair
<LI><A HREF="ample.html#SEC36">\rd</A>: Root delimiter characters
<LI><A HREF="ample.html#SEC37">\rt</A>: Root successor test
<LI><A HREF="ample.html#SEC38">\sah</A>: Suffix ad hoc pair
<LI><A HREF="ample.html#SEC39">\scl (xxAD01.CTL)</A>: String class
<LI><A HREF="ample.html#SEC40">\st</A>: Suffix successor test
<LI><A HREF="ample.html#SEC41">\strcheck</A>: Valid allomorph and string environment characters
</UL>



<H3><A NAME="SEC8" HREF="ample.html#TOC8">4.1.1  Allomorphs Never Co-occur Constraint: \ancc</A></H3>
<P>
<A NAME="IDX27"></A>

</P>
<P>
Allomorphs Never Co-occur constraints are valid only for XAMPLE.

</P>
<P>
An allomorphs never co-occur constraint is defined by the
<CODE>\ancc</CODE> field code followed by one or more allomorph identification
strings, and finally an allomorphs never co-occur environment.  This
constraint states that the indicated allomorph identification strings
may <B>never</B> co-occur.  If there is more than one environment, the
various environments are logically ANDed together (i.e. when all of the
indicated environments are found, then the constraint will fail; if
some, but not all, of the environments are found, then the constraint
will succeed).

</P>
<P>
For the syntax of allomorphs never co-occur constraints, see
section <A HREF="ample.html#SEC44">4.4  Allomorphs Never Co-occur Constraint Syntax</A>.

</P>
<P>
If no <CODE>\ancc</CODE> fields appear in the analysis data file, then AMPLE
does not eliminate any analyses by the <CODE>ANCC_FT</CODE> test.

</P>


<H3><A NAME="SEC9" HREF="ample.html#TOC9">4.1.2  Allomorph properties: \ap</A></H3>
<P>
<A NAME="IDX28"></A>

</P>
<P>
Allomorph properties are defined by the field code <CODE>\ap</CODE> followed
by one or more allomorph property names.  An allomorph property name
must be a single, contiguous sequence of printing characters.
Characters and words which have special meanings in tests should not be
used.

</P>
<P>
A maximum of 255 properties (including both allomorph and morpheme
properties) may be defined.  Any number of <CODE>\ap</CODE> fields may be
used so long as the number of property names does not exceed 255.

</P>
<P>
If no <CODE>\ap</CODE> fields appear in the analysis data file, then AMPLE
does not allow allomorph properties to be used in the dictionary files
or in the tests.

</P>


<H3><A NAME="SEC10" HREF="ample.html#TOC10">4.1.3  Categories: \ca</A></H3>
<P>
<A NAME="IDX29"></A>

</P>
<P>
Categories are defined by the field code <CODE>\ca</CODE> followed by one or
more category names.  A category name must be a single, contiguous
sequence of printing characters.  Characters and words which have
special meanings in tests should not be used.

</P>
<P>
A maximum of 255 categories may be defined.  Any number of <CODE>\ca</CODE>
fields may be used so long as the number of category names does not
exceed 255.

</P>
<P>
If no <CODE>\ca</CODE> fields appear in the analysis data file, then AMPLE
does not allow categories to be used in the dictionary entries or in
the tests.  This is inconceivable for AMPLE's model of morphology.

</P>


<H3><A NAME="SEC11" HREF="ample.html#TOC11">4.1.4  Category output control: \cat</A></H3>
<P>
<A NAME="IDX30"></A>

</P>
<P>
The category information to write to the analysis output file is
defined by the field code <CODE>\cat</CODE> followed by one or two words.
The first word must be either <CODE>prefix</CODE>, <CODE>suffix</CODE>, or
<CODE>computed</CODE> (or an abbreviation of one of those words), either
capitalized or lowercase.  The second word, if present, must be
<CODE>morpheme</CODE> (or an abbreviation thereof), either capitalized or
lowercase.

</P>
<P>
In addition, the <CODE>\catcr</CODE> further defines what category to use
for the case that a word consists solely of compound roots.

</P>
<P>
The <CODE>\cat</CODE> field may appear any number of times, but once is
enough.  If more than one such field occurs, the last one is the one
that is used.

</P>
<P>
If no <CODE>\cat</CODE> fields appear in the analysis data file, then AMPLE
does not write any category information to the output file.

</P>


<H3><A NAME="SEC12" HREF="ample.html#TOC12">4.1.5  Category output control for compound roots: \catcr</A></H3>
<P>
<A NAME="IDX31"></A>

</P>
<P>
The <CODE>\catcr</CODE> defines what category to output in the
analysis output file for the case when a word consists
solely of compound roots.
The first word must be either <CODE>left</CODE> or <CODE>right</CODE> (or an
abbreviation of one of those words), either capitalized or lowercase.
If the word is <CODE>left</CODE>, then the category of the
leftmost root in the compound will be used.  If the word is
<CODE>right</CODE>, then the category of the rightmost root in the
compound will be used.  If a <CODE>\cat</CODE> field appears, but no
<CODE>\catcr</CODE> field, then the default is to use the
rightmost root.

</P>
<P>
The <CODE>\catcr</CODE> field may appear any number of times, but once is
enough.  If more than one such field occurs, the last one is the one
that is used.

</P>
<P>
If no <CODE>\cat</CODE> field appears in the analysis data file, then AMPLE
does not write any category information to the output file,
regardless of the setting of the <CODE>\catcr</CODE> field.  That
is, the <CODE>\catcr</CODE> field has no effect whatsoever unless
the <CODE>\cat</CODE> field is also present.

</P>


<H3><A NAME="SEC13" HREF="ample.html#TOC13">4.1.6  Category class: \ccl</A></H3>
<P>
<A NAME="IDX32"></A>

</P>
<P>
A category class is defined by the field code <CODE>\ccl</CODE> followed by
the class name, which is followed in turn by one or more category names
or (previously defined) category class names.  A category class name
used as part of the class definition must be enclosed in square
brackets.

</P>
<P>
The class name must be a single, contiguous sequence of printing
characters.  Characters and words which have special meanings in tests
should not be used.  The category names must have been defined by an
earlier <CODE>\ca</CODE> field.

</P>
<P>
Each <CODE>\ccl</CODE> field defines a single category class.  Any number of
<CODE>\ccl</CODE> fields may appear in the file.

</P>
<P>
If no <CODE>\ccl</CODE> fields appear in the analysis data file, then AMPLE
does not allow any category classes to be used in tests or morpheme
environment constraints.

</P>


<H3><A NAME="SEC14" HREF="ample.html#TOC14">4.1.7  Compound root category pair: \cr</A></H3>
<P>
<A NAME="IDX33"></A>

</P>
<P>
An allowable compound root category pair is defined by the <CODE>\cr</CODE>
field code followed by two category names previously defined in a
<CODE>\ca</CODE> field.  The order of the category names is significant.

</P>
<P>
Any number of compound root category pairs may be declared.  If
compound roots are not allowed by a <CODE>\maxr</CODE> field, then the
compound root category pairs are ignored.

</P>
<P>
If no <CODE>\cr</CODE> fields appear in the analysis data file, then AMPLE
does not allow any compound roots.  This is, of course, immaterial if
the maximum number of roots is one (1).

</P>


<H3><A NAME="SEC15" HREF="ample.html#TOC15">4.1.8  Dictionary decapitalization control: \dicdecap</A></H3>
<P>
<A NAME="IDX34"></A>

</P>
<P>
The <CODE>\dicdecap</CODE> field indicates that allomorph strings in
dictionary entries should be decapitalized.  Only the field code is
significant; anything else in the field is ignored.

</P>
<P>
The <CODE>\dicdecap</CODE> field may appear any number of times, but once is
enough.

</P>
<P>
If no <CODE>\dicdecap</CODE> fields appear in the analysis data file, then
AMPLE stores dictionary entries verbatim without decapitalizing
allomorph strings.

</P>


<H3><A NAME="SEC16" HREF="ample.html#TOC16">4.1.9  Final test: \ft</A></H3>
<P>
<A NAME="IDX35"></A>

</P>
<P>
A final test is defined by the <CODE>\ft</CODE> field code followed by the
test name and possibly a test body.  The test body is not needed if the
test name is that of a built-in test (either MEC_FT or MCC_FT), or a
previously defined successor test that is to be used as a final test.

</P>
<P>
Any number of final tests may be defined in the file.
For details about the syntax of final tests, see
section <A HREF="ample.html#SEC42">4.2  Test Syntax</A>.

</P>
<P>
If no <CODE>\ft</CODE> fields appear in the analysis data file, AMPLE still
applies the built-in final tests MEC_FT and MCC_FT.

</P>


<H3><A NAME="SEC17" HREF="ample.html#TOC17">4.1.10  Infix ad hoc pair: \iah</A></H3>
<P>
<A NAME="IDX36"></A>

</P>
<P>
An infix ad hoc pair is defined by the <CODE>\iah</CODE> field code followed
by two morpheme identifiers.  The first morphname may belong to a
prefix, root, or suffix depending on what is allowed by the infix
dictionary entries.  The second must belong to an infix.

</P>
<P>
Any number of infix ad hoc pairs may be defined in the file.  However,
their use is strongly discouraged on linguistic grounds.

</P>
<P>
If no <CODE>\iah</CODE> fields appear in the analysis data file, then AMPLE
never eliminates any analyses via the infix <CODE>ADHOC_ST</CODE> test.

</P>


<H3><A NAME="SEC18" HREF="ample.html#TOC18">4.1.11  Infix successor test: \it</A></H3>
<P>
<A NAME="IDX37"></A>

</P>
<P>
An infix successor test is defined by the <CODE>\it</CODE> field code
followed by the test name and possibly a test body.  The test body is
not needed if the test name is that of a built-in test (either SEC_ST
ADHOC_ST, or PEC_ST), or a previously defined prefix test that is to
be used as an infix test.

</P>
<P>
Infix tests are applied in the order they appear in the analysis data
file.  If not explicitly listed, SEC_ST, ADHOC_ST, and PEC_ST are
applied after all the user-defined infix tests.

</P>
<P>
Any number of infix successor tests may be defined in the file.  For
the syntax of successor tests, see
section <A HREF="ample.html#SEC42">4.2  Test Syntax</A>.

</P>
<P>
If no <CODE>\it</CODE> fields appear in the analysis data file, AMPLE still
applies the built-in infix tests SEC_ST, ADHOC_ST and PEC_ST.

</P>


<H3><A NAME="SEC19" HREF="ample.html#TOC19">4.1.12  Maximum number of infixes: \maxi</A></H3>
<P>
<A NAME="IDX38"></A>

</P>
<P>
The maximum number of infixes that may appear in a word is defined by
the <CODE>\maxi</CODE> field code followed by a number greater than or equal
to zero.

</P>
<P>
The <CODE>\maxi</CODE> field may appear any number of times, but once is
enough.  If more than one such field occurs, the last one is the one
that is used.

</P>
<P>
If no <CODE>\maxi</CODE> fields appear in the analysis data file, then AMPLE
assumes that the language does not have infixes.

</P>


<H3><A NAME="SEC20" HREF="ample.html#TOC20">4.1.13  Maximum number of interfixes: \maxn</A></H3>
<P>
<A NAME="IDX39"></A>

</P>
<P>
(An "interfix" is an affix that can also appear between roots.)

</P>
<P>
The maximum number of interfixes that may appear in a word is defined by
the <CODE>\maxn</CODE> field code followed by a number greater than or equal
to zero.

</P>
<P>
The <CODE>\maxn</CODE> field may appear any number of times, but once is
enough.  If more than one such field occurs, the last one is the one
that is used.

</P>
<P>
If no <CODE>\maxn</CODE> fields appear in the analysis data file, then AMPLE
assumes that the language does not have interfixes.

</P>


<H3><A NAME="SEC21" HREF="ample.html#TOC21">4.1.14  Maximum number of null allomorphs: \maxnull</A></H3>
<P>
<A NAME="IDX40"></A>

</P>
<P>
The maximum number of null allomorphs that may appear in a word is
defined by the <CODE>\maxnull</CODE> field code followed by a number greater
than or equal to zero.

</P>
<P>
The <CODE>\maxnull</CODE> field may appear any number of times, but once is
enough.  If more than one such field occurs, the last one is the one
that is used.

</P>
<P>
If no <CODE>\maxnull</CODE> fields appear in the analysis data file, then
AMPLE limits the number of null allomorphs in a word to ten (10).

</P>


<H3><A NAME="SEC22" HREF="ample.html#TOC22">4.1.15  Maximum number of prefixes: \maxp</A></H3>
<P>
<A NAME="IDX41"></A>

</P>
<P>
The maximum number of prefixes that may appear in a word is defined by
the <CODE>\maxp</CODE> field code followed by a number greater than or equal
to zero.

</P>
<P>
The <CODE>\maxp</CODE> field may appear any number of times, but once is
enough.  If more than one such field occurs, the last one is the one
that is used.

</P>
<P>
If no <CODE>\maxp</CODE> fields appear in the analysis data file, then AMPLE
assumes that the language does not have prefixes.

</P>


<H3><A NAME="SEC23" HREF="ample.html#TOC23">4.1.16  Maximum number of properties: \maxprops</A></H3>
<P>
<A NAME="IDX42"></A>

</P>
<P>
The maximum number of properties that can be defined can be increased
from the default of 255 by giving the <CODE>\maxprops</CODE> field code
followed by a number greater than or equal to 255 but less than 65536.

</P>
<P>
The <CODE>\maxprops</CODE> field may appear any number of times, but once is
enough.  If more than one such field occurs, the one containing the
largest valid value is the one that is used.

</P>
<P>
The <CODE>\maxprops</CODE> must be used before any properties are defined.
This is the case for both morpheme and allomorph properties.

</P>
<P>
If no <CODE>\maxprops</CODE> fields appear in the analysis data file, then
AMPLE limits the number of properties which can be defined to 255.

</P>


<H3><A NAME="SEC24" HREF="ample.html#TOC24">4.1.17  Maximum number of roots: \maxr</A></H3>
<P>
<A NAME="IDX43"></A>

</P>
<P>
The maximum number of roots that may appear in a word is defined by
the <CODE>\maxr</CODE> field code followed by a number greater than or equal
to one.

</P>
<P>
The <CODE>\maxr</CODE> field may appear any number of times, but once is
enough.  If more than one such field occurs, the last one is the one
that is used.

</P>
<P>
If no <CODE>\maxr</CODE> fields appear in the analysis data file, then AMPLE
assumes that only a single root can appear in a word.

</P>


<H3><A NAME="SEC25" HREF="ample.html#TOC25">4.1.18  Maximum number of suffixes: \maxs</A></H3>
<P>
<A NAME="IDX44"></A>

</P>
<P>
The maximum number of suffixes that may appear in a word is defined by
the <CODE>\maxs</CODE> field code followed by a number greater than or equal
to zero.

</P>
<P>
The <CODE>\maxs</CODE> field may appear any number of times, but once is
enough.  If more than one such field occurs, the last one is the one
that is used.

</P>
<P>
If no <CODE>\maxs</CODE> fields appear in the analysis data file, then AMPLE
assumes that up to 100 suffixes can occur in a word.

</P>


<H3><A NAME="SEC26" HREF="ample.html#TOC26">4.1.19  Morpheme Co-occurrence Constraint: \mcc</A></H3>
<P>
<A NAME="IDX45"></A>

</P>
<P>
A morpheme co-occurrence constraint is defined by the <CODE>\mcc</CODE> field
code followed by one or more morpheme names or morpheme class names, and
finally a morpheme environment constraint.  Each morpheme class name
must be enclosed in square brackets, and must have been defined by a
prior <CODE>\mcl</CODE> field.

</P>
<P>
For the syntax of morpheme co-occurrence constraints, see
section <A HREF="ample.html#SEC43">4.3  Morpheme Co-occurrence Constraint Syntax</A>.

</P>
<P>
If no <CODE>\mcc</CODE> fields appear in the analysis data file, then AMPLE
does not eliminate any analyses by the <CODE>MCC_FT</CODE> test.

</P>


<H3><A NAME="SEC27" HREF="ample.html#TOC27">4.1.20  Morpheme class: \mcl</A></H3>
<P>
<A NAME="IDX46"></A>

</P>
<P>
A morpheme class is defined by the <CODE>\mcl</CODE> field code followed by the
class name, which is followed in turn by one or more morpheme names
or (previously defined) morpheme class names.  A morpheme class name
used as part of the class definition must be enclosed in square
brackets.

</P>
<P>
The class name must be a single, contiguous sequence of printing
characters.  Characters and words which have special meanings in tests
should not be used.  The morpheme names should be defined by an entry
in one of the dictionary files.

</P>
<P>
Each <CODE>\mcl</CODE> field defines a single morpheme class.  Any number of
<CODE>\mcl</CODE> fields may appear in the file.

</P>
<P>
If no <CODE>\mcl</CODE> fields appear in the analysis data file, then AMPLE
does not allow any morpheme classes in morpheme environment constraints
or tests.

</P>


<H3><A NAME="SEC28" HREF="ample.html#TOC28">4.1.21  Morpheme properties: \mp</A></H3>
<P>
<A NAME="IDX47"></A>

</P>
<P>
Morpheme properties are defined by the field code <CODE>\mp</CODE> followed
by one or more morpheme property names.  An morpheme property name
must be a single, contiguous sequence of printing characters.
Characters and words which have special meanings in tests should not be
used.

</P>
<P>
A maximum of 255 properties (including both allomorph and morpheme
properties) may be defined.  Any number of <CODE>\mp</CODE> fields may be
used so long as the number of property names does not exceed 255.

</P>
<P>
If no <CODE>\mp</CODE> fields appear in the analysis data file, then AMPLE
does not allow any morpheme properties in dictionary files or tests.

</P>


<H3><A NAME="SEC29" HREF="ample.html#TOC29">4.1.22  Interfix ad hoc pair: \nah</A></H3>
<P>
<A NAME="IDX48"></A>

</P>
<P>
An interfix ad hoc pair is defined by the <CODE>\nah</CODE> field code followed
by two morpheme identifiers.  The first morphname may belong to either
a root or an interfix.
The second must belong to an interfix.

</P>
<P>
Any number of interfix ad hoc pairs may be defined in the file.  However,
their use is strongly discouraged on linguistic grounds.

</P>
<P>
If no <CODE>\nah</CODE> fields appear in the analysis data file, then AMPLE
never eliminates any analyses via the interfix <CODE>ADHOC_ST</CODE> test.

</P>


<H3><A NAME="SEC30" HREF="ample.html#TOC30">4.1.23  Interfix successor test: \nt</A></H3>
<P>
<A NAME="IDX49"></A>

</P>
<P>
An interfix successor test is defined by the <CODE>\nt</CODE> field code
followed by the test name and possibly a test body.  The test body is
not needed if the test name is that of a built-in test (either SEC_ST
ADHOC_ST, or PEC_ST), or a previously defined prefix test or infix
test that is to be used as an interfix test.

</P>
<P>
Interfix tests are applied in the order they appear in the analysis data
file.  If not explicitly listed, SEC_ST, ADHOC_ST, and PEC_ST are
applied after all the user-defined interfix tests.

</P>
<P>
Any number of interfix successor tests may be defined in the file.  For
the syntax of successor tests, see
section <A HREF="ample.html#SEC42">4.2  Test Syntax</A>.

</P>
<P>
If no <CODE>\nt</CODE> fields appear in the analysis data file, AMPLE still
applies the built-in interfix tests SEC_ST, ADHOC_ST and PEC_ST.

</P>


<H3><A NAME="SEC31" HREF="ample.html#TOC31">4.1.24  Prefix ad hoc pair: \pah</A></H3>
<P>
<A NAME="IDX50"></A>

</P>
<P>
A prefix ad hoc pair is defined by the <CODE>\pah</CODE> field code followed
by two morpheme identifiers.  The first morphname may belong to either
a prefix or an infix (if infixes exist and can mingle with prefixes).
The second must belong to a prefix.

</P>
<P>
Any number of prefix ad hoc pairs may be defined in the file.  However,
their use is strongly discouraged on linguistic grounds.

</P>
<P>
If no <CODE>\pah</CODE> fields appear in the analysis data file, then AMPLE
never eliminates any analyses via the prefix <CODE>ADHOC_ST</CODE> test.

</P>


<H3><A NAME="SEC32" HREF="ample.html#TOC32">4.1.25  Word parser parameter settings: \patr</A></H3>
<P>
<A NAME="IDX51"></A>

</P>
<P>
The <CODE>\patr</CODE> field is recognized only by XAMPLE, not by AMPLE, and
has effect only if a grammar file is selected by the <CODE>-e</CODE> command
line option.  Each instance of this field sets one of the PC-PATR control
parameters.  Several instances of the field can occur in the analysis
data file in order to set several different parameters.  Each field
contains a parameter name followed by an argument giving its value.
These parameters and allowable arguments are discussed below.

</P>
<P>
Note that the parameter names and arguments following the <CODE>\patr</CODE>
field code are not case sensitive: <CODE>ON</CODE> is the same as <CODE>On</CODE>,
which is the same as <CODE>on</CODE>.  Also, the parameter names and arguments
may be abbreviated to the shortest unique value: <CODE>off</CODE> could be
written <CODE>of</CODE>, since that is sufficient to distinguish it from
<CODE>on</CODE>.

</P>
<DL COMPACT>

<DT><CODE>CheckCycles</CODE>
<DD>
This parameter controls a check against introducing cycles into the parse
chart.  This makes the parse safer, but slows it down.  Legal grammars
should not introduce cycles, but it can happen while developing grammars.
<CODE>\patr CheckCycles ON</CODE> enables this check, and <CODE>\patr
CheckCycles OFF</CODE> disables it.  The default is <CODE>ON</CODE>.

<DT><CODE>DebuggingLevel</CODE>
<DD>
This parameter specifies the amount of PC-PATR debugging information which
will be written to the log file.  Its argument is a number greater than
or equal to zero.  If zero, then no extra debugging information will be
written to the log file.  The default value is <CODE>0</CODE>.

NOTE: this parameter is most useful for the programmer.  It can produce
<EM>huge</EM> amounts of cryptic output.

<DT><CODE>FeatureStyle</CODE>
<DD>
This parameter controls the way that feature structures are written to
either the output analysis file or the log file, but not whether they are
written.  <CODE>\patr FeatureStyle Full</CODE> causes features to be displayed
in an indented format that makes obvious the embedded structure of each
feature.  <CODE>\patr FeatureStyle Flat</CODE> causes features to be displayed
in a flat, linear string that uses less space.  The default style is
<CODE>Flat</CODE>.

<DT><CODE>MaxAmbiguity</CODE>
<DD>
This parameter controls the maximum number of different parses for a
particular AMPLE word analysis that will be written to either the output
analysis file or the log file.  Its argument is a number greater than or
equal to one.  The default maximum is 10.

<DT><CODE>PromoteDefAtoms</CODE>
<DD>
This parameter controls whether default atomic feature values loaded from
the lexicon are "promoted" to ordinary atomic feature values before
parsing begins.  <CODE>\patr PromoteDefAtoms On</CODE> causes default atomic
values to be promoted.  <CODE>\patr PromoteDefAtoms Off</CODE> causes parsing
to use default atomic values still marked as default.  (This can affect
feature unification since a conflicting default value does not cause a
failure: the default value merely disappears.)  The default value is
<CODE>On</CODE>.

<DT><CODE>PropertyIsFeature</CODE>
<DD>
This parameter controls whether the values in the AMPLE analysis
<CODE>\p</CODE> (property) field are to be interpreted as feature template
names, the same as the values in the AMPLE analysis <CODE>\fd</CODE> (feature
descriptor) field.  <CODE>\patr PropertyIsFeature On</CODE> turns on this
behavior, and <CODE>\patr PropertyIsFeature Off</CODE> turns it off.  The
default value is <CODE>On</CODE>.

<DT><CODE>ShowAllFeatures</CODE>
<DD>
This parameter controls whether the feature structures for all nodes in
the parse tree are written to the output files, or just the feature
structure for the top node in the parse tree. <CODE>\patr ShowAllFeatures
On</CODE> causes features for all nodes to be written.  <CODE>\patr
ShowAllFeatures Off</CODE> causes only the feature structure for the top node
of the parse to be written.  The default value is <CODE>On</CODE>.

<DT><CODE>ShowFailures</CODE>
<DD>
This parameter controls how the parser handles parse failures.  An AMPLE
analysis may fail to parse either by failing the feature constraints or
by failing the phrase structure rules.  <CODE>\patr ShowFailures On</CODE>
causes partial results indicating the cause of parse failures to be
written to the log file.  <CODE>\patr ShowFailures Off</CODE> prevents any
extra output to the log file.  The default value is <CODE>Off</CODE>.

NOTE: since the purpose of using the PC-PATR word parser in XAMPLE is to
weed out incorrect AMPLE analyses, a large number of parse failures are
to be expected, which can cause <EM>huge</EM> log files.  This parameter is
best used in conjunction with the <CODE>-t</CODE> command line option when
tracing the analysis of a single word, or a small number of words.

<DT><CODE>ShowFeatures</CODE>
<DD>
This parameter controls whether or not any feature structures are written
to the output analysis file or the log file.  It does not affect any of
the other parameters related to how feature structures are written.
<CODE>\patr ShowFeatures On</CODE> enables writing feature structures to the
output files.  <CODE>\patr ShowFeatures Off</CODE> disables writing feature
structures.  The default value is <CODE>On</CODE>.

<DT><CODE>ShowGlosses</CODE>
<DD>
This parameter controls whether morpheme glosses are displayed in the
parse tree output.  <CODE>\patr ShowGlosses On</CODE> enables writing glosses
in the parse tree output.  <CODE>\patr ShowGlosses Off</CODE> disables writing
glosses.  If no morpheme glosses exist in the dictionary, then this
parameter is ignored.  The default value is <CODE>On</CODE>.

<DT><CODE>TimeLimit</CODE>
<DD>
This parameter limits the amount of time that parsing an AMPLE analysis
can take.  Its argument is a number greater than or equal to zero, which
is the maximum number of seconds than a parse is allowed before being
cancelled.  The default value is <CODE>0</CODE>, which has the special meaning
that no limit is imposed.

NOTE: this feature is new and still somewhat experimental.  It may not be
fully debugged, and may cause unforeseen side effects such as program
crashes some time after one or more parses are cancelled due to exceeding
the set time limit.

<DT><CODE>TopDownFilter</CODE>
<DD>
This parameter controls whether simple top-down filtering based on the
grammar categories is applied to the parse process.  <CODE>\patr
TopDownFilter On</CODE> enables this top-down filtering.  <CODE>\patr
TopDownFilter Off</CODE> disables the top-down filtering, slowing down the
parse but possibly finding more solutions.  The default value is
<CODE>On</CODE>.

<DT><CODE>TreeStyle</CODE>
<DD>
This parameter controls how parse trees are written to either the analyis
output file or the log file.

<CODE>\patr TreeStyle Full</CODE> causes parses to be written in a somewhat
graphic tree display format, using ASCII characters to draw the branches
of the tree.

<CODE>\patr TreeStyle Flat</CODE> causes parses to be written as parenthesized
strings, similar to the way that LISP represents trees.  This is the
default value: it may be cryptic, but it requires the least space.

<CODE>\patr TreeStyle Indented</CODE> causes parses to be written in an
indented format sometimes called a <EM>northwest tree</EM>.

<CODE>\patr TreeStyle XML</CODE> causes parses to be written in an XML format,
with each node containing the feature structure associated with that node
of the parse tree.  This setting causes the <CODE>FeatureStyle</CODE> parameter
to be ignored.

<CODE>\patr TreeStyle None</CODE> prevents parses from being written.  This
allows PC-PATR word grammars to be used for filtering invalid AMPLE
analyses without cluttering up the output analysis files.

<DT><CODE>TrimEmptyFeatures</CODE>
<DD>
This parameter controls whether empty feature structures are written to
the output files.  <CODE>\patr TrimEmptyFeatures On</CODE> disables the display
of empty feature values. <CODE>\patr TrimEmptyFeatures Off</CODE> enables the
display of empty features.  The default value is <CODE>Off</CODE>.

<DT><CODE>Unification</CODE>
<DD>
This parameter controls whether the parsing process allows unification
failures to block successful parsing.  <CODE>\patr Unification On</CODE> causes
the constituent structure rules to constrain the parse.  <CODE>\patr
Unification Off</CODE> causes feature unification failures to be ignored while
parsing.  (Most likely, this would be useful only while debugging the
word grammar.) The default value is <CODE>On</CODE>.

</DL>



<H3><A NAME="SEC33" HREF="ample.html#TOC33">4.1.26  Punctuation class: \pcl</A></H3>
<P>
<A NAME="IDX52"></A>

</P>
<P>
A punctuation class is defined by the field code <CODE>\pcl</CODE> followed
by the class name, which is followed in turn by one or more
punctuation characters or (previously defined) punctuation class
names.  A punctuation class name used as part of the class definition
must be enclosed in square brackets.

</P>
<P>
The class name must be a single, contiguous sequence of printing
characters.  The individual members of the class are separated by
spaces, tabs, or newlines.

</P>
<P>
Each <CODE>\pcl</CODE> field defines a single punctuation class.  Any number of
<CODE>\pcl</CODE> fields may appear in the file.

</P>
<P>
If no <CODE>\pcl</CODE> fields appear in the analysis data file, then AMPLE
does not allow any punctuation classes in tests, and does not allow any
punctuation classes in punctuation environment constraints.

</P>


<H3><A NAME="SEC34" HREF="ample.html#TOC34">4.1.27  Prefix successor test: \pt</A></H3>
<P>
<A NAME="IDX53"></A>

</P>
<P>
A prefix successor test is defined by the <CODE>\pt</CODE> field code
followed by the test name and possibly a test body.  The test body is
not needed if the test name is that of a built-in test (either SEC_ST,
ADHOC_ST, or PEC_ST).

</P>
<P>
Prefix tests are applied in the order they appear in the analysis data
file.  If not explicitly listed, SEC_ST, ADHOC_ST, and PEC_ST are
applied after all the user-defined prefix tests.

</P>
<P>
Any number of prefix successor tests may be defined in the file.  For
the syntax of successor tests, see
section <A HREF="ample.html#SEC42">4.2  Test Syntax</A>.

</P>
<P>
If no <CODE>\pt</CODE> fields appear in the analysis data file, AMPLE still
applies the built-in prefix tests SEC_ST, ADHOC_ST, and PEC_ST.

</P>


<H3><A NAME="SEC35" HREF="ample.html#TOC35">4.1.28  Root ad hoc pair: \rah</A></H3>
<P>
<A NAME="IDX54"></A>

</P>
<P>
A root ad hoc pair is defined by the <CODE>\rah</CODE> field code followed by
two morpheme identifiers.  The first identifier may belong to a prefix,
an infix (if infixes exist and can mingle with prefixes or roots), or a
root (if compound roots are allowed).  The second morpheme identifier
must belong to a root.

</P>
<P>
A prefix or infix identifier in a root ad hoc pair must be the affix's
morphname.  A root identifier in a root ad hoc pair must be given exactly
as it occurs in the analysis (an etymology or a gloss, depending on the
assignment to the <CODE>M</CODE> field in the root section of the dictionary
code table).

</P>
<P>
Any number of root ad hoc pairs may be defined in the file.  However,
their use is strongly discouraged on linguistic grounds.

</P>
<P>
If no <CODE>\rah</CODE> fields appear in the analysis data file, then AMPLE
never eliminates any analyses via the root <CODE>ADHOC_ST</CODE> test.

</P>


<H3><A NAME="SEC36" HREF="ample.html#TOC36">4.1.29  Root Delimiter Characters: \rd</A></H3>
<P>
<A NAME="IDX55"></A>

</P>
<P>
The root delimiter characters used in the output analysis file are
defined by the <CODE>\rd</CODE> field code followed by two characters,
possibly separated by spaces.  The first character is used to mark the
beginning of a root analysis and the second is used to mark its end.

</P>
<P>
The <CODE>\rd</CODE> field may appear any number of times, but once is
enough.  If more than one such field occurs, the last one is the one
that is used.

</P>
<P>
If no <CODE>\rd</CODE> fields appear in the analysis data file, then AMPLE
uses the delimiter characters <CODE>&#60;</CODE> and <CODE>&#62;</CODE>.

</P>


<H3><A NAME="SEC37" HREF="ample.html#TOC37">4.1.30  Root successor test: \rt</A></H3>
<P>
<A NAME="IDX56"></A>

</P>
<P>
A root successor test is defined by the <CODE>\rt</CODE> field code followed
by the test name and possibly a test body.  The test body is not
needed if the test name is that of a built-in test (SEC_ST, ADHOC_ST,
ROOTS_ST, or PEC_ST), or a previously defined prefix or infix test
that is to be used as a root test.

</P>
<P>
Root tests are applied in the order they appear in the analysis data
file.  If not explicitly listed, SEC_ST, ADHOC_ST, ROOT_ST, and PEC_ST
are applied after all the user-defined root tests.

</P>
<P>
Any number of root successor tests may be defined in the file.  For the
syntax of successor tests, see
section <A HREF="ample.html#SEC42">4.2  Test Syntax</A>.

</P>
<P>
If no <CODE>\rt</CODE> fields appear in the analysis data file, AMPLE still
applies the built-in root tests SEC_ST, ADHOC_ST, ROOTS_ST, and PEC_ST.

</P>


<H3><A NAME="SEC38" HREF="ample.html#TOC38">4.1.31  Suffix ad hoc pair: \sah</A></H3>
<P>
<A NAME="IDX57"></A>

</P>
<P>
A suffix ad hoc pair is defined by the <CODE>\sah</CODE> field code followed
by two morpheme identifiers.  The first identifier may belong to a
root, an infix (if infixes exist and can mingle with roots or
suffixes), or a suffix.  The second morpheme identifier must belong to
a suffix.

</P>
<P>
A suffix or infix identifier in a suffix ad hoc pair must be the affix's
morphname.  A root identifier in a suffix ad hoc pair must be given exactly
as it occurs in the analysis (an etymology or a gloss, depending on the
assignment to the <CODE>M</CODE> field in the root section of the dictionary
code table).

</P>
<P>
Any number of suffix ad hoc pairs may be defined in the file.  However,
their use is strongly discouraged on linguistic grounds.

</P>
<P>
If no <CODE>\sah</CODE> fields appear in the analysis data file, then AMPLE
never eliminates any analyses via the suffix <CODE>ADHOC_ST</CODE> test.

</P>


<H3><A NAME="SEC39" HREF="ample.html#TOC39">4.1.32  String class: \scl</A></H3>
<P>
<A NAME="IDX58"></A>

</P>
<P>
A string class is defined by the <CODE>\scl</CODE> field code followed by the
class name, which is followed in turn by one or more contiguous
character strings or (previously defined) string class names.  A string
class name used as part of the class definition must be enclosed in
square brackets.

</P>
<P>
The class name must be a single, contiguous sequence of printing
characters.  Characters and words which have special meanings in tests
should not be used.  The actual character strings have no such
restrictions.  The individual members of the class are separated by
spaces, tabs, or newlines.

</P>
<P>
Each <CODE>\scl</CODE> field defines a single string class.  Any number of
<CODE>\scl</CODE> fields may appear in the file.

</P>
<P>
If no <CODE>\scl</CODE> fields appear in the analysis data file, then AMPLE
does not allow any string classes in tests, and does not allow any
string classes in string environment constraints unless they are
defined in the text input control file or the dictionary orthography
changes file.

</P>


<H3><A NAME="SEC40" HREF="ample.html#TOC40">4.1.33  Suffix successor test: \st</A></H3>
<P>
<A NAME="IDX59"></A>

</P>
<P>
A suffix successor test is defined by the <CODE>\st</CODE> field code
followed by the test name and possibly a test body.  The test body is
not needed if the test name is that of a built-in test (either SEC_ST,
ADHOC_ST, or PEC_ST), or a previously defined prefix, infix, or root
test that is to be used as a suffix test.

</P>
<P>
Suffix tests are applied in the order they appear in the analysis data
file.  If not explicitly listed, SEC_ST, ADHOC_ST, and PEC_ST are
applied after all the user-defined suffix tests.

</P>
<P>
Any number of suffix successor tests may be defined in the file.  For
the syntax of successor tests, see
section <A HREF="ample.html#SEC42">4.2  Test Syntax</A>.

</P>
<P>
If no <CODE>\st</CODE> fields appear in the analysis data file, AMPLE still
applies the built-in suffix tests SEC_ST, ADHOC_ST, and PEC_ST.

</P>


<H3><A NAME="SEC41" HREF="ample.html#TOC41">4.1.34  Valid allomorph and string environment characters: \strcheck</A></H3>
<P>
<A NAME="IDX60"></A>

</P>
<P>
The characters considered to be valid for allomorph strings and string
environment constraints are defined by a <CODE>\strcheck</CODE> field code
followed by the list of characters.  Spaces are not significant in this
list.

</P>
<P>
The <CODE>\strcheck</CODE> field may appear any number of times, but once is
enough.  If more than one such field occurs, the last one is the one
that is used.

</P>
<P>
If no <CODE>\strcheck</CODE> fields appear in the analysis data file, then
AMPLE does not check allomorph strings and string environment
constraints for containing only valid characters.

</P>


<H2><A NAME="SEC42" HREF="ample.html#TOC42">4.2  Test Syntax</A></H2>
<P>
<A NAME="IDX61"></A>

</P>
<P>
The remainder of this chapter presents grammatical descriptions of the
syntax of tests and morpheme co-occurrence constraints in BNF notation.
The following comments explain how to read the syntax rules given
below:

<OL>

<LI>

Names shown inside wedges (<CODE>&#60;&#62;</CODE>) are nonterminal symbols.  These
must eventually be expanded into terminal symbols.

<LI>

The symbol <CODE>::=</CODE> means "is replaced by."

<LI>

Items on the righthand side of the rule (following the <CODE>::=</CODE>) that
are not enclosed in wedges are terminal symbols, and appear in the rule
exactly as they must appear in
an AMPLE control file.
Whitespace is largely optional; it is required only to separate
identifiers and keywords.  (Keywords are the alphabetic terminal
symbols shown in the rules below.)

<LI>

Alternative ways of replacing a nonterminal symbol are listed on
separate lines.
</OL>


<PRE>

 1.  &#60;test&#62;          ::= &#60;identifier&#62; &#60;body&#62;

 2a. &#60;body&#62;          ::= &#60;body&#62; &#60;logop&#62; &#60;factor&#62;
 2b.                     IF &#60;factor&#62; THEN &#60;factor&#62;
 2c.                     &#60;forleft&#62; &#60;factor&#62;
 2d.                     &#60;forright&#62; &#60;factor&#62;
 2e.                     &#60;factor&#62;

 3a. &#60;factor&#62;        ::= NOT &#60;factor&#62;
 3b.                     ( &#60;body&#62; )
 3c.                     &#60;property_expr&#62;
 3d.                     &#60;string_expr&#62;
 3e.                     &#60;type_expr&#62;
 3f.                     &#60;category_expr&#62;
 3g.                     &#60;order_expr&#62;
 3h.                     &#60;cap_expr&#62;
 3i.                     &#60;punct_expr&#62;

 4.  &#60;property_expr&#62; ::= &#60;position&#62; property is &#60;identifier&#62;

 5a. &#60;string_expr&#62;   ::= &#60;position&#62; morphname is &#60;identifier&#62;
 5b.                     &#60;position&#62; morphname is member &#60;identifier&#62;
 5c.                     &#60;position&#62; morphname is &#60;position&#62; morphname
 5d.                     &#60;position&#62; allomorph is &#60;identifier&#62;
 5e.                     &#60;position&#62; allomorph is member &#60;identifier&#62;
 5f.                     &#60;position&#62; allomorph is &#60;position&#62; allomorph
 5g.                     &#60;position&#62; allomorph matches &#60;identifier&#62;
 5h.                     &#60;position&#62; allomorph matches member &#60;identifier&#62;
 5i.                     &#60;position&#62; allomorph matches &#60;position&#62; allomorph
 5j.                     &#60;position&#62; surface is &#60;identifier&#62;
 5k.                     &#60;position&#62; surface is member &#60;identifier&#62;
 5l.                     &#60;position&#62; surface is &#60;position&#62; allomorph
 5m.                     &#60;position&#62; surface matches &#60;identifier&#62;
 5n.                     &#60;position&#62; surface matches member &#60;identifier&#62;
 5o.                     &#60;position&#62; surface matches &#60;position&#62; allomorph
 5p.                     &#60;neighbor&#62; word is &#60;identifier&#62;
 5q.                     &#60;neighbor&#62; word is member &#60;identifier&#62;
 5r.                     &#60;neighbor&#62; word matches &#60;identifier&#62;
 5s.                     &#60;neighbor&#62; word matches member &#60;identifier&#62;

 6.  &#60;type_expr&#62;     ::= &#60;position&#62; type is &#60;type&#62;

 7a. &#60;category_expr&#62; ::= &#60;position&#62; fromcategory is &#60;position&#62; fromcategory
 7b.                     &#60;position&#62; fromcategory is &#60;position&#62; tocategory
 7c.                     &#60;position&#62; tocategory is &#60;position&#62; fromcategory
 7d.                     &#60;position&#62; tocategory is &#60;position&#62; tocategory
 7e.                     &#60;position&#62; fromcategory is member &#60;identifier&#62;
 7f.                     &#60;position&#62; tocategory is member &#60;identifier&#62;
 7g.                     &#60;position&#62; fromcategory is &#60;identifier&#62;
 7h.                     &#60;position&#62; tocategory is &#60;identifier&#62;
 7i.                     outputcategory is &#60;identifier&#62;
 7j.                     outputcategory is member &#60;identifier&#62;

 8a. &#60;cap_expr&#62;      ::= &#60;position&#62; allomorph is capitalized
 8b.                     word is capitalized

 9a. &#60;order_expr&#62;    ::= &#60;position&#62; orderclass &#60;relop&#62; &#60;position&#62; orderclass
 9b.                     &#60;position&#62; orderclass &#60;relop&#62; &#60;position&#62; orderclassmin
 9c.                     &#60;position&#62; orderclass &#60;relop&#62; &#60;position&#62; orderclassmax
 9d.                     &#60;position&#62; orderclassmin &#60;relop&#62; &#60;position&#62; orderclass
 9e.                     &#60;position&#62; orderclassmin &#60;relop&#62; &#60;position&#62; orderclassmin
 9f.                     &#60;position&#62; orderclassmin &#60;relop&#62; &#60;position&#62; orderclassmax
 9g.                     &#60;position&#62; orderclassmax &#60;relop&#62; &#60;position&#62; orderclass
 9h.                     &#60;position&#62; orderclassmax &#60;relop&#62; &#60;position&#62; orderclassmin
 9i.                     &#60;position&#62; orderclassmax &#60;relop&#62; &#60;position&#62; orderclassmax
 9j.                     &#60;position&#62; orderclass &#60;relop&#62; &#60;constant&#62;
 9k.                     &#60;position&#62; orderclassmin &#60;relop&#62; &#60;constant&#62;
 9l.                     &#60;position&#62; orderclassmax &#60;relop&#62; &#60;constant&#62;

10a. &#60;punct_expr&#62;    ::= &#60;neighbor&#62; punctuation is &#60;identifier&#62;
10b.                     &#60;neighbor&#62; punctuation is member &#60;identifier&#62;

11.  &#60;logop&#62;         ::= AND
						 OR
						 XOR
						 IFF

12.  &#60;forleft&#62;       ::= FOR_ALL_LEFT
						 FOR-ALL-LEFT
						 FORALLLEFT
						 FOR_SOME_LEFT
						 FOR-SOME-LEFT
						 FORSOMELEFT

13.  &#60;forright&#62;      ::= FOR_ALL_RIGHT
						 FOR-ALL-RIGHT
						 FORALLRIGHT
						 FOR_SOME_RIGHT
						 FOR-SOME-RIGHT
						 FORSOMERIGHT

14.  &#60;neighbor&#62;      ::= last
						 next

15.  &#60;type&#62;          ::= prefix
						 infix
						 interfix
						 interfixinfix
						 interfixprefix
						 interfixsuffix
						 root
						 suffix
						 initial
						 final

16.  &#60;relop&#62;        ::= =
						&#62;
						&#62;=
						&#60;=
						&#60;
						~=

17.  &#60;position&#62;     ::= left
						right
						current
						LEFT
						RIGHT
						INITIAL
						FINAL

18a. &#60;identifier&#62;   ::= "&#60;word&#62;"
18b.                    '&#60;word&#62;'
18c.                    .&#60;word&#62;.
18d.                    [&#60;word&#62;]
18e.                    &#60;word&#62;

19.  &#60;word&#62;         ::= &#60;wchar&#62;
						&#60;wchar&#62;&#60;word&#62;

20.  &#60;wchar&#62;        ::= one of the following characters:
							!"#$%&#38;'*+,-./0123456789:;?
							@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_
							`abcdefghijklmnopqrstuvwxyz{}
							\200-\376 (character codes 128-254)

21.  &#60;constant&#62;     ::= &#60;number&#62;
						-&#60;number&#62;

22.  &#60;number&#62;       ::= &#60;digit&#62;
						&#60;digit&#62;&#60;number&#62;

23.  &#60;digit&#62;        ::= one of the following characters:  0123456789

</PRE>


<H4>4.2.0.1  Comments on selected BNF rules</H4>
<DL COMPACT>

<DT>1.
<DD>
A test consists of an identifier followed by the body of the test.  The
identifier is the name by which a test is known.  The body consists of
the expressions which are interpreted to evaluate the test.

<DT>4.
<DD>
The identifier in a property expression must be a property name defined
with <CODE>\mp</CODE> or <CODE>\ap</CODE> in the analysis data file.

<DT>5a.
<DD>
In a string expression involving morphnames, an identifier must be equal to
some morphname; for example, <CODE>left morphname is "PAST"</CODE> indicates that
the name of the morpheme to the left is PAST.

<DT>5b.
<DD>
A member identifier in such expressions must be the name of a class of
morphnames defined with <CODE>\mcl</CODE> in the analysis data file.

<DT>5dgjmpr.
<DD>
In a string expression involving allomorphs, surface strings, or
adjacent words, an identifier must be equal to some portion of a word after
any orthography change has been applied.  For example, <CODE>left allomorph
is "abadaba"</CODE> indicates that the allomorph of the morpheme to the left
is abadaba.

<DT>5ehknqs.
<DD>
A member identifier in such expressions must be the name of a
class of strings defined with <CODE>\scl</CODE> in the analysis data file.

<DT>5d-i.
<DD>
If reference is made to left, LEFT or INITIAL, the allomorph is tested
to see if it ends with the string; for example, <CODE>left allomorph
matches "ba"</CODE> indicates that the allomorph of the morpheme to the left
ends in ba.  If reference is made to current, right, RIGHT, or FINAL,
the allomorph is tested to see if it begins with the string.

<DT>5j-o.
<DD>
If reference is made to left, LEFT or INITIAL, the surface string is
tested to see if it ends with the given value.  If reference is made to
current, right, RIGHT, or FINAL, the surface string is tested to see if
it begins with the given value.

<DT>5p-s.
<DD>
If reference is made to last, the word is tested to see if it ends with
the string.  If reference is made to next, the word is tested to see if
it begins with the string.  (These should be avoided, and other means
used to prune analyses based on adjacent words.)

<DT>6.
<DD>
The type must be a keyword indicating whether the morpheme referred to
is a prefix, an infix, a root, and so on

<DT>7efj.
<DD>
The identifier must be the name of a class of categories defined with
<CODE>\ccl</CODE> in the analysis data file.

<DT>7ghi.
<DD>
The identifier must be a category defined with <CODE>\ca</CODE> in the
analysis data file.

<DT>9a-l.
<DD>
A constant is an integer between -32767 and (positive) 32767.  The
relational operator (relop) must be among those listed in
rule 16.
The terminals <CODE>orderclass</CODE> and <CODE>orderclassmin</CODE> are
treated identically.  Both refer to the first of potentially
two order class numbers in a dictionary order class field.
The terminal <CODE>orderclassmax</CODE> refers to the second
order class number in a dictionary order class field.  If the
second number is not present, <CODE>orderclassmax</CODE> is set to
the same value as <CODE>orderclass</CODE>.

<DT>10.
<DD>
Punctuation expressions always refer to punctuation either immediately
before or after the current word.  A <CODE>&#60;neighbor&#62;</CODE> value of
<CODE>last</CODE> refers to immediately before the current word and
a <CODE>&#60;neighbor&#62;</CODE> value of <CODE>next</CODE> refers to
immediately after the current word.

<DT>15.
<DD>
A note on interfixes: these are affixes which can also appear between
roots.  A given interfix is both a prefix and interfix or both a
suffix and an interfix or both an infix and interfix.  Therefore in a
test, one may specify the particular subtype of interfix (i.e. it is
also a prefix/infix/suffix).

<DT>18a-d.
<DD>
The quoted forms of an identifier are needed only if the identifier is
the same as one of the AMPLE test keywords.  It is recommended that the
quoted identifier not contain the closing quote character.

</DL>



<H2><A NAME="SEC43" HREF="ample.html#TOC43">4.3  Morpheme Co-occurrence Constraint Syntax</A></H2>

<P>
This section presents a grammatical description of the syntax of
morpheme co-occurrence constraints in BNF notation.  These constraints
are found either in the analysis data file
(see section <A HREF="ample.html#SEC26">4.1.19  Morpheme Co-occurrence Constraint: \mcc</A>)
or in a dictionary file
(see section <A HREF="ample.html#SEC67">7.12  Morpheme Co-occurrence Constraint (internal code Z)</A>).

</P>

<PRE>

 1a. &#60;constraint&#62;   ::= &#60;morphnames&#62; &#60;environments&#62;
 1b.                    { &#60;literal&#62; } &#60;morphnames&#62; &#60;environments&#62;

 2a. &#60;morphnames&#62;   ::= &#60;literal&#62;
 2b.                    &#60;literal&#62; &#60;morphnames&#62;
 2c.                    [ &#60;literal&#62; ]
 2d.                    [ &#60;literal&#62; ] &#60;morphnames&#62;

 3a. &#60;environments&#62; ::= &#60;environment&#62;
 3b.                    &#60;environment&#62; &#60;environments&#62;

 4a. &#60;environment&#62;  ::= &#60;marker&#62; &#60;leftside&#62; &#60;envbar&#62; &#60;rightside&#62;
 4b.                    &#60;marker&#62; &#60;leftside&#62; &#60;envbar&#62;
 4c.                    &#60;marker&#62; &#60;envbar&#62; &#60;rightside&#62;

 5a. &#60;leftside&#62;     ::= &#60;side&#62;
 5b.                    &#60;boundary&#62;
 5c.                    &#60;boundary&#62; &#60;side&#62;
 5d.                    &#60;side&#62; # &#60;side&#62;
 5e.                    &#60;boundary&#62; &#60;side&#62; # &#60;side&#62;

 6a. &#60;rightside&#62;  ::= &#60;side&#62;
 6b.                  &#60;boundary&#62;
 6c.                  &#60;side&#62; &#60;boundary&#62;
 6d.                  &#60;side&#62; # &#60;side&#62;
 6e.                  &#60;side&#62; # &#60;side&#62; &#60;boundary&#62;

 7a. &#60;side&#62;       ::= &#60;item&#62;
 7b.                  &#60;item&#62; &#60;side&#62;
 7c.                  &#60;item&#62; ... &#60;side&#62;

 8a. &#60;item&#62;       ::= &#60;piece&#62;
 8b.                  ( &#60;piece&#62; )

 9a. &#60;piece&#62;      ::= ~ &#60;piece&#62;
 9b.                  &#60;literal&#62;
 9c.                  [ &#60;literal&#62; ]
 9d.                  { &#60;literal&#62; }

10.  &#60;marker&#62;     ::= /
					  +/

11.  &#60;envbar&#62;     ::= _
					  ~_

12.  &#60;boundary&#62;   ::= #
					  ~#

13.  &#60;literal&#62;    ::= one or more contiguous characters

</PRE>


<H4>4.3.0.1  Comments on selected BNF rules</H4>
<DL COMPACT>

<DT>1b.
<DD>
A literal enclosed in braces is an arbitary identifier for this
morpheme co-occurrence constraint.  (This feature was added to support
LinguaLinks.)

<DT>2ab.
<DD>
A literal is a morphname from one of the dictionary files.

<DT>2cd.
<DD>
A literal enclosed in square brackets must be the name of a morpheme
class defined by a <CODE>\mcl</CODE> field in the analysis data file.

<DT>5-6.
<DD>
Note that what can appear to the left of the environment bar is a
mirror image of what can appear to the right.

<DT>5de.
<DD>
<DT>6de.
<DD>
These should be avoided, and other means used to prune analyses based
on adjacent words.

<DT>7c.
<DD>
An ellipsis (<CODE>...</CODE>) indicates a possible break in contiguity.

<DT>8b.
<DD>
Something enclosed in parentheses is optional.

<DT>9a.
<DD>
A tilde (<CODE>~</CODE>) reverses the desirability of an element, causing the
constraint to fail if it is found rather than fail if it is not found.

<DT>9b.
<DD>
A literal is a morphname from one of the dictionary files.

<DT>9c.
<DD>
A literal enclosed in square brackets must be the name of a morpheme
class defined by a <CODE>\mcl</CODE> field in the analysis data file.

<DT>9d.
<DD>
A literal enclosed in curly braces must be one of the following
(checked in this order):

<OL>
<LI>

one of the keywords <CODE>root</CODE>, <CODE>prefix</CODE>, <CODE>infix</CODE>, or
<CODE>suffix</CODE>
<LI>

a property name defined by an <CODE>\ap</CODE> or <CODE>\mp</CODE> field in the
analyis data file
<LI>

a category name defined by a <CODE>\ca</CODE> field in the analysis data file
<LI>

a category class name defined by a <CODE>\ccl</CODE> field in the analysis
data file
<LI>

a morpheme class name defined by a <CODE>\mcl</CODE> field in the analysis
data file
</OL>

<DT>10.
<DD>
A <CODE>/</CODE> is usually used for string environment constraints, but may
used for morpheme environment constraints in <CODE>\mcc</CODE> fields in the
analysis data file.

<DT>11.
<DD>
A tilde (<CODE>~</CODE>) attached to the environment bar inverts the sense of
the constraint as a whole.

<DT>12b.
<DD>
The boundary marker preceded by a tilde (<CODE>~#</CODE>) indicates that it
must not be a word boundary.

<DT>13.
<DD>
The special characters used by environment constraints can be included
in a literal only if they are immediately preceded by a backslash:

<PRE>

\+  \/  \#  \~  \[  \]  \(  \)  \{  \}  \.  \_  \\

</PRE>

</DL>



<H2><A NAME="SEC44" HREF="ample.html#TOC44">4.4  Allomorphs Never Co-occur Constraint Syntax</A></H2>

<P>
This section presents a grammatical description of the syntax of
allomorphs never co-occur constraints in BNF notation.  These constraints
are found in the analysis data file
(see section <A HREF="ample.html#SEC8">4.1.1  Allomorphs Never Co-occur Constraint: \ancc</A>).

</P>

<PRE>

 1a. &#60;constraint&#62;   ::= &#60;allomorphIDs&#62; &#60;environments&#62;
 1b.                    { &#60;literal&#62; } &#60;allomorphIDs&#62; &#60;environments&#62;

 2a. &#60;allomorphIDs&#62; ::= &#60;literal&#62;
 2b.                    &#60;literal&#62; &#60;allomorphIDs&#62;

 3a. &#60;environments&#62; ::= &#60;environment&#62;
 3b.                    &#60;environment&#62; &#60;environments&#62;

 4a. &#60;environment&#62;  ::= &#60;marker&#62; &#60;leftside&#62; &#60;envbar&#62; &#60;rightside&#62;
 4b.                    &#60;marker&#62; &#60;leftside&#62; &#60;envbar&#62;
 4c.                    &#60;marker&#62; &#60;envbar&#62; &#60;rightside&#62;

 5a. &#60;leftside&#62;     ::= &#60;side&#62;
 5b.                    &#60;boundary&#62;
 5c.                    &#60;boundary&#62; &#60;side&#62;
 5d.                    &#60;side&#62; # &#60;side&#62;
 5e.                    &#60;boundary&#62; &#60;side&#62; # &#60;side&#62;

 6a. &#60;rightside&#62;  ::= &#60;side&#62;
 6b.                  &#60;boundary&#62;
 6c.                  &#60;side&#62; &#60;boundary&#62;
 6d.                  &#60;side&#62; # &#60;side&#62;
 6e.                  &#60;side&#62; # &#60;side&#62; &#60;boundary&#62;

 7a. &#60;side&#62;       ::= &#60;item&#62;
 7b.                  &#60;item&#62; &#60;side&#62;
 7c.                  &#60;item&#62; ... &#60;side&#62;

 8a. &#60;item&#62;       ::= &#60;piece&#62;
 8b.                  ( &#60;piece&#62; )

 9a. &#60;piece&#62;      ::= ~ &#60;piece&#62;
 9b.                  &#60;literal&#62;

10.  &#60;marker&#62;     ::= /
					  ~/

11.  &#60;envbar&#62;     ::= _
					  ~_

12.  &#60;boundary&#62;   ::= #
					  ~#

13.  &#60;literal&#62;    ::= one or more contiguous characters

</PRE>


<H4>4.4.0.1  Comments on selected BNF rules</H4>
<DL COMPACT>

<DT>1b.
<DD>
A literal enclosed in braces is an arbitary identifier for this
allomorphs never co-occur constraint.

<DT>2ab.
<DD>
A literal is an allomorph identification string from one of the dictionary files.

<DT>5-6.
<DD>
Note that what can appear to the left of the environment bar is a
mirror image of what can appear to the right.

<DT>5de.
<DD>
<DT>6de.
<DD>
These should be avoided, and other means used to prune analyses based
on adjacent words.

<DT>7c.
<DD>
An ellipsis (<CODE>...</CODE>) indicates a possible break in contiguity.

<DT>8b.
<DD>
Something enclosed in parentheses is optional.

<DT>9a.
<DD>
A tilde (<CODE>~</CODE>) reverses the desirability of an element, causing the
constraint to fail if it is found rather than fail if it is not found.

<DT>9b.
<DD>
A literal is an allomorph identification string from one of the dictionary files.

<DT>10.
<DD>
A <CODE>/</CODE> is usually used for string environment constraints, but may
used for allomorphs never co-occur environment constraints in
<CODE>\ancc</CODE> fields in the analysis data file.

<DT>11.
<DD>
A tilde (<CODE>~</CODE>) attached to the environment bar inverts the sense of
the constraint as a whole.

<DT>12b.
<DD>
The boundary marker preceded by a tilde (<CODE>~#</CODE>) indicates that it
must not be a word boundary.

<DT>13.
<DD>
The special characters used by environment constraints can be included
in a literal only if they are immediately preceded by a backslash:

<PRE>

\+  \/  \#  \~  \[  \]  \(  \)  \{  \}  \.  \_  \\

</PRE>

</DL>



<H1><A NAME="SEC45" HREF="ample.html#TOC45">5  Dictionary Code Table File</A></H1>
<P>
<A NAME="IDX62"></A>

</P>
<P>
The
second
control file read by AMPLE contains the dictionary
code table.  Each entry of an AMPLE dictionary (whether for
roots, prefixes, infixes, or suffixes) is structured by field codes that
indicate the type of information that follows.  The dictionary code table
maps the field codes used in the dictionary files onto the internal codes
that AMPLE uses.  This allows linguists to use their favorite
dictionary field codes rather than constraining them to a predefined set.

</P>
<P>
The dictionary code table is divided into one or more sections,
one for each type of dictionary file.  Each section contains several
mappings of field codes in the form of simple changes.  The field codes
used in the dictionary code table file are described in the remainder
of this chapter.

</P>

<UL>
<LI><A HREF="ample.html#SEC46">\ch (xxANCD.TAB)</A>: Change standard format marker to internal code
<LI><A HREF="ample.html#SEC47">\infix</A>: Infix dictionary fields
<LI><A HREF="ample.html#SEC48">\prefix</A>: Prefix dictionary fields
<LI><A HREF="ample.html#SEC49">\root</A>: Root dictionary fields
<LI><A HREF="ample.html#SEC50">\suffix</A>: Suffix dictionary fields
<LI><A HREF="ample.html#SEC51">\unified</A>: Unified dictionary fields
</UL>



<H2><A NAME="SEC46" HREF="ample.html#TOC46">5.1  Change standard format marker to internal code: \ch</A></H2>
<P>
<A NAME="IDX63"></A>

</P>
<P>
A dictionary field code change is defined by <CODE>\ch</CODE> followed by two
quoted strings.  The first string is the field code used in the
dictionary (including the leading backslash character).  The second
string is the single capital letter designating the field type.  For
the lists of dictionary field type codes, see
section <A HREF="ample.html#SEC55">7  Dictionary Files</A>.

</P>
<P>
Any character not found in either the dictionary field code string or
the dictionary field type code may be used as the quoting character.
The double quote (<CODE>"</CODE>) or single quote (<CODE>'</CODE>) are most often
used for this purpose.

</P>


<H2><A NAME="SEC47" HREF="ample.html#TOC47">5.2  Infix dictionary fields: \infix</A></H2>
<P>
<A NAME="IDX64"></A>

</P>
<P>
The set of dictionary field code changes for an infix dictionary file
begins with <CODE>\infix</CODE>, optionally followed by the record marker
field code for the infix dictionary.  If the record marker is not
given, then the field code ("from string") from the first infix
dictionary field code change is used.
See section <A HREF="ample.html#SEC55">7  Dictionary Files</A>,
for the set of infix dictionary field type codes.

</P>


<H2><A NAME="SEC48" HREF="ample.html#TOC48">5.3  Prefix dictionary fields: \prefix</A></H2>
<P>
<A NAME="IDX65"></A>

</P>
<P>
The set of dictionary field code changes for a prefix dictionary file
begins with <CODE>\prefix</CODE>, optionally followed by the record marker
field code for the prefix dictionary.  If the record marker is not
given, then the field code ("from string") from the first prefix
dictionary field code change is used.
See section <A HREF="ample.html#SEC55">7  Dictionary Files</A>,
for the set of prefix dictionary field type codes.

</P>


<H2><A NAME="SEC49" HREF="ample.html#TOC49">5.4  Root dictionary fields: \root</A></H2>
<P>
<A NAME="IDX66"></A>

</P>
<P>
The set of dictionary field code changes for a root dictionary file
begins with <CODE>\root</CODE>, optionally followed by the record marker
field code for the root dictionary.  If the record marker is not
given, then the field code ("from string") from the first root
dictionary field code change is used.
See section <A HREF="ample.html#SEC55">7  Dictionary Files</A>,
for the set of root dictionary field type codes.

</P>


<H2><A NAME="SEC50" HREF="ample.html#TOC50">5.5  Suffix dictionary fields: \suffix</A></H2>
<P>
<A NAME="IDX67"></A>

</P>
<P>
The set of dictionary field code changes for a suffix dictionary file
begins with <CODE>\suffix</CODE>, optionally followed by the record marker
field code for the suffix dictionary.  If the record marker is not
given, then the field code ("from string") from the first suffix
dictionary field code change is used.
See section <A HREF="ample.html#SEC55">7  Dictionary Files</A>,
for the set of suffix dictionary field type codes.

</P>


<H2><A NAME="SEC51" HREF="ample.html#TOC51">5.6  Unified dictionary fields: \unified</A></H2>
<P>
<A NAME="IDX68"></A>

</P>
<P>
The set of dictionary field code changes for a unified dictionary file
begins with <CODE>\unified</CODE>, optionally followed by the record marker
field code for the unified dictionary.  If the record marker is not
given, then the field code ("from string") from the first unified
dictionary field code change is used.
See section <A HREF="ample.html#SEC55">7  Dictionary Files</A>,
for the set of unified dictionary field type codes.

</P>


<H1><A NAME="SEC52" HREF="ample.html#TOC52">6  Dictionary Orthography Change Table File</A></H1>
<P>
<A NAME="IDX69"></A>

</P>
<P>
The
third
control file read by AMPLE, and the
first
optional one,
contains the dictionary orthography change table.  This table maps the
allomorph strings in the dictionary files into the internal
orthographic representation.  When the text and internal orthographies
differ, it may be desirable to have the allomorphs in the dictionaries
stored in the same orthography as the texts, or it may be desirable to
have them in the internal form, or it might even be desirable to have
them in a third form.  AMPLE allows for any of these choices.

</P>
<P>
The dictionary orthography change table is defined by a special
standard format file.  This file contains a single record with two
types of fields, either of which may appear any number of times.  The
rest of this chapter describes these fields, focusing on the syntax of
the orthography changes.

</P>

<UL>
<LI><A HREF="ample.html#SEC53">\ch (xxORDC.TAB)</A>: Dictionary orthography change
<LI><A HREF="ample.html#SEC54">\scl (xxORDC.TAB)</A>: String class
</UL>



<H2><A NAME="SEC53" HREF="ample.html#TOC53">6.1  Dictionary Orthography Change: \ch</A></H2>
<P>
<A NAME="IDX70"></A>

</P>
<P>
An orthography change is defined by the <CODE>\ch</CODE> field code followed
by the actual orthography change.  Any number of orthography changes
may be defined in the dictionary orthography change table.  The output
of each change serves as the input the following change.  That is, each
change is applied as many times as necessary to a dictionary allomorph
before the next change from the dictionary orthography change table is
applied.
See section <A HREF="ample.html#SEC74">8.5  Text Orthography Change: \ch</A>,
for the syntax of orthography changes.

</P>


<H2><A NAME="SEC54" HREF="ample.html#TOC54">6.2  String class: \scl</A></H2>
<P>
<A NAME="IDX71"></A>

</P>
<P>
A string class is defined by the <CODE>\scl</CODE> field code followed by the
class name, which is followed in turn by one or more contiguous
character strings or (previously defined) string class names.  A string
class name used as part of the class definition must be enclosed in
square brackets.

</P>
<P>
The class name must be a single, contiguous sequence of printing
characters.  Characters and words which have special meanings in tests
should not be used.  The actual character strings have no such
restrictions.  The individual members of the class are separated by
spaces, tabs, or newlines.

</P>
<P>
Each <CODE>\scl</CODE> field defines a single string class.  Any number of
<CODE>\scl</CODE> fields may appear in the file.  The only restriction is
that a string class must be defined before it is used.

</P>
<P>
If no <CODE>\scl</CODE> fields appear in the dictionary orthography changes
file, then AMPLE does not allow any string classes in dictionary
orthography change environment constraints unless they are defined in
the analysis data file.

</P>


<H1><A NAME="SEC55" HREF="ample.html#TOC55">7  Dictionary Files</A></H1>
<P>
<A NAME="IDX72"></A>

</P>
<P>
This chapter describes the content of AMPLE dictionary
files.  These are normally divided into

<OL>
<LI>

a prefix dictionary file (if needed),
<LI>

an infix dictionary file (if needed),
<LI>

an suffix dictionary file (if needed), and
<LI>

one or more root dictionary files.
</OL>

<P>
With the <SAMP>`-u'</SAMP> command line option in conjunction with the
<CODE>\unified</CODE> field in the dictionary code table file, the
dictionary can be stored as one or more files containing entries of any
type: prefix, infix, suffix, or root.

</P>
<P>
The following sections describe the different types of fields used in
the different types of dictionary files.  Remember, the mapping from
the actual field codes used in the dictionary files to the type codes
that AMPLE uses internally is controlled by the dictionary code table
file
(see section <A HREF="ample.html#SEC45">5  Dictionary Code Table File</A>).

</P>

<UL>
<LI><A HREF="ample.html#SEC56">Allomorph</A>: Internal code A
<LI><A HREF="ample.html#SEC57">Category</A>: Internal code C
<LI><A HREF="ample.html#SEC58">Elsewhere allomorph</A>: Internal code E
<LI><A HREF="ample.html#SEC59">Feature descriptor</A>: Internal code F
<LI><A HREF="ample.html#SEC60">Root gloss</A>: Internal code G
<LI><A HREF="ample.html#SEC61">Infix location</A>: Internal code L
<LI><A HREF="ample.html#SEC62">Morphname</A>: Internal code M
<LI><A HREF="ample.html#SEC63">Order class</A>: Internal code O
<LI><A HREF="ample.html#SEC64">Morpheme property</A>: Internal code P
<LI><A HREF="ample.html#SEC65">Morpheme type</A>: Internal code T
<LI><A HREF="ample.html#SEC66">Underlying form</A>: Internal code U
<LI><A HREF="ample.html#SEC67">Morpheme co-occurrence constraint</A>: Internal code Z
<LI><A HREF="ample.html#SEC68">Do not load</A>: Internal code !
</UL>



<H2><A NAME="SEC56" HREF="ample.html#TOC56">7.1  Allomorph (internal code A)</A></H2>

<P>
Each dictionary entry must contain one or more allomorph fields.  Each
of these contains one of the affix/root's allomorphs, that is, the string of
characters by which the affix/root is represented in text and recognized by
AMPLE.

</P>
<P>
If an affix/root has multiple allomorphs, each one must be entered in its own
allomorph field.  These fields should be ordered with those on which the
strictest constraints have been imposed preceding those with less strict
or no constraints.  The only exception to this is the use of indexed
string classes to indicate reduplication.  (See lines 26 and 27 below.)

</P>
<P>
It is also possible to have a null allomorph (sometimes called a
zero).  This is indicated by the single digit 0.  The occurrence of
null allomorphs should be restricted in some way or another for
efficiency reason.  Because the digit 0 has a special meaning in
AMPLE, it must not be part of the internal orthography.  If
the practical orthography uses 0, it should be changed to some other
character in the orthography input table.

</P>
<P>
Properties, constraints, and comments may follow the allomorph string.
Any properties must be listed before any constraints.  String, punctuation and
morpheme environment constraints may be intermixed, but must come
before any comments.  A complete BNF grammar of an allomorph field is
given below.

</P>

<PRE>

 1a. &#60;allomorph_field&#62; ::= &#60;allomorph&#62;
 1b.                       &#60;allomorph&#62; &#60;properties&#62;
 1c.                       &#60;allomorph&#62; &#60;constraints&#62;
 1d.                       &#60;allomorph&#62; &#60;properties&#62; &#60;constraints&#62;
 1e.                       &#60;allomorph&#62; &#60;comment&#62;
 1f.                       &#60;allomorph&#62; &#60;properties&#62; &#60;comment&#62;
 1g.                       &#60;allomorph&#62; &#60;constraints&#62; &#60;comment&#62;
 1h.                       &#60;allomorph&#62; &#60;properties&#62; &#60;constraints&#62; &#60;comment&#62;

 2a. &#60;allomorph&#62;       ::= &#60;literal&#62;
 2b.                       &#60;literal&#62; { &#60;literal&#62; }
 2c.                       &#60;redup_pattern&#62;
 2d.                       &#60;redup_pattern&#62; { &#60;literal&#62; }
 2e.                       &#60;full_redup&#62;
 2f.                       &#60;full_redup&#62; { &#60;literal&#62; }

 3a. &#60;properties&#62;      ::= &#60;literal&#62;
 3b.                       &#60;literal&#62; &#60;properties&#62;

 4a. &#60;constraints&#62;     ::= &#60;string_constraint&#62;
 4b.                       &#60;negative_string_constraint&#62;
 4c.                       &#60;morph_constraint&#62;
 4d.                       &#60;punct_constraint&#62;
 4e.                       &#60;string_constraint&#62; &#60;constraints&#62;
 4f.                       &#60;negative_string_constraint&#62; &#60;constraints&#62;
 4g.                       &#60;morph_constraint&#62; &#60;constraints&#62;
 4h.                       &#60;punct_constraint&#62; &#60;constraints&#62;

 5.  &#60;comment&#62;         ::= &#60;comment_char&#62; anything to the end of the line

 6a. &#60;string_constraint&#62; ::= / &#60;envbar&#62; &#60;string_right&#62;
 6b.                         / &#60;string_left&#62; &#60;envbar&#62;
 6c.                         / &#60;string_left&#62; &#60;envbar&#62; &#60;string_right&#62;

 6d. &#60;negative_string_constraint&#62; ::= ~/ &#60;envbar&#62; &#60;string_right&#62;
 6e.                                  ~/ &#60;string_left&#62; &#60;envbar&#62;
 6f.                                  ~/ &#60;string_left&#62; &#60;envbar&#62; &#60;string_right&#62;

 7a. &#60;string_left&#62;       ::= &#60;string_side&#62;
 7b.                         &#60;boundary&#62;
 7c.                         &#60;boundary&#62; &#60;string_side&#62;
 7d.                         &#60;string_side&#62; # &#60;string_side&#62;
 7e.                         &#60;boundary&#62; &#60;string_side&#62; # &#60;string_side&#62;

 8a. &#60;string_right&#62;      ::= &#60;string_side&#62;
 8b.                         &#60;boundary&#62;
 8c.                         &#60;string_side&#62; &#60;boundary&#62;
 8d.                         &#60;string_side&#62; # &#60;string_side&#62;
 8e.                         &#60;string_side&#62; # &#60;string_side&#62; &#60;boundary&#62;

 9a. &#60;string_side&#62;       ::= &#60;string_item&#62;
 9b.                         &#60;string_item&#62; &#60;string_side&#62;
 9c.                         &#60;string_item&#62; ... &#60;string_side&#62;

10a. &#60;string_item&#62;       ::= &#60;string_piece&#62;
10b.                         ( &#60;string_piece&#62; )

11a. &#60;string_piece&#62;      ::= ~ &#60;string_piece&#62;
11b.                         &#60;literal&#62;
11c.                         [ &#60;literal&#62; ]
11d.                         [ &#60;indexed_literal&#62; ]

12a. &#60;morph_constraint&#62;  ::= +/ &#60;envbar&#62; &#60;morph_right&#62;
12b.                         +/ &#60;morph_left&#62; &#60;envbar&#62;
12c.                         +/ &#60;morph_left&#62; &#60;envbar&#62; &#60;morph_right&#62;

13a. &#60;morph_left&#62;        ::= &#60;morph_side&#62;
13b.                         &#60;boundary&#62;
13c.                         &#60;boundary&#62; &#60;morph_side&#62;
13d.                         &#60;morph_side&#62; # &#60;morph_side&#62;
13e.                         &#60;boundary&#62; &#60;morph_side&#62; # &#60;morph_side&#62;

14a. &#60;morph_right&#62;       ::= &#60;morph_side&#62;
14b.                         &#60;boundary&#62;
14c.                         &#60;morph_side&#62; &#60;boundary&#62;
14d.                         &#60;morph_side&#62; # &#60;morph_side&#62;
14e.                         &#60;morph_side&#62; # &#60;morph_side&#62; &#60;boundary&#62;

15a. &#60;morph_side&#62;        ::= &#60;morph_item&#62;
15b.                         &#60;morph_item&#62; &#60;morph_side&#62;
15c.                         &#60;morph_item&#62; ... &#60;morph_side&#62;

16a. &#60;morph_item&#62;        ::= &#60;morph_piece&#62;
16b.                         ( &#60;morph_piece&#62; )

17a. &#60;morph_piece&#62;       ::= ~ &#60;morph_piece&#62;
17b.                         &#60;literal&#62;
17c.                         [ &#60;literal&#62; ]
17d.                         { &#60;literal&#62; }

18a. &#60;punct_constraint&#62;  ::= ./ &#60;envbar&#62; &#60;punct_right&#62;
18b.                         ./ &#60;punct_left&#62; &#60;envbar&#62;
18c.                         ./ &#60;punct_left&#62; &#60;envbar&#62; &#60;punct_right&#62;

19a. &#60;punct_left&#62;        ::= &#60;punct_side&#62;
19b.                         &#60;boundary&#62;
19c.                         &#60;boundary&#62; &#60;punct_side&#62;

20a. &#60;punct_right&#62;       ::= &#60;punct_side&#62;
20b.                         &#60;boundary&#62;
20c.                         &#60;punct_side&#62; &#60;boundary&#62;

21a. &#60;punct_side&#62;        ::= &#60;punct_item&#62;
21b.                         &#60;punct_item&#62; &#60;punct_side&#62;

22a. &#60;punct_item&#62;        ::= &#60;punct_piece&#62;
22b.                         ( &#60;punct_piece&#62; )

23a. &#60;punct_piece&#62;       ::= ~ &#60;punct_piece&#62;
23b.                         &#60;literal&#62;
23c.                         [ &#60;literal&#62; ]

24a. &#60;envbar&#62;            ::= _
24b.                         ~_

25a. &#60;boundary&#62;          ::= #
25b.                         ~#

26a. &#60;redup_pattern&#62;     ::= [ &#60;indexed_literal&#62; ]
26b.                         &#60;literal&#62; [ &#60;indexed_literal&#62; ]
26c.                         [ &#60;indexed_literal&#62; ] &#60;literal&#62;
26d.                         [ &#60;indexed_literal&#62; ] &#60;redup_pattern&#62;
26e.                         &#60;redup_pattern&#62; [ &#60;indexed_literal&#62; ]

27.  &#60;indexed_literal&#62;   ::= &#60;literal&#62; ^ &#60;number&#62;

28.  &#60;literal&#62;           ::= one or more contiguous characters

29.  &#60;comment_char&#62;      ::= character defined by <SAMP>`-c'</SAMP> command
							 line option, or <CODE>|</CODE> by default

30.  &#60;number&#62;            ::= one or more contiguous digits (0-9)

31a. &#60;full_redup&#62;        ::= '&#60;'...'&#62;'
31b.                         &#60;literal&#62; '&#60;'...'&#62;'
31c.                         '&#60;'...'&#62;' &#60;literal&#62;
31d.                         &#60;literal&#62; '&#60;'...'&#62;' &#60;literal&#62;

</PRE>


<H4>7.1.0.1  Comments on selected BNF rules</H4>
<DL COMPACT>

<DT>2.
<DD>
The (first) literal string is a surface form representation of the
morpheme (except for full reduplication; see 31 below).  The literal
string enclosed in braces is a unique allomorph identification string.
(The identification string is a feature added to support LinguaLinks.
It is not stored unless the <SAMP>`-b'</SAMP> command line option is used.

<DT>3.
<DD>
Each literal string is an allomorph property defined by a <CODE>\ap</CODE>
field in the analysis data file.

<DT>4.
<DD>
String, punctuation and morpheme constraints can be mixed together, but
it is recommended that you group the string constraints together, the
punctuation constraints together and the morpheme constraints together.

<DT>5.
<DD>
A comment begins with a specified character and ends with the end of
the line.

<DT>6d.
<DD>
A negative string constraint is just like a string
constraint with two exceptions:

<OL>
<LI>

the result is negated (that is, whatever the value of the
regular string constraint would be, it takes its opposite value
as the result); and
<LI>

multiple negative string constraints are logically
ANDed together (whereas multiple regular string constraints
are logically ORed together).
</OL>

Thus one can use negative string constraints to say that a
given allomorph may not occur in environment X and it also
may not occur in environment Y.

If an allomorph has both regular and negative string
constraints, both must be met.  That is, at least one of
the regular string constraints must be true and none of the
environments described within the negative string
constraints must be true.

<DT>7-8.
<DD>
Note that what can appear to the left of the environment bar is a
mirror image of what can appear to the right.

<DT>7de.
<DD>
<DT>8de.
<DD>
These should be avoided, and other means used to prune analyses based
on adjacent words.

<DT>9c.
<DD>
An ellipsis (<CODE>...</CODE>) indicates a possible break in contiguity.

<DT>10b.
<DD>
Something enclosed in parentheses is optional.

<DT>11a.
<DD>
A tilde (<CODE>~</CODE>) reverses the desirability of an element, causing the
constraint to fail if it is found rather than fail if it is not found.

<DT>11b.
<DD>
A literal is matched against the surface form of the word.

<DT>11c.
<DD>
A literal enclosed in square brackets must be the name of a string
class defined by a <CODE>\scl</CODE> field in the analysis data file or the
dictionary orthography change table file.

<DT>11d.
<DD>
The indexed literal enclosed in square brackets must match an indexed
literal given as part of the reduplication allomorph pattern.  (See 2c,
2d, and 26.)

<DT>13-14.
<DD>
Note that what can appear to the left of the environment bar is a
mirror image of what can appear to the right.

<DT>13de.
<DD>
<DT>14de.
<DD>
These should be avoided, and other means used to prune analyses based
on adjacent words.

<DT>15c.
<DD>
An ellipsis (<CODE>...</CODE>) indicates a possible break in contiguity.

<DT>16b.
<DD>
Something enclosed in parentheses is optional.

<DT>17a.
<DD>
A tilde (<CODE>~</CODE>) reverses the desirability of an element, causing the
constraint to fail if it is found rather than fail if it is not found.

<DT>17b.
<DD>
A literal is a morphname from one of the dictionary files.

<DT>17c.
<DD>
A literal enclosed in square brackets must be the name of a morpheme
class defined by a <CODE>\mcl</CODE> field in the analysis data file.

<DT>17d.
<DD>
A literal enclosed in curly braces must be one of the following
(checked in this order):

<OL>
<LI>

one of the keywords <CODE>root</CODE>, <CODE>prefix</CODE>, <CODE>infix</CODE>, or
<CODE>suffix</CODE>
<LI>

a property name defined by an <CODE>\ap</CODE> or <CODE>\mp</CODE> field in the
analyis data file
<LI>

a category name defined by a <CODE>\ca</CODE> field in the analysis data file
<LI>

a category class name defined by a <CODE>\ccl</CODE> field in the analysis
data file
<LI>

a morpheme class name defined by a <CODE>\mcl</CODE> field in the analysis
data file
</OL>

<DT>19-20.
<DD>
Note that what can appear to the left of the environment bar is a
mirror image of what can appear to the right.

<DT>22b.
<DD>
Something enclosed in parentheses is optional.

<DT>23a.
<DD>
A tilde (<CODE>~</CODE>) reverses the desirability of an element, causing the
constraint to fail if it is found rather than fail if it is not found.

<DT>23b.
<DD>
A literal is a punctuation character.
All such punctuation characters should not be listed in the set of word
formation characters.  See
section <A HREF="ample.html#SEC69">8  Text Input Control File</A>.

The punctuation characters can match punctuation characters either
before or after the current word.  Unlike string constraints,
punctuation constraints effectively ignore the position of the
conditioned allomorph within the word.  All that matters are any
punctuation characters immediately preceding or following the current
word.  Further note that neither ellipsis nor cross word boundary
conditions are allowed.

<DT>24.
<DD>
A tilde (<CODE>~</CODE>) attached to the environment bar inverts the sense of
the constraint as a whole.

<DT>25b.
<DD>
The boundary marker preceded by a tilde (<CODE>~#</CODE>) indicates that it
must not be a word boundary.

<DT>26-27.
<DD>
Although the BNF has spaces in it to improve readability, these two items
cannot have embedded spaces in the dictionary file.

<DT>26.
<DD>
The reduplication allomorph pattern contains references to string classes
and possibly literal strings.  The string class names are indexed to
indicate identical shared values, either in the string environment
constraint or in more than one location in the reduplication allomorph
pattern itself.  <EM>Note: this has been implemented only for AMPLE at this
point.</EM>

<DT>27.
<DD>
The literal (without the following index given by an ASCII caret
(<CODE>^</CODE>) and a number) must be the name of a string class defined by a
<CODE>\scl</CODE> field in the analysis data file or the dictionary orthography
change table file.

<DT>28.
<DD>
The special characters used by environment constraints can be included
in a literal only if they are immediately preceded by a backslash:

<PRE>

\+  \/  \#  \~  \[  \]  \(  \)  \{  \}  \.  \_  \\

</PRE>

<DT>31.
<DD>
The special sequence <CODE>&#60;...&#62;</CODE> indicates full reduplication.  This
may be preceded and/or followed by any literal (e.g. hyphen).  This
sequence is recognized as indicating full reduplication only when it
is either a prefix or a suffix.  When it is a prefix, then it will
match when a sequence of one or more characters repeats itself in the
rest of the word being considered.  When it is a suffix, it will match
when the entire string before it is repeated.  These matches are
modulo any literal elements before or after.  For example, if it is a
prefix, it can match the first <CODE>hati</CODE> in a form like
<CODE>kohatihati</CODE>.  If it is a suffix, it could match the second
<CODE>hati</CODE> in a form like <CODE>hatihatimo</CODE>.  <EM>Note: this has
been implemented only for AMPLE at this point.</EM>

</DL>

<P>
The allomorph field is used in all types of dictionary entries: prefix,
infix, suffix, and root.

</P>


<H2><A NAME="SEC57" HREF="ample.html#TOC57">7.2  Category (internal code C)</A></H2>

<P>
Each dictionary entry must contain a category field.  If multiple
category fields exist, then their contents are merged together.

</P>
<P>
For affix entries, this field must contain at least one category pair
for the morpheme, but may contain any number of category pairs
separated by spaces or tabs.  Each category pair consists of two
category names separated by a slash (<CODE>/</CODE>).  The category names
must have been defined by a <CODE>\ca</CODE> field in the analysis data
file.  The first category is the <EM>from category</EM>, that is, the
category of the unit to which this morpheme can be affixed.  The second
category is the <EM>to category</EM>, that is, the category of the result
after this morpheme has been affixed.

</P>
<P>
For root entries, this field contains one or more morphological
categories as defined by a <CODE>\ca</CODE> field in the analysis data file.
If multiple categories are listed, they should be separated by spaces
or tabs.

</P>
<P>
The category field is used in all types of dictionary entries: prefix,
infix, suffix, and root.

</P>


<H2><A NAME="SEC58" HREF="ample.html#TOC58">7.3  Elsewhere Allomorph (internal code E)</A></H2>

<P>
For compatibility with STAMP, the "elsewhere" field defines an
allomorph.  In AMPLE, this field also provides a default value for the
underlying form.

</P>
<P>
The syntax of the elsewhere allomorph field is the same as the syntax
of the normal allomorph field.
See section <A HREF="ample.html#SEC56">7.1  Allomorph (internal code A)</A>.

</P>
<P>
The elsewhere allomorph field is used in all types of dictionary
entries: prefix, infix, suffix, and root.

</P>


<H2><A NAME="SEC59" HREF="ample.html#TOC59">7.4  Feature Descriptor (internal code F)</A></H2>

<P>
The feature descriptor field is always optional.  It contains the names of
one or more features that are written verbatim to the <CODE>\fd</CODE> field
of the output analysis file.  It is not otherwise used by AMPLE.

</P>
<P>
If a dictionary entry contains multiple feature descriptor fields,
their contents are merged together.

</P>
<P>
The feature descriptor field is used in all types of dictionary entries:
prefix, infix, suffix, and root.

</P>


<H2><A NAME="SEC60" HREF="ample.html#TOC60">7.5  Root Gloss (internal code G)</A></H2>

<P>
The root gloss field contains an alternative morphname for writing to
the output analysis file.  It is enabled by the <SAMP>`-g'</SAMP> command line
option.  Without this command line option, it is totally ignored by
AMPLE.
See section <A HREF="ample.html#SEC62">7.7  Morphname (internal code M)</A>.
Only one root gloss field is allowed in each dictionary entry.  If an
entry has more than one root gloss field, then the first one is used
and the others trigger provoke an error message.

</P>
<P>
The root gloss field is used only in root dictionary entries.

</P>


<H2><A NAME="SEC61" HREF="ample.html#TOC61">7.6  Infix location (internal code L)</A></H2>

<P>
The infix location field serves to restrict where infixes may be found,
and must be included in each infix dictionary entry.  Subject to the
constraints imposed by the infix location field, AMPLE searches the
rest of the word for any occurrence of any allomorph string of the
infix.  This makes infixes rather expensive, computationally, so they
should be constrained as much as possible.

</P>

<PRE>

 1.  &#60;infix_location&#62; ::= &#60;types&#62; &#60;constraints&#62;

 2a. &#60;types&#62;          ::= &#60;type&#62;
 2b.                      &#60;type&#62; &#60;types&#62;

 3a. &#60;constraints&#62;    ::= &#60;environment&#62;
 3b.                      &#60;environment&#62; &#60;constraints&#62;

 4a. &#60;environment&#62;    ::= &#60;marker&#62; &#60;leftside&#62; &#60;envbar&#62; &#60;rightside&#62;
 4b.                      &#60;marker&#62; &#60;leftside&#62; &#60;envbar&#62;
 4c.                      &#60;marker&#62; &#60;envbar&#62; &#60;rightside&#62;

 5a. &#60;leftside&#62;       ::= &#60;side&#62;
 5b.                      &#60;boundary&#62;
 5c.                      &#60;boundary&#62; &#60;side&#62;

 6a. &#60;rightside&#62;      ::= &#60;side&#62;
 6b.                      &#60;boundary&#62;
 6c.                      &#60;side&#62; &#60;boundary&#62;

 7a. &#60;side&#62;           ::= &#60;item&#62;
 7b.                      &#60;item&#62; &#60;side&#62;
 7c.                      &#60;item&#62; ... &#60;side&#62;

 8a. &#60;item&#62;           ::= &#60;piece&#62;
 8b.                      ( &#60;piece&#62; )

 9a. &#60;piece&#62;          ::= ~ &#60;piece&#62;
 9b.                      &#60;literal&#62;
 9c.                      [ &#60;literal&#62; ]

10a. &#60;type&#62;           ::= prefix
10b.                      root
10c.                      suffix

11a. &#60;marker&#62;         ::= /
11b.                      +/

12a. &#60;envbar&#62;         ::= _
12b.                      ~_

13a. &#60;boundary&#62;       ::= #
13b.                      ~#

14.  &#60;literal&#62;        ::= one or more contiguous characters

</PRE>


<H4>7.6.0.1  Comments on selected BNF rules</H4>
<DL COMPACT>

<DT>2.
<DD>
The first part of the infix location field lists the type of morpheme
in which the infix may be hidden.  This consists of one or more of the
words <CODE>prefix</CODE>, <CODE>root</CODE>, or <CODE>suffix</CODE>.  If <CODE>prefix</CODE>
is given, then AMPLE looks for infixes after exhausting the possible
prefixes at a given point in the word, and resumes looking for more
prefixes after finding an infix.  Similarly, if <CODE>root</CODE> is given,
then AMPLE looks for infixes after running out of roots while parsing
the word, and if it finds an infix, it looks for more roots.  Suffixes
are treated the same way if <CODE>suffix</CODE> is given in the infix
location field.

<DT>5.
<DD>
A boundary marker (<CODE>#</CODE>) on the left side of the environment bar
refers to the place in the word which the parse has reached before
looking for infixes, not to the beginning of the word.

<DT>6.
<DD>
A boundary marker (<CODE>#</CODE>) on the right side of the environment bar
refers to the end of the word.

<DT>7c.
<DD>
An ellipsis (<CODE>...</CODE>) indicates a possible break in contiguity.

<DT>8b.
<DD>
Something enclosed in parentheses is optional.

<DT>9a.
<DD>
A tilde (<CODE>~</CODE>) reverses the desirability of an element, causing the
constraint to fail if it is found rather than fail if it is not found.

<DT>11.
<DD>
A <CODE>+/</CODE> is usually used for morpheme environment constraints, but may
used for infix location environment constraints as well.

<DT>12.
<DD>
A tilde attached to the environment bar (<CODE>~_</CODE>) inverts the sense of
the constraint as a whole.

<DT>13b.
<DD>
The boundary marker preceded by a tilde (<CODE>~#</CODE>) indicates that it
must not be a word boundary.

<DT>14.
<DD>
The special characters used by environment constraints can be included
in a literal only if they are immediately preceded by a backslash:

<PRE>

\+  \/  \#  \~  \[  \]  \(  \)  \{  \}  \.  \_  \\

</PRE>

</DL>

<P>
The infix location field is used only in infix dictionary entries.

</P>


<H2><A NAME="SEC62" HREF="ample.html#TOC62">7.7  Morphname (internal code M)</A></H2>

<P>
A morphname is an arbitrary name for a given morpheme.  Only the first
word (string of contiguous nonspace characters) following the morphname
field code is used as the morphname.  Morphnames must be less than 64
characters long.

</P>
<P>
A morphname serves two important functions:

<OL>
<LI>

It identifies a morpheme in morpheme environment constraints, morpheme
co-occurrence constraints, ad hoc pairs, and tests.

<LI>

It is the default morpheme identifier written to the output analysis
file.
See section <A HREF="ample.html#SEC60">7.5  Root Gloss (internal code G)</A>.
</OL>

<P>
Generally, a morphname is an identifier of a morpheme and does not
need to faithfully represent that morpheme's meaning or function.

</P>
<P>
If a dictionary entry has more than one morphname field, the morphname
from the first one is used; the others cause an error message.  The
morphname field is used in all types of dictionary entries: prefix,
infix, suffix, and root.  The usage differs somewhat between affix and
root dictionary entries, so these two types of morphnames are described
separately.

</P>

<H3>7.7.1  Affix morphnames</H3>

<P>
Every affix dictionary entry must have a morphname field.  Users are
strongly encouraged to observe the following suggestions in creating
affix morphnames:

</P>

<OL>
<LI>

Make each morphname unique.  If two morphemes have the same name, it is
impossible to refer unambiguously to them.  The same morphname should
not be used in different affix dictionaries (that is, in the prefix
dictionary and in the suffix dictionary).

<LI>

Keep morphnames short.  This reduces the size of analysis files and
makes text glossing more aesthetically pleasing.  For example, for a
verbal person marker, use simply <CODE>1</CODE> rather than <CODE>1P</CODE> unless
there is good reason to add the <CODE>P</CODE> for person or possessive.  For
a first person object marker, <CODE>1O</CODE> might serve as well as
<CODE>1OBJ</CODE>.

<LI>

Use only uppercase alphabetic characters and numbers for contrast with
root morphnames, which are generally made up of lowercase alphabetic
characters.  Be cautious in using hyphens, periods, underscores,
slashes, backslashes, or other nonalphanumeric characters.  The reason
to avoid these is that other programs which apply to the resulting
analysis may make use of nonalphanumerics in different ways.

<LI>

Design a syntax of names and stick to it for inflectional morphemes
which combine more than one semantic notion.  For example, for Latin
nominal inflections, which indicate gender, number, and case, the
syntax might be

<PRE>

MORPHNAME = GENDER CASE NUMBER

</PRE>

where <CODE>GENDER</CODE> is <CODE>M</CODE> for masculine, <CODE>F</CODE> for feminine
and <CODE>N</CODE> for neuter; <CODE>CASE</CODE> is <CODE>N</CODE> for nominative,
<CODE>A</CODE> for accusative, <CODE>G</CODE> for genitive, and so on; and <CODE>NUMBER</CODE>
is <CODE>S</CODE> for singular and <CODE>P</CODE> for plural.  The name for
masculine nominative singular would then be <CODE>MNS</CODE>.
</OL>


<H3>7.7.2  Root morphnames</H3>

<P>
Root morphnames are generally either glosses or etymologies.
Etymologies are frequently marked with a leading asterisk (<CODE>*</CODE>).
(This is used by STAMP to indicate regular sound changes.)

</P>
<P>
If the morphname field contains only an asterisk, the morphname becomes
an asterisk followed by whatever allomorph is matched.  If the
morphname field is omitted, or if it contains only a comment, AMPLE
puts whatever allomorph was matched in the text into the analysis.  If
the morpheme contains any alternate forms, it is wise to include an
explicit morphname field.

</P>


<H2><A NAME="SEC63" HREF="ample.html#TOC63">7.8  Order class (internal code O)</A></H2>

<P>
The order class of an affix is a number indicating its position
relative to other morphemes.  Prefixes should be assigned negative
numbers and suffixes should be assigned positive numbers.  Infixes
should be assigned order class values appropriate to where they can
appear in the word relative to the prefixes and suffixes.

</P>
<P>
If the order class field is omitted, then a default value of zero (0)
is assigned to the affix.  Order class values must be between -32767
and 32767.

</P>
<P>
Order classes are used only by tests in the analysis data file.  They
are needed only if appropriate tests are written to take advantage of
them.

</P>
<P>
The order class field is used only in affix type dictionary entries:
prefix, infix, and suffix.  Roots always have an implicit order class
of zero.

</P>
<P>
Beginning with AMPLE version 3.6.0, one may have up to two
order class numbers in an order class field (separated by
white space).  These represent the minimum and the maximum
values of the positions this affix can span.  The first
number is the minimum and the second is the maximum.
Therefore the first number should be less than or equal to
the second.  If only one number appears, both the minimum
and maximum values are set to that number.  If no number
appears, then both the minimum and maximum are set to zero.

</P>
<P>
Note that for STAMP, only the first order class number has
any use (it is used for transfer insertion rules whose
environments do not indicate a location where the morpheme
is to be inserted).

</P>


<H2><A NAME="SEC64" HREF="ample.html#TOC64">7.9  Morpheme property (internal code P)</A></H2>

<P>
This field contains one or more morpheme properties.  These properties
must have been defined by a <CODE>\mp</CODE> field in the analysis data file.
A morpheme property is inherited by all allomorphs of the morpheme.

</P>
<P>
The morpheme property field is optional, and may be repeated.  If
multiple properties apply to a morpheme, they may be given all in a
single field or each in a separate field.

</P>
<P>
Morpheme properties typically indicate a characteristic of the morpheme
which conditions the occurrence of allomorphs of an adjacent morpheme.
Morpheme properties are used in tests defined in the analysis data file
and in morpheme environment constraints.

</P>
<P>
The morpheme property field is used in all types of dictionary entries:
prefix, infix, suffix, and root.

</P>


<H2><A NAME="SEC65" HREF="ample.html#TOC65">7.10  Morpheme type (internal code T)</A></H2>

<P>
In a unified dictionary, the type of an entry is determined by the
first letter following the morpheme type field code: <CODE>p</CODE> or
<CODE>P</CODE> for prefixes, <CODE>i</CODE> or <CODE>I</CODE> for infixes, <CODE>n</CODE> or
<CODE>N</CODE> for interfixes, <CODE>s</CODE> or <CODE>S</CODE> for suffixes, and
<CODE>r</CODE> or <CODE>R</CODE> for roots.  The morpheme type field is not needed
for root entries because the entry type defaults to root.

</P>
<P>
The morpheme type field is used only in unified dictionary files,
since the morpheme type is otherwise implicit.  The only exception to
this is for interfixes.

</P>
<P>
Special notes for interfixes:

</P>
<P>
An "interfix" is an affix that can also appear between roots.  That
is, it is a prefix, infix, or suffix that can occur in the usual
position for prefixes/infixes/suffixes, but which can also occur
between roots.  As such, one uses a regular prefix/infix/suffix entry
and adds the morpheme type of <CODE>n</CODE> or <CODE>N</CODE>.  For unified
dictionaries, the interfix code must follow the prefix/infix/suffix
code.  Separate it by a space.

</P>
<P>
If one is using the non-unified dictionary approach, one can add a
morpheme type field to an affix entry to indicate that it is also an
interfix.

</P>


<H2><A NAME="SEC66" HREF="ample.html#TOC66">7.11  Underlying Form (internal code U)</A></H2>

<P>
The underlying form field contains information for writing to <CODE>\u</CODE>
fields in the output analysis file.  If a mapping from a dictionary
field code to internal code <CODE>U</CODE> is not defined in the dictionary
code table file, then this field effectively does not exist.

</P>
<P>
Only one underlying form field is allowed in each dictionary entry.  If an
entry has more than one underlying form field, then the first one is used
and the others trigger provoke an error message.

</P>
<P>
If a particular record in a dictionary file does not have an underlying
form field, but does use an "elsewhere" field
(see section <A HREF="ample.html#SEC58">7.3  Elsewhere Allomorph (internal code E)</A>),
then AMPLE uses the elsewhere entry for the underlying form.  If an
entry has neither an underlying form field nor an elsewhere field,
AMPLE assumes that the underlying form is null and will output a zero
(0) for the underlying form.

</P>
<P>
The underlying form field is used in all types of dictionary entries:
prefix, infix, suffix, and root.

</P>


<H2><A NAME="SEC67" HREF="ample.html#TOC67">7.12  Morpheme Co-occurrence Constraint (internal code Z)</A></H2>

<P>
See section <A HREF="ample.html#SEC26">4.1.19  Morpheme Co-occurrence Constraint: \mcc</A>,
for a description of morpheme co-occurrence constraint fields in the
analysis data file.  These fields can also occur in dictionary entries.
This is appropriate only if the constraint is about that morpheme.

</P>
<P>
One difference between morpheme co-occurrence constraints in the
analysis data file and those found in dictionary entries is that the
field code in the dictionary file is not necessarily <CODE>\mcc</CODE>.  The
primary difference is that morpheme co-occurrence constraints found in
a dictionary entry are stored with the dictionary entry in memory, and
those found in the analysis data file are stored together in one long
list.  If a constraint applies to more than one morpheme, it must be
put in the analysis data file to work properly.

</P>
<P>
The morpheme co-occurrence constraint field is optional.  If more than
one constraint applies to the morpheme, as many of these fields as
desired may be included.

</P>
<P>
The morpheme co-occurrence constraint field is used in all types of
dictionary entries: prefix, infix, suffix, and root.

</P>


<H2><A NAME="SEC68" HREF="ample.html#TOC68">7.13  Do not load (internal code !)</A></H2>

<P>
When a "do not load" field is included in a record, AMPLE
ignores the record altogether.  This makes it possible to include records
in the dictionary for linguistic purposes, while not needlessly taking up
memory space if the dictionary is used for some other purpose.

</P>
<P>
The "do not load" field is used in all types of dictionary entries:
prefix, infix, suffix, and root.

</P>



<H1><A NAME="SEC69" HREF="ample.html#TOC69">8  Text Input Control File</A></H1>
<P>
<A NAME="IDX73"></A>

</P>
<P>
This chapter describes the expected characteristics of an input text
file, and the options offered for describing these characteristics by a
<EM>text input control file</EM>.<A NAME="DOCF1" HREF="ample.html#FOOT1">(1)</A>

</P>

<UL>
<LI><A HREF="ample.html#SEC70">Input text files</A>: Expected characteristics of text files
<LI><A HREF="ample.html#SEC71">\ambig</A>: Ambiguity or failure marker character
<LI><A HREF="ample.html#SEC72">\barchar</A>: Bar code format marker character
<LI><A HREF="ample.html#SEC73">\barcodes</A>: Bar code format code characters
<LI><A HREF="ample.html#SEC74">\ch</A>: Text orthography change
<LI><A HREF="ample.html#SEC81">\dsc</A>: Decomposition separation character
<LI><A HREF="ample.html#SEC82">\excl</A>: Fields to exclude
<LI><A HREF="ample.html#SEC83">\format</A>: Primary  format marker character
<LI><A HREF="ample.html#SEC84">\incl</A>: Fields to include
<LI><A HREF="ample.html#SEC85">\luwfc</A>: Lowercase/uppercase word formation character pairs
<LI><A HREF="ample.html#SEC86">\luwfcs</A>: Multibyte lower/uppercase word formation character pairs
<LI><A HREF="ample.html#SEC87">\maxdecap</A>: Maximum number of alternative decapitalizations
<LI><A HREF="ample.html#SEC88">\nocap</A>: Prevent any decapitalization
<LI><A HREF="ample.html#SEC89">\noincap</A>: Prevent decapitalization of individual characters
<LI><A HREF="ample.html#SEC90">\scl</A>: String class
<LI><A HREF="ample.html#SEC91">\wfc</A>: Caseless word formation characters
<LI><A HREF="ample.html#SEC92">\wfcs</A>: Multibyte caseless word formation characters
<LI><A HREF="ample.html#SEC93">Sample text input control file</A>
</UL>



<H2><A NAME="SEC70" HREF="ample.html#TOC70">8.1  Input text files</A></H2>

<P>
Text input control files define a simple model of input text files.
They are plain text files with two types of embedded format markers.

<OL>

<LI>

A primary format marker consists of one or more contiguous characters
beginning with a special flag character.  The default character
initiating format markers is the backslash (<CODE>\</CODE>).  Thus, each of
the following would be recognized as a format marker and would not be
processed by the program:

<PRE>

\
\p
\sp
\begin{enumerate}
\very-long.and;muddled/format*marker,to#be$sure

</PRE>

Note that format markers cannot have a space or tab embedded in them;
the first space or tab encountered terminates the format marker.

One final note: the format character under discussion here applies only
to the input text files which are to be processed.  It has absolutely
nothing to do with the use of backslash (<CODE>\</CODE>) to
flag field codes in control files such as the text input control file.

<LI>

A secondary type of marker consists of a flag character followed by a
single character from a list of known values.  This secondary flag
character must be different than the primary flag character.  Its
default value is the vertical bar (<CODE>|</CODE>), causing this type of
format marker to be frequently called a bar code.  The following could
be valid (secondary) format markers and would not be processed by
the program:

<PRE>

|b
|i
|r

</PRE>

</OL>

<P>
Consider the following two lines of input text:

<PRE>

\bgoodbye\r
|bgoodbye|r

</PRE>

<P>
Using the default definitions of format markers, the first line is
considered to be a single format marker, and provides nothing which the
program should try to parse.  The second line, however contains two
format markers, <CODE>|b</CODE> and <CODE>|r</CODE>, and the word <CODE>goodbye</CODE>
which would be processed by the program.

</P>
<P>
The primary format markers serve to divide the text into fields.  See
section <A HREF="ample.html#SEC82">8.7  Fields to Exclude: \excl</A>
and
section <A HREF="ample.html#SEC84">8.9  Fields to Include: \incl</A>
for details on how these fields are used.  There is no requirement that
the format markers be at the beginning of a line as with the field codes
used in AMPLE control files.

</P>


<H2><A NAME="SEC71" HREF="ample.html#TOC71">8.2  Ambiguity Marker Character: \ambig</A></H2>
<P>
<A NAME="IDX74"></A>

</P>
<P>
The <CODE>\ambig</CODE> field defines the character used to mark ambiguities
and failures in the analysis output file.  For example, to use the hash
mark (<CODE>#</CODE>), the text input control file would include:

<PRE>

\ambig  #

</PRE>

<P>
This would cause an ambiguous analysis to be output as follows:

<PRE>

\a #3#&#60; N0 kay &#62;#&#60; V1 ka &#62; IMP#&#60; V1 ka &#62; INF#

</PRE>

<P>
It makes sense to use the <CODE>\ambig</CODE> field only once in the text
input control file.  If multiple <CODE>\ambig</CODE> fields do occur in the
file, the value given in the first one is used.  If the text input
control file does not have an <CODE>\ambig</CODE> field, the percent sign
(<CODE>%</CODE>) is used.

</P>
<P>
The first printing character following the <CODE>\ambig</CODE> field code is
used as the ambiguity marker.  The character currently being used to mark
comments cannot be assigned to also mark ambiguities in the output file.
Thus, the vertical bar (<CODE>|</CODE>) cannot normally be used as the
ambiguity marker.  Logically, this field should be in the
analysis data
file rather than the text <EM>input</EM> control file since it affects
output instead of input.  Nevertheless, compatibility demands that it
stays this way.

</P>


<H2><A NAME="SEC72" HREF="ample.html#TOC72">8.3  Bar code format marker character: \barchar</A></H2>
<P>
<A NAME="IDX75"></A>

</P>
<P>
The <CODE>\barchar</CODE> defines the character that begins a two-character
secondary format marker.  For example, if this type of format marker
begins with the dollar sign (<CODE>$</CODE>), the following would be placed
in the text input control file:

<PRE>

\barchar  $

</PRE>

<P>
An empty <CODE>\barchar</CODE> field in the text input control file prevents
any bar code format markers from being recognized.  Thus, the following
field effectively turns off special treatment of this style of format
marking (assuming the <CODE>|</CODE> is marking comments):

<PRE>

\barchar       | no bar character

</PRE>

<P>
It makes sense to use the <CODE>\barchar</CODE> field only once in the text
input control file.  If multiple <CODE>\barchar</CODE> fields do occur in the
file, the value given in the first one is used.

</P>
<P>
The first printing character following the <CODE>\barchar</CODE> field code
is used as the bar code format marker.  The character currently being
used to mark comments cannot be assigned to also flag format markers in
input text files.
Thus, the default value (<CODE>|</CODE>) cannot normally be explicitly
defined (since <CODE>\barchar |</CODE> is treated as <CODE>\barchar</CODE>
followed only by a comment), so it must be taken as given.

</P>


<H2><A NAME="SEC73" HREF="ample.html#TOC73">8.4  Bar Code Format Code Characters: \barcodes</A></H2>
<P>
<A NAME="IDX76"></A>

</P>
<P>
In conjunction with the special format marking character discussed in
the previous section, the <CODE>\barcodes</CODE> field defines the individual
characters used with in bar codes.  These characters may be separated by
spaces or lumped together.  Thus, the following two fields are
equivalent:

<PRE>

\barcodes    abcdefg         | lumped together
\barcodes    a b c d e f g   | separated

</PRE>

<P>
If provided more than one <CODE>\barcodes</CODE> field in the text input
control file, the combination of all characters defined in all such
fields is used.  No check is made for repeated characters: the previous
example would be accepted without complaint despite the redundancy of
the second line.

</P>
<P>
The default value for the bar codes is <CODE>bdefhijmrsuvyz</CODE>.
Therefore, if the text input control file contains neither a
<CODE>\barchar</CODE> nor a <CODE>\barcodes</CODE> field, the following bar codes
are considered to be formatting information by AMPLE: <CODE>|b</CODE>,
<CODE>|d</CODE>, <CODE>|e</CODE>, <CODE>|f</CODE>, <CODE>|h</CODE>, <CODE>|i</CODE>, <CODE>|j</CODE>,
<CODE>|m</CODE>, <CODE>|r</CODE>, <CODE>|s</CODE>, <CODE>|u</CODE>, <CODE>|v</CODE>, <CODE>|y</CODE>, and
<CODE>|z</CODE>.  These are exactly the codes recognized by the SIL
Manuscripter program that was in vogue when the concept of a text input
control file was originally developed.

</P>


<H2><A NAME="SEC74" HREF="ample.html#TOC74">8.5  Text Orthography Change: \ch</A></H2>
<P>
<A NAME="IDX77"></A>

</P>
<P>
An orthography change is defined by the <CODE>\ch</CODE> field code followed
by the actual orthography change.  Any number of orthography changes
may be defined in the text input control file.  The output of each
change serves as the input the following change.  That is, each change
is applied as many times as necessary to an input word before the next
change from the text input control file is applied.

</P>

<UL>
<LI><A HREF="ample.html#SEC75">Basic changes</A>
<LI><A HREF="ample.html#SEC76">Environmentally constrained changes</A>
<LI><A HREF="ample.html#SEC77">Using text orthography changes</A>
<LI><A HREF="ample.html#SEC78">Where orthography changes apply</A>
<LI><A HREF="ample.html#SEC79">A sample orthography change table</A>
<LI><A HREF="ample.html#SEC80">Syntax of Orthography Changes</A>
</UL>



<H3><A NAME="SEC75" HREF="ample.html#TOC75">8.5.1  Basic changes</A></H3>

<P>
To substitute one string of characters for another, these must be made
known to the program in a change.  (The technical term for this sort of
change is a production, but we will simply call them changes.)  In the
simplest case, a change is given in three parts: (1) the field code
<CODE>\ch</CODE> must be given at the extreme left margin to indicate that
this line contains a change; (2) the match string is the string for
which the program must search; and (3) the substitution string is the
replacement for the match string, wherever it is found.

</P>
<P>
The beginning and end of the match and substitution strings must be
marked.  The first printing character following <CODE>\ch</CODE> (with at
least one space or tab between) is used as the delimiter for that line.
The match string is taken as whatever lies between the first and second
occurrences of the delimiter on the line and the substitution string is
whatever lies between the third and fourth occurrences.  For example,
the following lines indicate the change of hi to bye, where the
delimiters are the double quote mark (<CODE>"</CODE>), the single quote mark
(<CODE>'</CODE>), the period (<CODE>.</CODE>), and the at sign (<CODE>@</CODE>).

<PRE>
\ch "hi" "bye"
\ch 'hi' 'bye'
\ch .hi. .bye.
\ch @hi@ @bye@
</PRE>

<P>
Throughout this document, we use the double quote mark as the delimiter
unless there is some reason to do otherwise.

</P>
<P>
Change tables follow these conventions:

<OL>
<LI>

Any characters (other than the delimiter) may be placed between the
match and substitution strings.  This allows various notations to
symbolize the change.  For example, the following are equivalent:

<PRE>
\ch "thou" "you"
\ch "thou" to "you"
\ch "thou" &#62; "you"
\ch "thou" --&#62; "you"
\ch "thou" becomes "you"
</PRE>

<LI>

Comments included after the substitution string are initiated by a
vertical bar (<CODE>|</CODE>), or whatever is indicated as the comment character
by means of the <CODE>-c</CODE> option when AMPLE is started.
The following lines illustrate the use of comments:

<PRE>
\ch "qeki" "qiki" | for cases like wawqeki
\ch "thou" "you"  | for modern English
</PRE>

<LI>

A change can be ignored temporarily by turning it into a comment field.
This is done either by placing an unrecognized field code in front of
the normal <CODE>\ch</CODE>, or by placing the comment character
(<CODE>|</CODE>) in front of it.  For example, only the
first of the following three lines would effect a change:

<PRE>
\ch "nb" "mp"
\no \ch "np" "np"
|\ch "mb" "nb"
</PRE>

</OL>

<P>
The changes in the text input control file are applied as an ordered
set of changes.  The first change is applied to the entire word by
searching from left to right for any matching strings and, upon finding
any, replacing them with the substitution string.  After the first
change has been applied to the entire word, then the next change is
applied, and so on.  Thus, each change applies to the result of all
prior changes.  When all the changes have been applied, the resulting
word is returned.  For example, suppose we have the following changes:

<PRE>
\ch "aib" &#62; "ayb"
\ch "yb"  &#62; "yp"
</PRE>

<P>
Consider the effect these have on the word <I>paiba</I>.  The first
changes <I>i</I> to <I>y</I>, yielding <I>payba</I>; the second changes
<I>b</I> to <I>p</I>, to yield <I>paypa</I>.  (This would be better than the
single change of <I>aib</I> to <I>ayp</I> if there were sources of <I>yb</I>
other than the output of the first rule.)

</P>
<P>
The way in which change tables are applied allows certain
tricks.  For example, suppose that for Quechua, we wish to change
<I>hw</I> to <I>f</I>, so that <I>hwista</I> becomes <I>fista</I> and <I>hwis</I>
becomes <I>fis</I>.  However, we do not wish to change the sequence
<I>shw</I> or <I>chw</I> to <I>sf</I> or <I>cf</I> (respectively).  This could
be done by the following sequence of changes. (Note, <CODE>@</CODE> and
<CODE>$</CODE> are not otherwise used in the orthography.)

<PRE>
\ch "shw" &#62; "@"     | (1)
\ch "chw" &#62; "$"      | (2)
\ch "hw"  &#62; "f"      | (3)
\ch "@"   &#62; "shw"   | (4)
\ch "$"   &#62; "chw"    | (5)
</PRE>

<P>
Lines (1) and (2) protect the <I>sh</I> and <I>ch</I> by changing them to
distinguished symbols.  This clears the way for the change of <I>hw</I> to
<I>f</I> in (3).  Then lines (4) and (5) restore <CODE>@</CODE> and <CODE>$</CODE> to
<I>sh</I> and <I>ch</I>, respectively. (An alternative, simpler way to do
this is discussed in the next section.)

</P>


<H3><A NAME="SEC76" HREF="ample.html#TOC76">8.5.2  Environmentally constrained changes</A></H3>

<P>
It is possible to impose string environment constraints (SECs) on
changes in the orthography change tables.  The syntax of SECs is
described in detail in section .

</P>
<P>
For example, suppose we wish to change the mid vowels (<I>e</I> and
<I>o</I>) to high vowels (<I>i</I> and <I>u</I> respectively) immediately
before and after <I>q</I>.  This could be done with the following
changes:

<PRE>
\ch "o" "u"  / _ q  / q _
\ch "e" "i"  / _ q  / q _
</PRE>

<P>
This is not entirely a hypothetical example; some Quechua practical
orthographies write the mid vowels <I>e</I> and <I>o</I>.  However, in the
environment of <I>/q/</I> these could be considered phonemically high
vowels <I>/i/</I> and <I>/u/</I>.  Changing the mid vowels to high upon
loading texts has the advantage that--for cases like <I>upun</I> "he
drinks" and <I>upoq</I> "the one who drinks"--the root needs to be
represented internally only as <I>upu</I> "drink".  But note, because
of Spanish loans, it is not possible to change all cases of <I>e</I> to
<I>i</I> and <I>o</I> to <I>u</I>.  The changes must be conditioned.

</P>
<P>
In reality, the regressive vowel-lowering effect of <I>/q/</I> can pass
over various intervening consonants, including <I>/y/</I>, <I>/w/</I>,
<I>/l/</I>, <I>/ll/</I>, <I>/r/</I>, <I>/m/</I>, <I>/n/</I>, and <I>/n/</I>.  For
example, <I>/ullq/</I> becomes <I>ollq</I>, <I>/irq/</I> becomes <I>erq</I>,
and so on.  Rather than list each of these cases as a separate constraint, it
is convenient to define a class (which we label <CODE>+resonant</CODE>) and
use this class to simplify the SEC.  Note that the string class
must be defined (with the <CODE>\scl</CODE> field code) before it is used in a
constraint.

<PRE>
\scl +resonant y w l ll r m n n~
\ch "o" "u" / q _ / _ ([+resonant]) q
\ch "e" "i" / q _ / _ ([+resonant]) q
</PRE>

<P>
This says that the mid vowels become high vowels after <I>/q/</I> and
before <I>/q/</I>, possibly with an intervening <I>/y/</I>, <I>/w/</I>,
<I>/l/</I>, <I>/ll/</I>, <I>/r/</I>, <I>/m/</I>, <I>/n/</I>, or <I>/n/</I>.

</P>
<P>
Consider the problem posed for Quechua in the previous section, that of
changing <I>hw</I> to <I>f</I>.  An alternative is to condition the change
so that it does not apply adjacent to a member of the string class
<CODE>Affric</CODE> which contains <I>s</I> and <I>c</I>.

<PRE>
\scl Affric c s
\ch "hw" "f" / [Affric] ~_
</PRE>

<P>
It is sometimes convenient to make certain changes only at word
boundaries, that is, to change a sequence of characters only if they
initiate or terminate the word.  This conditioning is easily expressed,
as shown in the following examples.

<PRE>
\ch "this" "that"           | anywhere in the word
\ch "this" "that"  / # _    | only if word initial
\ch "this" "that"  /   _ #  | only if word final
\ch "this" "that"  / # _ #  | only if entire word
</PRE>

<P>

</P>


<H3><A NAME="SEC77" HREF="ample.html#TOC77">8.5.3  Using text orthography changes</A></H3>

<P>
The purpose of orthography change is to convert text from an external
orthography to an internal representation more suitable for
morphological analysis.  In many cases this is unnecessary, the
practical orthography being completely adequate as the internal
representation.  In other cases, the practical orthography is an
inconvenience that can be circumvented by converting to a more phonemic
representation.

</P>
<P>
Let us take a simple example from Latin.  In the Latin orthography, the
nominative singular masculine of the word "king" is <I>rex</I>.
However, phonemically, this is really <I>/reks/</I>; <I>/rek/</I> is the
root meaning king and the <I>/s/</I> is an inflectional suffix.  If
the program is to recover such an analysis, then it is necessary to
convert the <I>x</I> of the external, practical orthography into <I>ks</I>
internally.  This can be done by including the following orthography
change in the text input control file:

<PRE>
\ch  "x"  "ks"
</PRE>

<P>
In this, <I>x</I> is the match string and <I>ks</I> is the substitution
string, as discussed in section .  Whenever <I>x</I> is
found, <I>ks</I> is substituted for it.

</P>
<P>
Let us consider next an example from Huallaga Quechua.  The practical
orthography currently represents long vowels by doubling the vowel.
For example, what is written as <I>kaa</I> is <I>/ka:/</I> "I am", where
the length (represented by a colon) is the morpheme meaning "first
person subject".  Other examples, such as <I>upoo</I> <I>/upu:/</I> "I
drink" and <I>upichee</I> <I>/upi-chi-:/</I> "I extinguish", motivate us
to convert all long vowels into a vowel followed by a colon.  The
following changes do this:

<PRE>
\ch  "aa"  "a:"
\ch  "ee"  "i:"
\ch  "ii"  "i:"
\ch  "oo"  "u:"
\ch  "uu"  "u:"
</PRE>

<P>
Note that the long high vowels (<I>i</I> and <I>u</I>) have become mid vowels
(<I>e</I> and <I>o</I> respectively); consequently, the vowel in the
substitution string is not necessarily the same as that of the match
string.  What is the utility of these changes?  In the lexicon, the
morphemes can be represented in their phonemic forms; they do not have to
be represented in all their orthographic variants.  For example, the
first person subject morpheme can be represented simply as a colon
(<I>-:</I>), rather than as <I>-a</I> in cases like <I>kaa</I>, as <I>-o</I> in
cases like <I>qoo</I>, and as <I>-e</I> as in cases like <I>upichee</I>.
Further, the verb "drink" can be represented as <I>upu</I> and the
causative suffix (in <I>upichee</I>) can be represented as <I>-chi</I>; these
are the forms these morphemes have in other (nonlowered) environments.
As the next example, let us suppose that we are analyzing Spanish, and
that we wish to work internally with <I>k</I> rather than <I>c</I> (before
<I>a</I>, <I>o</I>, and <I>u</I>) and <I>qu</I> (before <I>i</I> and <I>e</I>). (Of
course, this is probably not the only change we would want to make.)
Consider the following changes:

<PRE>
\ch  "ca"  "ka"
\ch  "co"  "ko"
\ch  "cu"  "ku"
\ch  "qu"  "k"
</PRE>

<P>
The first three handle <I>c</I> and the last handles <I>qu</I>.  By virtue of
including the vowel after <I>c</I>, we avoid changing <I>ch</I> to <I>kh</I>.
There are other ways to achieve the same effect.  One way exploits the
fact that each change is applied to the output of all previous changes.
Thus, we could first protect <I>ch</I> by changing it to some distinguished
character (say <CODE>@</CODE>), then changing <I>c</I> to <I>k</I>, and then
restoring <CODE>@</CODE> to <I>ch</I>:

<PRE>
\ch  "ch"  "@"
\ch  "c"  "k"
\ch  "@"  "ch"
\ch  "qu"  "k"
</PRE>

<P>
Another approach conditions the change by the adjacent characters.  The
changes could be rewritten as

<PRE>
\ch  "c"  "k"  / _a  / _o  / _u  | only before a, o, or u
\ch  "qu"  "k"                   | in all cases
</PRE>

<P>
The first change says, "change <I>c</I> to <I>k</I> when followed by <I>a</I>,
<I>o</I>, or <I>u</I>."  (This would, for example, change <I>como</I> to
<I>komo</I>, but would not affect <I>chal</I>.)  The syntax of such conditions
is exactly that used in string environment constraints; see
section .

</P>


<H3><A NAME="SEC78" HREF="ample.html#TOC78">8.5.4  Where orthography changes apply</A></H3>

<P>
Input orthography changes are made when the text being processed may be
written in a practical orthography.  Rather than requiring that it be
converted as a prerequisite to running the program, it is possible to
have the program convert the orthography as it loads and before it
processes each word.

</P>
<P>
The changes loaded from the text input control file are applied after all the
text is converted to lower case (and the information about upper and
lower case, along with information about format marking, punctuation
and white space, has been put to one side.)  Consequently, the match
strings of these orthography changes should be all lower case; any
change that has an uppercase character in the match string will never
apply.

</P>


<H3><A NAME="SEC79" HREF="ample.html#TOC79">8.5.5  A sample orthography change table</A></H3>

<P>
We include here the entire orthography input change table for Caquinte
(a language of Peru).  There are basically four changes that need to be
made: (1) nasals, which in the practical orthography reflect their
assimilation to the point of articulation of a following noncontinuant,
must be changed into an unspecified nasal, represented by <I>N</I>; (2)
<I>c</I> and <I>qu</I> are changed to <I>k</I>; (3) <I>j</I> is changed to <I>h</I>;
and (4) <I>gu</I> is changed to <I>g</I> before <I>i</I> and <I>e</I>.

</P>

<PRE>
\ch  "mp"  "Np"     | for unspecified nasals
\ch  "nch" "Nch"
\ch  "nc"  "Nk"
\ch  "nqu" "Nk"
\ch  "nt"  "Nt"

\ch  "ch"  "@"     | to protect ch
\ch  "c"   "k"      | other c's to k
\ch  "@"   "ch"    | to restore ch
\ch  "qu"  "k"

\ch  "j"   "h"

\ch  "gue" "ge"
\ch  "gui" "gi"
</PRE>

<P>
This change table can be simplified by the judicious use of string
environment constraints:

</P>

<PRE>
\ch  "m"  &#62;  "N"  / _p
\ch  "n"  &#62;  "N"  / _c  / _t  / _qu

\ch  "c"  &#62;  "k"  / _~h
\ch  "qu" &#62;  "k"

\ch  "j"  &#62;  "h"

\ch  "gu" &#62;  "g"  / _e  /_i
</PRE>

<P>
As suggested by the preceding examples, the text orthography change
table is composed of all the <CODE>\ch</CODE> fields found in the
text input control file.  These may appear anywhere in the file relative to
the other fields.  It is recommended that all the orthography changes
be placed together in one section of the text input control file, rather than
being mixed in with other fields.

</P>


<H3><A NAME="SEC80" HREF="ample.html#TOC80">8.5.6  Syntax of Orthography Changes</A></H3>

<P>
This section presents a grammatical description of the syntax of
orthography changes in BNF notation.
These changes are found either in
the dictionary orthography change table file or in the text input control file
(see section <A HREF="ample.html#SEC53">6.1  Dictionary Orthography Change: \ch</A>).

</P>

<PRE>

 1a. &#60;orthochange&#62;  ::= &#60;basic_change&#62;
 1b.                    &#60;basic_change&#62; &#60;constraints&#62;

 2a. &#60;basic_change&#62; ::= &#60;quote&#62;&#60;quote&#62; &#60;quote&#62;&#60;string&#62;&#60;quote&#62;
 2b.                    &#60;quote&#62;&#60;string&#62;&#60;quote&#62; &#60;quote&#62;&#60;quote&#62;
 2c.                    &#60;quote&#62;&#60;string&#62;&#60;quote&#62; &#60;quote&#62;&#60;string&#62;&#60;quote&#62;

 3.  &#60;quote&#62;        ::= any printing character not used in either
						the ``from'' string or the ``to'' string

 4.  &#60;string&#62;       ::= one or more characters other than the quote
						character used by this orthography change

 5a. &#60;constraints&#62;  ::= &#60;change_envir&#62;
 5b.                    &#60;change_envir&#62; &#60;constraints&#62;

 6a. &#60;change_envir&#62; ::= &#60;marker&#62; &#60;leftside&#62; &#60;envbar&#62; &#60;rightside&#62;
 6b.                    &#60;marker&#62; &#60;leftside&#62; &#60;envbar&#62;
 6c.                    &#60;marker&#62; &#60;envbar&#62; &#60;rightside&#62;

 7a. &#60;leftside&#62;   ::= &#60;side&#62;
 7b.                  &#60;boundary&#62;
 7c.                  &#60;boundary&#62; &#60;side&#62;

 8a. &#60;rightside&#62;  ::= &#60;side&#62;
 8b.                  &#60;boundary&#62;
 8c.                  &#60;side&#62; &#60;boundary&#62;

 9a. &#60;side&#62;       ::= &#60;item&#62;
 9b.                  &#60;item&#62; &#60;side&#62;
 9c.                  &#60;item&#62; ... &#60;side&#62;

10a. &#60;item&#62;       ::= &#60;piece&#62;
10b.                  ( &#60;piece&#62; )

11a. &#60;piece&#62;      ::= ~ &#60;piece&#62;
11b.                  &#60;literal&#62;
11c.                  [ &#60;literal&#62; ]

12.  &#60;marker&#62;     ::= /
					  +/

13.  &#60;envbar&#62;     ::= _
					  ~_

14.  &#60;boundary&#62;   ::= #
					  ~#

15.  &#60;literal&#62;    ::= one or more contiguous characters

</PRE>


<H4>8.5.6.1  Comments on selected BNF rules</H4>
<DL COMPACT>

<DT>2.
<DD>
The same <CODE>&#60;quote&#62;</CODE> character must be used at both the beginning
and the end of both the "from" string and the "to" string.

<DT>3.
<DD>
The double quote (<CODE>"</CODE>) and single quote (<CODE>'</CODE>) characters are
most often used.

<DT>7-8.
<DD>
Note that what can appear to the left of the environment bar is a
mirror image of what can appear to the right.

<DT>9c.
<DD>
An ellipsis (<CODE>...</CODE>) indicates a possible break in contiguity.

<DT>10b.
<DD>
Something enclosed in parentheses is optional.

<DT>11a.
<DD>
A tilde (<CODE>~</CODE>) reverses the desirability of an element, causing the
constraint to fail if it is found rather than fail if it is not found.

<DT>11c.
<DD>
A literal enclosed in square brackets must be the name of a string
class defined by a <CODE>\scl</CODE> field in the analysis data file, or
earlier in the dictionary orthography change file.

<DT>12.
<DD>
A <CODE>+/</CODE> is usually used for morpheme environment constraints, but may
used for change environment constraints in <CODE>\ch</CODE> fields in the
dictionary orthography change table file.

<DT>13.
<DD>
A tilde attached to the environment bar (<CODE>~_</CODE>) inverts the sense of
the constraint as a whole.

<DT>14b.
<DD>
The boundary marker preceded by a tilde (<CODE>~#</CODE>) indicates that it
must not be a word boundary.

<DT>15.
<DD>
The special characters used by environment constraints can be included
in a literal only if they are immediately preceded by a backslash:

<PRE>

\+  \/  \#  \~  \[  \]  \(  \)  \.  \_  \\

</PRE>

</DL>



<H2><A NAME="SEC81" HREF="ample.html#TOC81">8.6  Decomposition Separation Character: \dsc</A></H2>
<P>
<A NAME="IDX78"></A>

</P>
<P>
The <CODE>\dsc</CODE> field defines the character used to separate the
morphemes in the decomposition field of the output analysis file.  For
example, to use the equal sign (<CODE>=</CODE>), the text input control file
would include:

<PRE>

\dsc  =

</PRE>

<P>
This would cause a decomposition field to be output as follows:

<PRE>

\d %3%kay%ka=y%ka=y%

</PRE>

<P>
It makes sense to use the <CODE>\dsc</CODE> field only once in the text input
control file.  If multiple <CODE>\dsc</CODE> fields do occur in the file, the
value given in the first one is used.  If the text input control file
does not have an <CODE>\dsc</CODE> field, a dash (<CODE>-</CODE>) is used.

</P>
<P>
The first printing character following the <CODE>\dsc</CODE> field code is used
as the morpheme decomposition separator character.  The same character
cannot be used both for separating decomposed morphemes in the analysis
output file and for marking comments in the input control files.  Thus,
one normally cannot use the vertical bar (<CODE>|</CODE>) as the decomposition
separation character.

</P>
<P>
Logically, this field should be in the
analysis data
file rather than the text <EM>input</EM> control file since it affects
output instead of input.  Nevertheless, compatibility demands that it
stays this way.

</P>


<H2><A NAME="SEC82" HREF="ample.html#TOC82">8.7  Fields to Exclude: \excl</A></H2>
<P>
<A NAME="IDX79"></A>

</P>
<P>
The <CODE>\excl</CODE> field excludes one or more fields from processing.
For example, to have the program ignore everything in <CODE>\co</CODE> and
<CODE>\id</CODE> fields, the following line is included in the text input
control file:

<PRE>

\excl  \co  \id      | ignore these fields

</PRE>

<P>
If more than one <CODE>\excl</CODE> field is found in the text input control
file, the contents of each field is added to the overall list of text
fields to exclude.  This list is initially empty, and stays empty
unless the text input control file contains an <CODE>\excl</CODE> field.
Thus, no text fields are excluded from processing by default.

</P>
<P>
If the text input control file contains <CODE>\excl</CODE> fields, then only
those text fields are not processed.  Every word in every text field
not mentioned explicitly in an <CODE>\excl</CODE> field will be processed.

</P>
<P>
Note that every text field in the input text files is processed
unless the text input control file contains either an <CODE>\excl</CODE> or
an <CODE>\incl</CODE> field.  One or the other is used to limit processing,
but never both.

</P>


<H2><A NAME="SEC83" HREF="ample.html#TOC83">8.8  Primary format marker character: \format</A></H2>
<P>
<A NAME="IDX80"></A>

</P>
<P>
The <CODE>\format</CODE> field designates a single character to flag the
beginning of a primary format marker.  For example, if the format
markers in the text files begin with the at sign (<CODE>@</CODE>), the
following would be placed in the text input control file:

<PRE>

\format  @

</PRE>

<P>
This would be used, for example, if the text contained format markers
like the following:

<PRE>

@
@p
@sp
@make(Article)
@very-long.and;muddled/format*marker,to#be$sure

</PRE>

<P>
If a <CODE>\format</CODE> field occurs in the text input control file without
a following character to serve for flagging format markers, then the
program will not recognize any format markers and will try to parse
everything other than punctuation characters.

</P>
<P>
It makes sense to use the <CODE>\format</CODE> field only once in the text
input control file.  If multiple <CODE>\format</CODE> fields do occur in the
file, the value given in the first one is used.

</P>
<P>
The first printing character following the <CODE>\format</CODE> field code is
used to flag format markers.  The character currently used to mark
comments cannot be assigned to also flag format markers.  Thus, the
vertical bar (<CODE>|</CODE>) cannot normally be used to flag format markers.

</P>


<H2><A NAME="SEC84" HREF="ample.html#TOC84">8.9  Fields to Include: \incl</A></H2>
<P>
<A NAME="IDX81"></A>

</P>
<P>
The <CODE>\incl</CODE> field explicitly includes one or more text fields for
processing, excluding all other fields.  For instance, to process
everything in <CODE>\txt</CODE> and <CODE>\qt</CODE> fields, but ignore everything
else, the following line is placed in the text input control file:

<PRE>

\incl  \txt  \qt      | process these fields

</PRE>

<P>
If more than one <CODE>\incl</CODE> field is found in the text input control
file, the contents of each field is added to the overall list of text
fields to process.  This list is initially empty, and stays empty
unless the text input control file contains an <CODE>\incl</CODE> field.

</P>
<P>
If the text input control file contains <CODE>\incl</CODE> fields, then only
those text fields are processed.  Every word in every text field not
mentioned explicitly in an <CODE>\incl</CODE> field will not be processed.

</P>
<P>
Note that every text field in the input text files is processed unless
the text input control file contains either an <CODE>\excl</CODE> or an
<CODE>\incl</CODE> field.  One or the other is used to limit processing, but
never both.

</P>


<H2><A NAME="SEC85" HREF="ample.html#TOC85">8.10  Lowercase/uppercase character pairs: \luwfc</A></H2>
<P>
<A NAME="IDX82"></A>

</P>
<P>
To break a text into words, the program needs to know which characters
are used to form words.  It always assumes that the letters <CODE>A</CODE>
through <CODE>Z</CODE> and <CODE>a</CODE> through <CODE>z</CODE> are used as word
formation characters.  If the orthography of the language the user is
working in uses any other characters that have lowercase and uppercase
forms, these must given in a <CODE>\luwfc</CODE> field in the text input
control file.

</P>
<P>
The <CODE>\luwfc</CODE> field defines pairs of characters; the first member
of each pair is a lowercase character and the second is the
corresponding uppercase character.  Several such pairs may be placed in
the field or they may be placed on separate fields.  Whitespace may be
interspersed freely.  For example, the following three examples are
equivalent:

<PRE>

\luwfc   

</PRE>

<P>
or

<PRE>

\luwfc        | e with acute accent
\luwfc        | enyee

</PRE>

<P>
or

<PRE>

\luwfc      

</PRE>

<P>
Note that comments can be used as well (just as they can in any
AMPLE control file).  This means that the comment character
cannot be designated as a word formation character.  If the orthography
includes the vertical bar (<CODE>|</CODE>), then a different comment character
must be defined with the <SAMP>`-c'</SAMP> command line option when
AMPLE is initiated; see
section <A HREF="ample.html#SEC3">2.1  AMPLE Command Options</A>.

</P>
<P>
The <CODE>\luwfc</CODE> field can be entered anywhere in the text input control file,
although a natural place would be before the <CODE>\wfc</CODE> (word formation
character) field.

</P>
<P>
Any standard alphabetic character (that is <CODE>a</CODE> through <CODE>z</CODE> or
<CODE>A</CODE> through <CODE>Z</CODE>) in the <CODE>\luwfc</CODE> field will override the
standard lower- upper case pairing.  For example, the following will
treat <CODE>X</CODE> as the upper case equivalent of <CODE>z</CODE>:

<PRE>

\luwfc z X

</PRE>

<P>
Note that <CODE>Z</CODE> will still have <CODE>z</CODE> as its lower-case
equivalent in this case.

</P>
<P>
The <CODE>\luwfc</CODE> field is allowed to map multiple lower case characters to
the same upper case character, and vice versa.  This is needed for
languages that do not mark tone on upper case letters.

</P>


<H2><A NAME="SEC86" HREF="ample.html#TOC86">8.11  Multibyte lowercase/uppercase character pairs: \luwfcs</A></H2>
<P>
<A NAME="IDX83"></A>

</P>
<P>
The <CODE>\luwfcs</CODE> field extends the character pair definitions of the
<CODE>\luwfc</CODE> field to multibyte character sequences.  Like the
<CODE>\luwfc</CODE> field, the <CODE>\luwfcs</CODE> field defines pairs of
characters; the first member of each pair is a multibyte lowercase
character and the second is the corresponding multibyte uppercase
character.  Several such pairs may be placed in the field or they may be
placed on separate fields.  Whitespace separates the members of each
pair, and the pairs from each other.  For example, the following three
examples are equivalent:

<PRE>

\luwfcs  e' E` n~ N^  C&#38;

</PRE>

<P>
or

<PRE>

\luwfcs  e' E`      | e with acute accent
\luwfcs  n~ N^      | enyee
\luwfcs    C&#38;      | c cedilla

</PRE>

<P>
or

<PRE>

\luwfcs  e' E`
		 n~ N^
		   C&#38;

</PRE>

<P>
Note that comments can be used as well (just as they can in any
AMPLE control file).  This means that the comment character
cannot be designated as a word formation character.  If the orthography
includes the vertical bar (<CODE>|</CODE>), then a different comment character
must be defined with the <SAMP>`-c'</SAMP> command line option when
AMPLE is initiated; see
above.
section <A HREF="ample.html#SEC3">2.1  AMPLE Command Options</A>.

</P>
<P>
Also note that there is no requirement that the lowercase form be the
same length (number of bytes) as the uppercase form.  The examples shown
above are only one or two bytes (character codes) in length, but there is
no limit placed on the length of a multibyte character.

</P>
<P>
The <CODE>\luwfcs</CODE> field can be entered anywhere in the text input
control file.  <CODE>\luwfcs</CODE> fields may be mixed with <CODE>\luwfc</CODE>
fields in the same file.

</P>
<P>
Any standard alphabetic character (that is <CODE>a</CODE> through <CODE>z</CODE> or
<CODE>A</CODE> through <CODE>Z</CODE>) in the <CODE>\luwfcs</CODE> field will override the
standard lower- upper case pairing.  For example, the following will
treat <CODE>X</CODE> as the upper case equivalent of <CODE>z</CODE>:

<PRE>

\luwfcs z X

</PRE>

<P>
Note that <CODE>Z</CODE> will still have <CODE>z</CODE> as its lowercase
equivalent in this case.

</P>
<P>
The <CODE>\luwfcs</CODE> field is allowed to map multiple multibyte lowercase
characters to the same multibyte uppercase character, and vice versa.
This may be useful in some situations, but it introduces an element of
ambiguity into the decapitalization and recapitalization processes.  If
ambiguous capitalization is supported, then for the previous example,
<CODE>z</CODE> will have both <CODE>X</CODE> and <CODE>Z</CODE> as uppercase equivalents,
and <CODE>X</CODE> will have both <CODE>x</CODE> and <CODE>Z</CODE> as lowercase
equivalents.

</P>


<H2><A NAME="SEC87" HREF="ample.html#TOC87">8.12  Maximum number of decapitalizations: \maxdecap</A></H2>
<P>
<A NAME="IDX84"></A>

</P>
<P>
The <CODE>\maxdecap</CODE> field sets the maximum number of different
decapitalizations allowed.  Since the <CODE>\luwfc</CODE> field can map
several lowercase characters onto a single uppercase character, a word
with uppercase characters can (logically) generate a number of
alternatives when decapitalized.  This is especially true of words that
are entirely capitalized to begin with.  The default limit is 100.

</P>


<H2><A NAME="SEC88" HREF="ample.html#TOC88">8.13  Prevent Any Decapitalization: \nocap</A></H2>
<P>
<A NAME="IDX85"></A>

</P>
<P>
The usual behavior is to normalize input words to lowercase.  The
program remembers the case of the word as one of four possibilities:

<OL>
<LI>

all uppercase
<LI>

all lowercase
<LI>

only the first letter uppercase
<LI>

mixed uppercase and lowercase
</OL>

<P>
However, not all orthographies use the concept of capitalization.  To
help deal with these, the field code <CODE>\nocap</CODE> disables all case
normalization if it appears anywhere in the text input control file.

</P>


<H2><A NAME="SEC89" HREF="ample.html#TOC89">8.14  Prevent Decapitalization of Individual Characters: \noincap</A></H2>
<P>
<A NAME="IDX86"></A>

</P>
<P>
The handling of mixed uppercase and lowercase is limited in utility,
and sometimes causes more problems than it solves.  For this reason,
the <CODE>\noincap</CODE> field code turns off mixed case decapitalization.
The program would still decapitalize words that are entirely
capitalized and words that begin with a capital letter.

</P>


<H2><A NAME="SEC90" HREF="ample.html#TOC90">8.15  String class: \scl</A></H2>
<P>
<A NAME="IDX87"></A>

</P>
<P>
A string class is defined by the <CODE>\scl</CODE> field code followed by the
class name, which is followed in turn by one or more contiguous
character strings or (previously defined) string class names.  A string
class name used as part of the class definition must be enclosed in
square brackets.

</P>
<P>
The class name must be a single, contiguous sequence of printing
characters.  Characters and words which have special meanings in tests
should not be used.  The actual character strings have no such
restrictions.  The individual members of the class are separated by
spaces, tabs, or newlines.

</P>
<P>
Each <CODE>\scl</CODE> field defines a single string class.  Any number of
<CODE>\scl</CODE> fields may appear in the file.  The only restriction is
that a string class must be defined before it is used.

</P>
<P>
String classes must be defined before being used.  For example, the first
two lines of the simpler Caquinte example above could be given as follows:

<PRE>
\scl  -bilabial  c t qu
\ch  "m"  &#62;  "N"  / _ p
\ch  "n"  &#62;  "N"  / _ [-bilabial]
</PRE>

<P>
The string class definition could be in another control file: string
classes defined elsewhere can be used in the text input control file as
well.

</P>
<P>
If no <CODE>\scl</CODE> fields appear in the text input control file, then
AMPLE does not allow any string classes in text input orthography
change environment constraints unless they are defined in the
analysis data file or the dictionary orthography changes
file.

</P>


<H2><A NAME="SEC91" HREF="ample.html#TOC91">8.16  Caseless word formation characters: \wfc</A></H2>
<P>
<A NAME="IDX88"></A>

</P>
<P>
To break a text into words, the program needs to know which characters
are used to form words.  It always assumes that the letters <CODE>A</CODE>
through <CODE>Z</CODE> and <CODE>a</CODE> through <CODE>z</CODE> are used as word
formation characters.  If the orthography of the language the user is
working in uses any characters that do not have different lowercase and
uppercase forms, these must given in a <CODE>\wfc</CODE> field in the text
input control file.

</P>
<P>
For example, English uses an apostrophe character (<CODE>'</CODE>) that could
be considered a word formation character.  This information is provided
by the following example:

<PRE>

\wfc  '    | needed for words like don't

</PRE>

<P>
Notice that the characters in the <CODE>\wfc</CODE> field may be separated by
spaces, although it is not required to do so.  If more than one
<CODE>\wfc</CODE> field occurs in the text input control file, the program
uses the combination of all characters defined in all such fields as
word formation characters.

</P>
<P>
The comment character cannot be designated as a word formation character.
If the orthography includes the vertical bar (<CODE>|</CODE>), then a different
comment character must be defined with the <SAMP>`-c'</SAMP> command line option
when AMPLE is initiated; see
above.
section <A HREF="ample.html#SEC3">2.1  AMPLE Command Options</A>.

</P>


<H2><A NAME="SEC92" HREF="ample.html#TOC92">8.17  Multibyte caseless word formation characters: \wfcs</A></H2>
<P>
<A NAME="IDX89"></A>

</P>
<P>
The <CODE>\wfcs</CODE> field allows multibyte characters to be defined as
"caseless" word formation characters.  It has the same relationship to
<CODE>\wfc</CODE> that <CODE>\luwfcs</CODE> has to <CODE>\luwfc</CODE>.  The multibyte word
formation characters are separated from each other by whitespace.

</P>


<H2><A NAME="SEC93" HREF="ample.html#TOC93">8.18  A sample text input control file</A></H2>

<P>
The following is the complete text input control file for Huallaga
Quechua (a language of Peru):

<PRE>
\id HGTEXT.CTL - for Huallaga Quechua, 25-May-88

\co         WORD FORMATION CHARACTERS

\wfc  ' ~

\co         FIELDS TO EXCLUDE

\excl  \id            | identification fields

\co         ORTHOGRAPHY CHANGES

\ch  "aa" &#62; "a:"      | for long vowels
\ch  "ee" &#62; "i:"
\ch  "ii" &#62; "i:"
\ch  "oo" &#62; "u:"
\ch  "uu" &#62; "u:"
\ch  "qeki" &#62; "qiki"  | for cases like wawqeki
\ch  "~n" &#62; "n~"      | for typos
| for Spanish loans like hwista
\scl sib s c          | sibilants
\ch  "hw" &#62; "f"  / ~[sib]_
</PRE>



<H1><A NAME="SEC94" HREF="ample.html#TOC94">9  Output Analysis Files</A></H1>
<P>
<A NAME="IDX90"></A>
<A NAME="IDX91"></A>

</P>
<P>
Analysis files are <EM>record oriented standard format files</EM>.
This means that the files are divided into records, each representing a
single word in the original input text file, and records are divided
into fields.  An analysis file contains at least one record, and may
contain a large number of records.  Each record contains one or more
fields.  Each field occupies at least one line, and is marked by a
<EM>field code</EM> at the beginning of the line.  A field code begins
with a backslash character (<CODE>\</CODE>), and contains 1 or more letters
in addition.

</P>

<UL>
<LI><A HREF="ample.html#SEC95">Analysis file fields</A>: Description of each type of field
<LI><A HREF="ample.html#SEC106">Ambiguous analyses</A>: How ambiguous analyses are marked
<LI><A HREF="ample.html#SEC107">Analysis failures</A>: How analysis failures are marked
</UL>



<H2><A NAME="SEC95" HREF="ample.html#TOC95">9.1  Analysis file fields</A></H2>

<P>
This section describes the possible fields in an analysis file.  The
only field that is guaranteed to exist is the analysis (<CODE>\a</CODE>)
field.  All other fields are either data dependent or optional.

</P>

<UL>
<LI><A HREF="ample.html#SEC96">\a</A>: Analysis
<LI><A HREF="ample.html#SEC97">\d</A>: Decomposition (surface forms)
<LI><A HREF="ample.html#SEC98">\cat</A>: Category (possible word, morpheme)
<LI><A HREF="ample.html#SEC99">\p</A>: Properties
<LI><A HREF="ample.html#SEC100">\fd</A>: Feature Descriptors
<LI><A HREF="ample.html#SEC101">\u</A>: Underlying forms (decomposition)
<LI><A HREF="ample.html#SEC102">\w</A>: Word (before decapitalization and orthography changes)
<LI><A HREF="ample.html#SEC103">\f</A>: Formatting (junk before the word)
<LI><A HREF="ample.html#SEC104">\c</A>: Capitalization flag
<LI><A HREF="ample.html#SEC105">\n</A>: Nonalphabetic (junk after the word)
</UL>



<H3><A NAME="SEC96" HREF="ample.html#TOC96">9.1.1  Analysis field: \a</A></H3>
<P>
<A NAME="IDX92"></A>

</P>
<P>
The analysis field (<CODE>\a</CODE>) starts each record of an analysis file.
It has the following form:

<PRE>

\a PFX IFX PFX &#60; CAT root CAT root &#62; SFX IFX SFX

</PRE>

<P>
where <CODE>PFX</CODE> is a prefix morphname, <CODE>IFX</CODE> is an infix
morphname, <CODE>SFX</CODE> is a suffix morphname, <CODE>CAT</CODE> is a root
category, and <CODE>root</CODE> is a root gloss or etymology.  In the
simplest case, an analysis field would look like this:

<PRE>

\a &#60; CAT root &#62;

</PRE>

<P>
where <CODE>CAT</CODE> is a root category and <CODE>root</CODE> is a root gloss or
etymology.

</P>
<P>
The <CODE>\rd</CODE> field in the analysis data file can replace the
characters used to bracket the root category and gloss/etymology; see
section <A HREF="ample.html#SEC36">4.1.29  Root Delimiter Characters: \rd</A>.
The dictionary field code mapped to <CODE>M</CODE> in the dictionary codes
file controls the affix and default root morphnames; see
section <A HREF="ample.html#SEC62">7.7  Morphname (internal code M)</A>.
If the <SAMP>`-g'</SAMP> command line option is given, the output analysis file
contains glosses from the root dictionary marked by the field code
mapped to <CODE>G</CODE> in the dictionary codes file; see
section <A HREF="ample.html#SEC3">2.1  AMPLE Command Options</A> and section <A HREF="ample.html#SEC60">7.5  Root Gloss (internal code G)</A>.

</P>


<H3><A NAME="SEC97" HREF="ample.html#TOC97">9.1.2  Decomposition field: \d</A></H3>
<P>
<A NAME="IDX93"></A>

</P>
<P>
The morpheme decomposition field (<CODE>\d</CODE>) follows the analysis
field.  It has the following form:

<PRE>

\d anti-dis-establish-ment-arian-ism-s

</PRE>

<P>
where the hyphens separate the individual morphemes in the surface form
of the word.

</P>
<P>
The <CODE>\dsc</CODE> field in the text input control file can replace the
hyphen with another character for separating the morphemes; see
section <A HREF="ample.html#SEC81">8.6  Decomposition Separation Character: \dsc</A>.

</P>
<P>
The morpheme decomposition field is optional.  It is enabled either by
a <SAMP>`-w d'</SAMP> command line option
(see section <A HREF="ample.html#SEC3">2.1  AMPLE Command Options</A>),
or by an interactive query.

</P>


<H3><A NAME="SEC98" HREF="ample.html#TOC98">9.1.3  Category field: \cat</A></H3>
<P>
<A NAME="IDX94"></A>

</P>
<P>
The category field (<CODE>\cat</CODE>) provides rudimentary category
information.  This may be useful for sentence level parsing.  It has
the following form:

<PRE>

\cat CAT

</PRE>

<P>
where <CODE>CAT</CODE> is the word category.
A more complex example
is

<PRE>

\cat C0 C1/C0=C2=C2/C1=C1/C1

</PRE>

<P>
where <CODE>C0</CODE> is the proposed word category, <CODE>C1/C0</CODE> is a prefix
category pair, <CODE>C2</CODE> is a root category, and <CODE>C2/C1</CODE> and
<CODE>C1/C1</CODE> are suffix category pairs.  The equal signs (<CODE>=</CODE>)
serve to separate the category information of the individual morphemes.

</P>
<P>
The <CODE>\cat</CODE> field of the analysis data file controls whether the
category field is written to the output analysis file; see
section <A HREF="ample.html#SEC98">9.1.3  Category field: \cat</A>.

</P>

<P>
If there are multiple analyses, there will be multiple categories in
the output, separated by ambiguity markers.

</P>


<H3><A NAME="SEC99" HREF="ample.html#TOC99">9.1.4  Properties field: \p</A></H3>
<P>
<A NAME="IDX95"></A>

</P>
<P>
The properties field (<CODE>\p</CODE>) contains the names of any allomorph or
morpheme properties found in the analysis of the word.  It has the
form:

<PRE>

\p prop1=prop2

</PRE>

<P>
where <CODE>prop1</CODE> is a property of the first morpheme and <CODE>prop2</CODE> is a
property of the second. A more complex example is:

<PRE>

\p ==prop1 prop2=prop3=

</PRE>

<P>
where there are five morphemes in the analysis: the first, second,
and last morphemes do not have any associated properties; the third
has two; and the fourth has one. The equal signs (=) serve to
separate the property information of the individual morphemes. Note
that morphemes may have more than one property, with the names
separated by spaces, or no properties at all.

</P>
<P>
As a final example, if an analysis has four morphemes and none of them
have properties, then it will look like this:

<PRE>

\p ===
</PRE>

<P>

</P>
<P>
By default, the properties field is written to the output analysis
file.  The <SAMP>`-w 0'</SAMP> command option, or any <SAMP>`-w'</SAMP> option that
does not include <SAMP>`p'</SAMP> in its argument disables the properties field.

</P>


<H3><A NAME="SEC100" HREF="ample.html#TOC100">9.1.5  Feature Descriptors field: \fd</A></H3>
<P>
<A NAME="IDX96"></A>

</P>
<P>
The feature descriptor field (<CODE>\fd</CODE>) contains the feature names
associated with each morpheme in the analysis.  It has the
form:

<PRE>

\fd feat1=feat2

</PRE>

<P>
where <CODE>feat1</CODE> is a feature descriptor of the first morpheme and
<CODE>feat2</CODE> is a feature descriptor of the second. A more complex
example is:

<PRE>

\fd =feat1==feat2 feat3=

</PRE>

<P>
where there are five morphemes in the analysis: the first, third, and
last morphemes do not have any associated feature descriptors; the second has
one; and the fourth has two. The equal signs (=) serve to separate the
feature descriptor information of the individual morphemes. Note that morphemes
may have more than one feature descriptor, with the names separated by
spaces, or no feature descriptors at all.

</P>
<P>
As a final example, if an analysis has four morphemes and none of them
have feature descriptors, then it will look like this:

<PRE>

\fd ===
</PRE>

<P>
The dictionary field code mapped to <CODE>F</CODE> in the dictionary code
table file controls whether feature descriptors are written to the
output analysis file; if this mapping is not defined, then the
<CODE>\fd</CODE> field is not written.
See section <A HREF="ample.html#SEC59">7.4  Feature Descriptor (internal code F)</A>.

</P>
<P>
If there are multiple analyses, there will be multiple feature sets in
the output, separated by ambiguity markers.

</P>


<H3><A NAME="SEC101" HREF="ample.html#TOC101">9.1.6  Underlying form field: \u</A></H3>
<P>
<A NAME="IDX97"></A>

</P>
<P>
The underlying form field (<CODE>\u</CODE>) is similar to the decomposition
field except that it shows underlying forms instead of surface forms.
It looks like this:

<PRE>

\u a-para-a-i-ri-me

</PRE>

<P>
where the hyphens separate the individual morphemes.

</P>
<P>
The <CODE>\dsc</CODE> field in the text input control file can replace the
hyphen with another character for separating the morphemes; see
section <A HREF="ample.html#SEC81">8.6  Decomposition Separation Character: \dsc</A>.

</P>
<P>
The dictionary field code mapped to <CODE>U</CODE> in the dictionary code
table file controls whether underlying forms are written to the output
analysis file; if this mapping is not defined, then the <CODE>\u</CODE> field
is not written.
See section <A HREF="ample.html#SEC66">7.11  Underlying Form (internal code U)</A>.

</P>


<H3><A NAME="SEC102" HREF="ample.html#TOC102">9.1.7  Word field: \w</A></H3>
<P>
<A NAME="IDX98"></A>

</P>
<P>
The original word field (<CODE>\w</CODE>) contains the original input word as
it looks before decapitalization and orthography changes.  It looks
like this:

<PRE>

\w The

</PRE>

<P>
Note that this is a gratuitous change from earlier versions of AMPLE
and KTEXT, which wrote the decapitalized form.

</P>
<P>
The original word field is optional.  It is enabled either by
a <SAMP>`-w w'</SAMP> command line option
(see section <A HREF="ample.html#SEC3">2.1  AMPLE Command Options</A>),
or by an interactive query.

</P>


<H3><A NAME="SEC103" HREF="ample.html#TOC103">9.1.8  Formatting field: \f</A></H3>
<P>
<A NAME="IDX99"></A>

</P>
<P>
The format information field (<CODE>\f</CODE>) records any formatting codes
or punctuation that appeared in the input text file before the word.
It looks like this:

<PRE>

\f \\id MAT 5 HGMT05.SFM, 14-feb-84 D. Weber, Huallaga Quechua\n
		\\c 5\n\n
		\\s

</PRE>

<P>
where backslashes (<CODE>\</CODE>) in the input text are doubled, newlines
are represented by <CODE>\n</CODE>, and additional lines in the field start
with a tab character.

</P>
<P>
The format information field is written to the output analysis file
whenever it is needed, that is, whenever formatting codes or
punctuation exist before words.

</P>


<H3><A NAME="SEC104" HREF="ample.html#TOC104">9.1.9  Capitalization field: \c</A></H3>
<P>
<A NAME="IDX100"></A>

</P>
<P>
The capitalization field (<CODE>\c</CODE>) records any capitalization of the
input word.  It looks like this:

<PRE>

\c 1

</PRE>

<P>
where the number following the field code has one of these values:
<DL COMPACT>

<DT><CODE>1</CODE>
<DD>
the first (or only) letter of the word is capitalized

<DT><CODE>2</CODE>
<DD>
all letters of the word are capitalized

<DT><CODE>4-32767</CODE>
<DD>
some letters of the word are capitalized and some are not
</DL>
<P>
Note that the third form is of limited utility, but still exists
because of words like the author's last name.

</P>
<P>
The capitalization field is written to the output analysis file
whenever any of the letters in the word are
capitalized; see
section <A HREF="ample.html#SEC88">8.13  Prevent Any Decapitalization: \nocap</A> and section <A HREF="ample.html#SEC89">8.14  Prevent Decapitalization of Individual Characters: \noincap</A>.

</P>


<H3><A NAME="SEC105" HREF="ample.html#TOC105">9.1.10  Nonalphabetic field: \n</A></H3>
<P>
<A NAME="IDX101"></A>

</P>
<P>
The nonalphabetic field (<CODE>\n</CODE>) records any trailing punctuation,
bar code
(see section <A HREF="ample.html#SEC73">8.4  Bar Code Format Code Characters: \barcodes</A>),
or whitespace characters.  It looks like this:

<PRE>

\n |r.\n

</PRE>

<P>
where newlines are represented by <CODE>\n</CODE>.  The nonalphabetic field
ends with the last whitespace character immediately following the word.

</P>
<P>
The nonalphabetic field is written to the output analysis file whenever
the word is followed by anything other than a single space character.
This includes the case when a word ends a file with nothing following
it.

</P>


<H2><A NAME="SEC106" HREF="ample.html#TOC106">9.2  Ambiguous analyses</A></H2>

<P>
The previous section assumed that only one analysis is produced for
each word.  This is not always possible since words in isolation are
frequently ambiguous.  Multiple analyses are handled by writing each
analysis field in parallel, with the number of analyses at the
beginning of each output field.  For example,

<PRE>

\a %2%&#60; A0 imaika &#62; CNJT AUG%&#60; A0 imaika &#62; ADVS%
\d %2%imaika-Npa-ni%imaika-Npani%
\cat %2%A0 A0=A0/A0=A0/A0%A0 A0=A0/A0%
\p %2%==%=%
\fd %2%==%=%
\u %2%imaika-Npa-ni%imaika-Npani%
\w Imaicampani
\f \\v124
\c 1
\n \n

</PRE>

<P>
where the percent sign (<CODE>%</CODE>) separates the different analyses in
each field.  Note that only those fields which contain analysis
information are marked for ambiguity.  The other fields (<CODE>\w</CODE>,
<CODE>\f</CODE>, <CODE>\c</CODE>, and <CODE>\n</CODE>) are the same regardless of the
number of analyses.

</P>
<P>
The <CODE>\ambig</CODE> field in the text input control file can replace the
percent sign with another character for separating the analyses; see
section <A HREF="ample.html#SEC71">8.2  Ambiguity Marker Character: \ambig</A>.

</P>


<H2><A NAME="SEC107" HREF="ample.html#TOC107">9.3  Analysis failures</A></H2>

<P>
The previous sections assumed that words are successfully analyzed.
This does not always happen.  Analysis failures are marked the same way
as multiple analyses, but with zero (<CODE>0</CODE>) for the ambiguity count.
For example,

<PRE>

\a %0%ta%
\d %0%ta%
\cat %0%%
\p %0%%
\fd %0%%
\u %0%%
\w TA
\f \\v 12 |b
\c 2
\n |r\n

</PRE>

<P>
Note that only the <CODE>\a</CODE> and <CODE>\d</CODE> fields contain any
information, and those both have the original word as a place
holder.  The other analysis fields (<CODE>\cat</CODE>, <CODE>\p</CODE>, <CODE>\fd</CODE>,
and <CODE>\u</CODE>) are marked for failure, but otherwise left empty.

</P>
<P>
The <CODE>\ambig</CODE> field in the text input control file can replace the
percent sign with another character for marking analysis failures and
ambiguities; see
section <A HREF="ample.html#SEC71">8.2  Ambiguity Marker Character: \ambig</A>.

</P>


<H1><A NAME="SEC108" HREF="ample.html#TOC108">Bibliography</A></H1>


<OL>

<LI>

Weber, David J., H. Andrew Black, and Stephen R. McConnel. 1988.
<CITE>AMPLE: a tool for exploring morphology</CITE>.
Occasional Publications in Academic Computing No. 12.
Dallas, TX: Summer Institute of Linguistics.

<LI>

Weber, David J., H. Andrew Black, Stephen R. McConnel, and Alan Buseman. 1990.
<CITE>STAMP: a tool for dialect adaptation</CITE>.
Occasional Publications in Academic Computing No. 15.
Dallas, TX: Summer Institute of Linguistics.

</OL>



<H1><A NAME="SEC109" HREF="ample.html#TOC109">10  Index</A></H1>

<P>
Jump to:
<A HREF="#cindex_-">-</A>
-
<A HREF="#cindex_\">\</A>
-
<A HREF="#cindex_a">a</A>
-
<A HREF="#cindex_d">d</A>
-
<A HREF="#cindex_o">o</A>
-
<A HREF="#cindex_s">s</A>
-
<A HREF="#cindex_t">t</A>
<P>
<H2><A NAME="cindex_-">-</A></H2>
<DIR>
<LI><A HREF="ample.html#IDX22">-/</A>
<LI><A HREF="ample.html#IDX1">-a</A>
<LI><A HREF="ample.html#IDX2">-b</A>
<LI><A HREF="ample.html#IDX3">-c character</A>
<LI><A HREF="ample.html#IDX4">-d number</A>
<LI><A HREF="ample.html#IDX5">-e filename</A>
<LI><A HREF="ample.html#IDX6">-f filename</A>
<LI><A HREF="ample.html#IDX7">-g</A>
<LI><A HREF="ample.html#IDX8">-i filename</A>
<LI><A HREF="ample.html#IDX9">-j</A>
<LI><A HREF="ample.html#IDX10">-m</A>
<LI><A HREF="ample.html#IDX11">-n number</A>
<LI><A HREF="ample.html#IDX12">-o filename</A>
<LI><A HREF="ample.html#IDX14">-p</A>
<LI><A HREF="ample.html#IDX13">-q</A>
<LI><A HREF="ample.html#IDX15">-r</A>
<LI><A HREF="ample.html#IDX16">-s filename</A>
<LI><A HREF="ample.html#IDX17">-t</A>
<LI><A HREF="ample.html#IDX18">-u</A>
<LI><A HREF="ample.html#IDX21">-v</A>
<LI><A HREF="ample.html#IDX19">-w fields</A>
<LI><A HREF="ample.html#IDX20">-x fields</A>
<LI><A HREF="ample.html#IDX24">-Z address,count</A>
<LI><A HREF="ample.html#IDX23">-z filename</A>
</DIR>
<H2><A NAME="cindex_\">\</A></H2>
<DIR>
<LI><A HREF="ample.html#IDX92">\a</A>
<LI><A HREF="ample.html#IDX74">\ambig</A>
<LI><A HREF="ample.html#IDX27">\ancc</A>
<LI><A HREF="ample.html#IDX28">\ap</A>
<LI><A HREF="ample.html#IDX75">\barchar</A>
<LI><A HREF="ample.html#IDX76">\barcodes</A>
<LI><A HREF="ample.html#IDX100">\c</A>
<LI><A HREF="ample.html#IDX29">\ca</A>
<LI><A HREF="ample.html#IDX30">\cat</A>, <A HREF="ample.html#IDX94">\cat</A>
<LI><A HREF="ample.html#IDX31">\catcr</A>
<LI><A HREF="ample.html#IDX32">\ccl</A>
<LI><A HREF="ample.html#IDX63">\ch</A>, <A HREF="ample.html#IDX70">\ch</A>, <A HREF="ample.html#IDX77">\ch</A>
<LI><A HREF="ample.html#IDX33">\cr</A>
<LI><A HREF="ample.html#IDX93">\d</A>
<LI><A HREF="ample.html#IDX34">\dicdecap</A>
<LI><A HREF="ample.html#IDX78">\dsc</A>
<LI><A HREF="ample.html#IDX79">\excl</A>
<LI><A HREF="ample.html#IDX99">\f</A>
<LI><A HREF="ample.html#IDX96">\fd</A>
<LI><A HREF="ample.html#IDX80">\format</A>
<LI><A HREF="ample.html#IDX35">\ft</A>
<LI><A HREF="ample.html#IDX36">\iah</A>
<LI><A HREF="ample.html#IDX81">\incl</A>
<LI><A HREF="ample.html#IDX64">\infix</A>
<LI><A HREF="ample.html#IDX37">\it</A>
<LI><A HREF="ample.html#IDX82">\luwfc</A>
<LI><A HREF="ample.html#IDX83">\luwfcs</A>
<LI><A HREF="ample.html#IDX84">\maxdecap</A>
<LI><A HREF="ample.html#IDX38">\maxi</A>
<LI><A HREF="ample.html#IDX39">\maxn</A>
<LI><A HREF="ample.html#IDX40">\maxnull</A>
<LI><A HREF="ample.html#IDX41">\maxp</A>
<LI><A HREF="ample.html#IDX42">\maxprops</A>
<LI><A HREF="ample.html#IDX43">\maxr</A>
<LI><A HREF="ample.html#IDX44">\maxs</A>
<LI><A HREF="ample.html#IDX45">\mcc</A>
<LI><A HREF="ample.html#IDX46">\mcl</A>
<LI><A HREF="ample.html#IDX47">\mp</A>
<LI><A HREF="ample.html#IDX101">\n</A>
<LI><A HREF="ample.html#IDX48">\nah</A>
<LI><A HREF="ample.html#IDX85">\nocap</A>
<LI><A HREF="ample.html#IDX86">\noincap</A>
<LI><A HREF="ample.html#IDX49">\nt</A>
<LI><A HREF="ample.html#IDX95">\p</A>
<LI><A HREF="ample.html#IDX50">\pah</A>
<LI><A HREF="ample.html#IDX51">\patr</A>
<LI><A HREF="ample.html#IDX52">\pcl</A>
<LI><A HREF="ample.html#IDX65">\prefix</A>
<LI><A HREF="ample.html#IDX53">\pt</A>
<LI><A HREF="ample.html#IDX54">\rah</A>
<LI><A HREF="ample.html#IDX55">\rd</A>
<LI><A HREF="ample.html#IDX66">\root</A>
<LI><A HREF="ample.html#IDX56">\rt</A>
<LI><A HREF="ample.html#IDX57">\sah</A>
<LI><A HREF="ample.html#IDX58">\scl</A>, <A HREF="ample.html#IDX71">\scl</A>, <A HREF="ample.html#IDX87">\scl</A>
<LI><A HREF="ample.html#IDX59">\st</A>
<LI><A HREF="ample.html#IDX60">\strcheck</A>
<LI><A HREF="ample.html#IDX67">\suffix</A>
<LI><A HREF="ample.html#IDX97">\u</A>
<LI><A HREF="ample.html#IDX68">\unified</A>
<LI><A HREF="ample.html#IDX98">\w</A>
<LI><A HREF="ample.html#IDX88">\wfc</A>
<LI><A HREF="ample.html#IDX89">\wfcs</A>
</DIR>
<H2><A NAME="cindex_a">a</A></H2>
<DIR>
<LI><A HREF="ample.html#IDX26">analysis data file</A>
<LI><A HREF="ample.html#IDX91">analysis output file</A>
</DIR>
<H2><A NAME="cindex_d">d</A></H2>
<DIR>
<LI><A HREF="ample.html#IDX62">dictionary code table</A>
<LI><A HREF="ample.html#IDX72">dictionary files</A>
<LI><A HREF="ample.html#IDX69">dictionary orthography change table</A>
</DIR>
<H2><A NAME="cindex_o">o</A></H2>
<DIR>
<LI><A HREF="ample.html#IDX90">output analysis file</A>
</DIR>
<H2><A NAME="cindex_s">s</A></H2>
<DIR>
<LI><A HREF="ample.html#IDX25">standard format</A>
</DIR>
<H2><A NAME="cindex_t">t</A></H2>
<DIR>
<LI><A HREF="ample.html#IDX61">Test syntax</A>
<LI><A HREF="ample.html#IDX73">text input control</A>
</DIR>

</P>
<P><HR><P>
<H1>Footnotes</H1>
<H3><A NAME="FOOT1" HREF="ample.html#DOCF1">(1)</A></H3>
<P>This chapter is adapted from
chapters 7, 8, and 9 of Weber (1988).
<P><HR><P>
This document was generated on 2 June 2006 using the
<A HREF="http://wwwinfo.cern.ch/dis/texi2html/">texi2html</A>
translator version 1.52.</P>
</BODY>
</HTML>
