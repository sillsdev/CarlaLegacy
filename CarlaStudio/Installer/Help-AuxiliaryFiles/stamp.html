<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.52
	 from stamp.txi on 7 January 2004 -->

<TITLE>STAMP Reference Manual</TITLE>
</HEAD>
<BODY>
<H1>STAMP Reference Manual</H1>
<H2>Synthesizing after Transferring AMPLE Analyses</H2>
<H2>version 2.2.0</H2>
<H2>January 2004</H2>
<ADDRESS>by Stephen McConnel (and H. Andrew Black for v. 2.1b1 and above)</ADDRESS>
<P>
<P><HR><P>
<H1>Table of Contents</H1>
<UL>
<LI><A NAME="TOC1" HREF="stamp.html#SEC1">1  Introduction to the STAMP program</A>
<LI><A NAME="TOC2" HREF="stamp.html#SEC2">2  Running STAMP</A>
<UL>
<LI><A NAME="TOC3" HREF="stamp.html#SEC3">2.1  STAMP Command Options</A>
<LI><A NAME="TOC4" HREF="stamp.html#SEC4">2.2  Program Interaction</A>
</UL>
<LI><A NAME="TOC5" HREF="stamp.html#SEC5">3  Standard format</A>
<LI><A NAME="TOC6" HREF="stamp.html#SEC6">4  STAMP Declarations File</A>
<UL>
<LI><A NAME="TOC7" HREF="stamp.html#SEC7">4.1  Analytic ambiguity delimiter: \ambig</A>
<LI><A NAME="TOC8" HREF="stamp.html#SEC8">4.2  Allomorph property declaration: \ap</A>
<LI><A NAME="TOC9" HREF="stamp.html#SEC9">4.3  Category declarations: \ca</A>
<LI><A NAME="TOC10" HREF="stamp.html#SEC10">4.4  Category output control: \cat</A>
<LI><A NAME="TOC11" HREF="stamp.html#SEC11">4.5  Category class declaration: \ccl</A>
<LI><A NAME="TOC12" HREF="stamp.html#SEC12">4.6  Maximum number of properties: \maxprops</A>
<LI><A NAME="TOC13" HREF="stamp.html#SEC13">4.7  Morpheme class declaration: \mcl</A>
<LI><A NAME="TOC14" HREF="stamp.html#SEC14">4.8  Morpheme property declaration: \mp</A>
<LI><A NAME="TOC15" HREF="stamp.html#SEC15">4.9  Punctuation class: \pcl</A>
<LI><A NAME="TOC16" HREF="stamp.html#SEC16">4.10  Root delimiter: \rd</A>
<LI><A NAME="TOC17" HREF="stamp.html#SEC17">4.11  String class declaration: \scl</A>
<LI><A NAME="TOC18" HREF="stamp.html#SEC18">4.12  Valid allomorph and string environment characters: \strcheck</A>
</UL>
<LI><A NAME="TOC19" HREF="stamp.html#SEC19">5  Transfer Control File</A>
<UL>
<LI><A NAME="TOC20" HREF="stamp.html#SEC20">5.1  Analytic ambiguity delimiter: \ambig</A>
<LI><A NAME="TOC21" HREF="stamp.html#SEC21">5.2  Allomorph property declaration: \ap</A>
<LI><A NAME="TOC22" HREF="stamp.html#SEC22">5.3  Category declarations: \ca</A>
<LI><A NAME="TOC23" HREF="stamp.html#SEC23">5.4  Category class declaration: \ccl</A>
<LI><A NAME="TOC24" HREF="stamp.html#SEC24">5.5  Copy rule: \cr</A>
<LI><A NAME="TOC25" HREF="stamp.html#SEC25">5.6  Flag rule: \fl</A>
<LI><A NAME="TOC26" HREF="stamp.html#SEC26">5.7  Insertion rule: \ir</A>
<UL>
<LI><A NAME="TOC27" HREF="stamp.html#SEC27">5.7.1  Flags in insertion rules</A>
<LI><A NAME="TOC28" HREF="stamp.html#SEC28">5.7.2  Determining the site for insertion</A>
</UL>
<LI><A NAME="TOC29" HREF="stamp.html#SEC29">5.8  Lexical change: \lc</A>
<UL>
<LI><A NAME="TOC30" HREF="stamp.html#SEC30">5.8.1  Morphnames in lexical changes</A>
<LI><A NAME="TOC31" HREF="stamp.html#SEC31">5.8.2  Categories in lexical changes</A>
<LI><A NAME="TOC32" HREF="stamp.html#SEC32">5.8.3  Delimiters and type in lexical changes</A>
<LI><A NAME="TOC33" HREF="stamp.html#SEC33">5.8.4  Environment conditions on lexical changes</A>
<LI><A NAME="TOC34" HREF="stamp.html#SEC34">5.8.5  Which change applies?</A>
<LI><A NAME="TOC35" HREF="stamp.html#SEC35">5.8.6  Common errors in lexical changes</A>
<LI><A NAME="TOC36" HREF="stamp.html#SEC36">5.8.7  Two examples</A>
<LI><A NAME="TOC37" HREF="stamp.html#SEC37">5.8.8  Where should lexical changes be made?</A>
<UL>
<LI><A NAME="TOC38" HREF="stamp.html#SEC38">5.8.8.1  In the transfer file</A>
<LI><A NAME="TOC39" HREF="stamp.html#SEC39">5.8.8.2  In the synthesis file</A>
<LI><A NAME="TOC40" HREF="stamp.html#SEC40">5.8.8.3  Using both the transfer and synthesis files</A>
</UL>
</UL>
<LI><A NAME="TOC41" HREF="stamp.html#SEC41">5.9  Maximum number of properties: \maxprops</A>
<LI><A NAME="TOC42" HREF="stamp.html#SEC42">5.10  Morpheme class declaration: \mcl</A>
<LI><A NAME="TOC43" HREF="stamp.html#SEC43">5.11  Morpheme property declaration: \mp</A>
<LI><A NAME="TOC44" HREF="stamp.html#SEC44">5.12  Punctuation class: \pcl</A>
<LI><A NAME="TOC45" HREF="stamp.html#SEC45">5.13  Root delimiter: \rd</A>
<LI><A NAME="TOC46" HREF="stamp.html#SEC46">5.14  String class declaration: \scl</A>
<LI><A NAME="TOC47" HREF="stamp.html#SEC47">5.15  Substitution rule: \sr</A>
</UL>
<LI><A NAME="TOC48" HREF="stamp.html#SEC48">6  Synthesis Control File</A>
<UL>
<LI><A NAME="TOC49" HREF="stamp.html#SEC49">6.1  Analytic ambiguity delimiter: \ambig</A>
<LI><A NAME="TOC50" HREF="stamp.html#SEC50">6.2  Allomorph property declaration: \ap</A>
<LI><A NAME="TOC51" HREF="stamp.html#SEC51">6.3  Category declarations: \ca</A>
<LI><A NAME="TOC52" HREF="stamp.html#SEC52">6.4  Category class declaration: \ccl</A>
<LI><A NAME="TOC53" HREF="stamp.html#SEC53">6.5  Lexical change: \lc</A>
<LI><A NAME="TOC54" HREF="stamp.html#SEC54">6.6  Maximum number of properties: \maxprops</A>
<LI><A NAME="TOC55" HREF="stamp.html#SEC55">6.7  Morpheme class declaration: \mcl</A>
<LI><A NAME="TOC56" HREF="stamp.html#SEC56">6.8  Morpheme property declaration: \mp</A>
<LI><A NAME="TOC57" HREF="stamp.html#SEC57">6.9  Punctuation class: \pcl</A>
<LI><A NAME="TOC58" HREF="stamp.html#SEC58">6.10  Root delimiter: \rd</A>
<LI><A NAME="TOC59" HREF="stamp.html#SEC59">6.11  Regular sound change: \rsc</A>
<LI><A NAME="TOC60" HREF="stamp.html#SEC60">6.12  Regular sound change identifiers: \rscid</A>
<LI><A NAME="TOC61" HREF="stamp.html#SEC61">6.13  String class declaration: \scl</A>
<LI><A NAME="TOC62" HREF="stamp.html#SEC62">6.14  Synthesis test: \test</A>
<UL>
<LI><A NAME="TOC63" HREF="stamp.html#SEC63">6.14.1  Campa epenthesis revisited</A>
<LI><A NAME="TOC64" HREF="stamp.html#SEC64">6.14.2  Reporting conditions</A>
<LI><A NAME="TOC65" HREF="stamp.html#SEC65">6.14.3  Test syntax</A>
</UL>
</UL>
<LI><A NAME="TOC66" HREF="stamp.html#SEC66">7  Dictionary Code Table File</A>
<UL>
<LI><A NAME="TOC67" HREF="stamp.html#SEC67">7.1  Change standard format marker to internal code: \ch</A>
<LI><A NAME="TOC68" HREF="stamp.html#SEC68">7.2  Infix dictionary fields: \infix</A>
<LI><A NAME="TOC69" HREF="stamp.html#SEC69">7.3  Prefix dictionary fields: \prefix</A>
<LI><A NAME="TOC70" HREF="stamp.html#SEC70">7.4  Root dictionary fields: \root</A>
<LI><A NAME="TOC71" HREF="stamp.html#SEC71">7.5  Suffix dictionary fields: \suffix</A>
<LI><A NAME="TOC72" HREF="stamp.html#SEC72">7.6  Unified dictionary fields: \unified</A>
</UL>
<LI><A NAME="TOC73" HREF="stamp.html#SEC73">8  Dictionary Orthography Change Table File</A>
<UL>
<LI><A NAME="TOC74" HREF="stamp.html#SEC74">8.1  Dictionary Orthography Change: \ch</A>
<LI><A NAME="TOC75" HREF="stamp.html#SEC75">8.2  String class: \scl</A>
</UL>
<LI><A NAME="TOC76" HREF="stamp.html#SEC76">9  Dictionary Files</A>
<UL>
<LI><A NAME="TOC77" HREF="stamp.html#SEC77">9.1  Allomorph (internal code A)</A>
<LI><A NAME="TOC78" HREF="stamp.html#SEC78">9.2  Category (internal code C)</A>
<LI><A NAME="TOC79" HREF="stamp.html#SEC79">9.3  Elsewhere Allomorph (internal code E)</A>
<LI><A NAME="TOC80" HREF="stamp.html#SEC80">9.4  Infix location (internal code L)</A>
<LI><A NAME="TOC81" HREF="stamp.html#SEC81">9.5  Morphname (internal code M)</A>
<LI><A NAME="TOC82" HREF="stamp.html#SEC82">9.6  Order class (internal code O)</A>
<LI><A NAME="TOC83" HREF="stamp.html#SEC83">9.7  Morpheme property (internal code P)</A>
<LI><A NAME="TOC84" HREF="stamp.html#SEC84">9.8  Morpheme type (internal code T)</A>
<LI><A NAME="TOC85" HREF="stamp.html#SEC85">9.9  Do not load (internal code !)</A>
</UL>
<LI><A NAME="TOC86" HREF="stamp.html#SEC86">10  Text Output Control File</A>
<UL>
<LI><A NAME="TOC87" HREF="stamp.html#SEC87">10.1  Text output ambiguity delimiter: \ambig</A>
<LI><A NAME="TOC88" HREF="stamp.html#SEC88">10.2  Text output orthographic changes: \ch</A>
<UL>
<LI><A NAME="TOC89" HREF="stamp.html#SEC89">10.2.1  Basic changes</A>
<LI><A NAME="TOC90" HREF="stamp.html#SEC90">10.2.2  Environmentally constrained changes</A>
<LI><A NAME="TOC91" HREF="stamp.html#SEC91">10.2.3  Using text orthography changes</A>
<LI><A NAME="TOC92" HREF="stamp.html#SEC92">10.2.4  Where orthography changes apply</A>
<LI><A NAME="TOC93" HREF="stamp.html#SEC93">10.2.5  A sample orthography change table</A>
<LI><A NAME="TOC94" HREF="stamp.html#SEC94">10.2.6  Syntax of Orthography Changes</A>
</UL>
<LI><A NAME="TOC95" HREF="stamp.html#SEC95">10.3  Decomposition Separation Character: \dsc</A>
<LI><A NAME="TOC96" HREF="stamp.html#SEC96">10.4  Primary format marker character: \format</A>
<LI><A NAME="TOC97" HREF="stamp.html#SEC97">10.5  Lowercase/uppercase character pairs: \luwfc</A>
<LI><A NAME="TOC98" HREF="stamp.html#SEC98">10.6  Multibyte lowercase/uppercase character pairs: \luwfcs</A>
<LI><A NAME="TOC99" HREF="stamp.html#SEC99">10.7  Text output string classes: \scl</A>
<LI><A NAME="TOC100" HREF="stamp.html#SEC100">10.8  Caseless word formation characters: \wfc</A>
<LI><A NAME="TOC101" HREF="stamp.html#SEC101">10.9  Multibyte caseless word formation characters: \wfcs</A>
<LI><A NAME="TOC102" HREF="stamp.html#SEC102">10.10  A sample text output control file</A>
</UL>
<LI><A NAME="TOC103" HREF="stamp.html#SEC103">11  Input Analysis Files</A>
<UL>
<LI><A NAME="TOC104" HREF="stamp.html#SEC104">11.1  Analysis file fields</A>
<UL>
<LI><A NAME="TOC105" HREF="stamp.html#SEC105">11.1.1  Analysis field: \a</A>
<LI><A NAME="TOC106" HREF="stamp.html#SEC106">11.1.2  Decomposition field: \d</A>
<LI><A NAME="TOC107" HREF="stamp.html#SEC107">11.1.3  Category field: \cat</A>
<LI><A NAME="TOC108" HREF="stamp.html#SEC108">11.1.4  Properties field: \p</A>
<LI><A NAME="TOC109" HREF="stamp.html#SEC109">11.1.5  Feature Descriptors field: \fd</A>
<LI><A NAME="TOC110" HREF="stamp.html#SEC110">11.1.6  Underlying form field: \u</A>
<LI><A NAME="TOC111" HREF="stamp.html#SEC111">11.1.7  Word field: \w</A>
<LI><A NAME="TOC112" HREF="stamp.html#SEC112">11.1.8  Formatting field: \f</A>
<LI><A NAME="TOC113" HREF="stamp.html#SEC113">11.1.9  Capitalization field: \c</A>
<LI><A NAME="TOC114" HREF="stamp.html#SEC114">11.1.10  Nonalphabetic field: \n</A>
</UL>
<LI><A NAME="TOC115" HREF="stamp.html#SEC115">11.2  Ambiguous analyses</A>
<LI><A NAME="TOC116" HREF="stamp.html#SEC116">11.3  Analysis failures</A>
</UL>
<LI><A NAME="TOC117" HREF="stamp.html#SEC117">Bibliography</A>
<LI><A NAME="TOC118" HREF="stamp.html#SEC118">12  Index</A>
</UL>
<P><HR><P>


<H1><A NAME="SEC1" HREF="stamp.html#TOC1">1  Introduction to the STAMP program</A></H1>

<P>
This manual describes STAMP, a computer program for adapting text in
conjunction with the AMPLE program.  This combination falls under the
Analysis Transfer Synthesis (ATS) paradigm.  It involves the following
steps:

</P>
<P>
(1) AMPLE is a morphological parser that is applied to source language
	text to analyze each word into morphemes.

</P>
<P>
(2) STAMP is applied to these analyses to make changes that will produce
	the corresponding target language word.

</P>
<P>
(3) An interactive editor is applied to STAMP output to correct the
	words that AMPLE failed to analyze and for which AMPLE and STAMP
	produced multiple possibilities.  The result is a word-for-word draft
	of the source language text in the target language.

</P>
<P>
(4) After eliminating analysis failures and ambiguities, the text must be
	checked and corrected by a competent speaker of the target language.

</P>
<P>
STAMP incorporates no language-specific facts; the user makes linguistic
facts known to STAMP entirely through external files.  STAMP is
sufficiently general to serve over a wide range of language families.
(However, AMPLE and STAMP do not adequately handle highly isolating
languages, that is, languages which have virtually no morphology.)

</P>
<P>
The name STAMP is derived by taking AMP from AMPLE, and T and S from
STAMP's main modules, TRANSFER and SYNTHESIS, which are applied in
succession to the output of AMPLE.  Thus one can think of STAMP as
S(T(AMP)), or more explicitly as:

<PRE>

adapted text = Synthesis[Transfer[AMPLE[source text]]]

</PRE>

<P>
Note: much of this reference manual is based almost verbatim on the book
published in 1990 (Weber, Black, McConnel, and Buseman), without explicit
permission from the coauthors.

</P>

<H4>1.0.0.1  New features</H4>
<DL COMPACT>

<DT>1. Version 2.1 (May 1999) introduced punctuation environment constraints in the allomorph fields of the dictionary files.  These are handled by a new built-in test called PEC_ST.  This version also added two punctuation-oriented clauses to user-written tests.
<DD>
<DT>2. Version 2.1b17 (October 2003) filled out several sections which previously had missing content.
<DD>
<DT>3. Version 2.2.0 (January 2004) added negative string environment constraints.
<DD>
</DL>



<H1><A NAME="SEC2" HREF="stamp.html#TOC2">2  Running STAMP</A></H1>

<P>
STAMP is a batch process oriented program.  It reads a number of control
files, and then processes one or more input analysis files to produce an
equal number of output files.

</P>

<UL>
<LI><A HREF="stamp.html#SEC3">Command options</A>
<LI><A HREF="stamp.html#SEC4">Interaction</A>
</UL>



<H2><A NAME="SEC3" HREF="stamp.html#TOC3">2.1  STAMP Command Options</A></H2>

<P>
The STAMP program uses an old-fashioned command line interface
following the convention of options starting with a dash character
(<SAMP>`-'</SAMP>).  The available options are listed below in alphabetical
order.  Those options which require an argument have the argument type
following the option letter.

</P>
<DL COMPACT>

<DT><CODE>-a</CODE>
<DD>
<A NAME="IDX1"></A>
causes all possible syntheses to be generated.

<DT><CODE>-c character</CODE>
<DD>
<A NAME="IDX2"></A>
selects the control file comment character.  The default is the vertical
bar (<CODE>|</CODE>).

<DT><CODE>-d number</CODE>
<DD>
<A NAME="IDX3"></A>
selects the maximum dictionary trie depth.  The default is 2, which
favors reduced memory needs over speed.

<DT><CODE>-f filename</CODE>
<DD>
<A NAME="IDX4"></A>
opens a command file containing the names of the control and data
files.  The default is to read those names from the standard input
(keyboard); see
section <A HREF="stamp.html#SEC4">2.2  Program Interaction</A>.

<DT><CODE>-i filename</CODE>
<DD>
<A NAME="IDX5"></A>
selects a single input analysis file.

<DT><CODE>-m</CODE>
<DD>
<A NAME="IDX6"></A>
monitors progress of an analysis: <CODE>*</CODE> means an analysis failure,
<CODE>.</CODE> means a single analysis, <CODE>2</CODE>-<CODE>9</CODE> means
2-9 ambiguities, and <CODE>&#62;</CODE> means 10 or more ambiguities.
This is not compatible with the <SAMP>`-q'</SAMP> option.

<DT><CODE>-n</CODE>
<DD>
<A NAME="IDX7"></A>
prevents root categories from being checked.

<DT><CODE>-o filename</CODE>
<DD>
<A NAME="IDX8"></A>
selects a single output text (or analysis if the <SAMP>`-x'</SAMP> option is also
selected) file.

<DT><CODE>-q</CODE>
<DD>
<A NAME="IDX9"></A>
causes AMPLE to operate "quietly" with minimal screen output.  This
is not compatible with the <SAMP>`-m'</SAMP> option.

<DT><CODE>-r</CODE>
<DD>
<A NAME="IDX10"></A>
causes morphnames that are not found in the dictionary to be reported.

<DT><CODE>-t</CODE>
<DD>
<A NAME="IDX11"></A>
causes the transfer and synthesis processes to be traced.  This produces
a huge amount of output.

<DT><CODE>-u</CODE>
<DD>
<A NAME="IDX12"></A>
signals that dictionaries are unified, not split into prefix, infix,
suffix, and root files.

<DT><CODE>-v</CODE>
<DD>
<A NAME="IDX13"></A>
verifies tests by pretty printing the parse trees.

<DT><CODE>-x</CODE>
<DD>
<A NAME="IDX14"></A>
restricts STAMP to only the transfer process.
</DL>

<P>
The following options exist only in beta-test versions of the program,
since they are used only for debugging.

</P>
<DL COMPACT>

<DT><CODE>-/</CODE>
<DD>
<A NAME="IDX15"></A>
increments the debugging level.  The default is zero (no debugging output).

<DT><CODE>-z filename</CODE>
<DD>
<A NAME="IDX16"></A>
opens a file for recording a memory allocation log.

<DT><CODE>-Z address,count</CODE>
<DD>
<A NAME="IDX17"></A>
traps the program at the point where <CODE>address</CODE> is allocated or
freed for the <CODE>count</CODE>'th time.
</DL>



<H2><A NAME="SEC4" HREF="stamp.html#TOC4">2.2  Program Interaction</A></H2>

<P>
If the <SAMP>`-f'</SAMP>, <SAMP>`-i'</SAMP>, and <SAMP>`-o'</SAMP> command options are not
used, STAMP prompts for a number of file names, reading the standard
input for the desired values.  The interactive dialog goes like this:

<PRE>

C&#62; stamp
STAMP: Synthesis(Transfer(AMPle(text))) = adapted text
Version 2.0b1 (July 21, 1998), Copyright 1998 SIL, Inc.
Beta test version compiled Jul 27 1998 16:04:11
	   Transfer/Synthesis Performed Tue Jul 28 14:54:04 1998
STAMP declarations file (zzSTAMP.DEC): pnstamp.dec
Transfer file (xxzzTR.CHG) [none]: hgpntr.chg
Synthesis file (zzSYNT.CHG) [none]: pnsynt.chg
Dictionary code table (zzSYCD.TAB): pnsycd.tab
Dictionary orthography change table (zzORDC.TAB) [none]: pnordc.tab
	10 changes loaded from suffix dictionary code table.
Suffix dictionary file (zzSF01.DIC): pnsf01.dic
		SUFFIX DICTIONARY: Loaded 137 records
	10 changes loaded from root dictionary code table.
Root dictionary file (xxRTnn.DIC): pnsyrt.dic
		ROOT DICTIONARY: Loaded 176 records
Next Root dictionary file (xxRTnn.DIC) [no more]:
Output text control file (zzOUTTX.CTL) [none]: pnoutx.ctl
10 output orthography changes were loaded from pnoutx.ctl

First Input file: pntest.ana
Output file: pntest.syn

Next Input file (or RETURN if no more):
C&#62;

</PRE>

<P>
Note that each prompt contains a reminder of the expected form of the
answer in parentheses and ends with a colon.  Several of the prompts
also contain the default answer in brackets.

</P>
<P>
Using the command options does not change the appearance of the program
screen output significantly, but the program displays the answers to
each of its prompts without waiting for input.  Assume that the file
<TT>`pntest.cmd'</TT> contains the following, which is the same as the
answers given above:

<PRE>

pnstamp.dec
hgpntr.chg
pnsynt.chg
pnsycd.tab
pnordc.tab
pnsf01.dic
pnsyrt.dic

pnoutx.ctl

</PRE>

<P>
Then running STAMP with the command options produces screen output like
the following:

<PRE>

C&#62; stamp -f pntest.cmd -i pntest.ana -o pntest.syn
STAMP: Synthesis(Transfer(AMPle(text))) = adapted text
Version 2.0b1 (July 21, 1998), Copyright 1998 SIL, Inc.
Beta test version compiled Jul 27 1998 16:04:11
	   Transfer/Synthesis Performed Tue Jul 28 14:59:34 1998
STAMP declarations file (zzSTAMP.DEC): pnstamp.dec
Transfer file (xxzzTR.CHG) [none]: hgpntr.chg
Synthesis file (zzSYNT.CHG) [none]: pnsynt.chg
Dictionary code table (zzSYCD.TAB): pnsycd.tab
Dictionary orthography change table (zzORDC.TAB) [none]: pnordc.tab
	10 changes loaded from suffix dictionary code table.
Suffix dictionary file (zzSF01.DIC): pnsf01.dic
		SUFFIX DICTIONARY: Loaded 137 records
	10 changes loaded from root dictionary code table.
Root dictionary file (xxRTnn.DIC): pnsyrt.dic
		ROOT DICTIONARY: Loaded 176 records
Next Root dictionary file (xxRTnn.DIC) [no more]:
Output text control file (zzOUTTX.CTL) [none]: pnoutx.ctl
10 output orthography changes were loaded from pnoutx.ctl

C&#62;

</PRE>

<P>
The only difference in the screen output is that the prompts for the
input text file and the output analysis file are not displayed.

</P>


<H1><A NAME="SEC5" HREF="stamp.html#TOC5">3  Standard format</A></H1>
<P>
<A NAME="IDX18"></A>

</P>
<P>
The input control files
and input analysis file
that STAMP reads
are all <EM>standard format</EM> files.  This means that the files are
divided into records and fields.  Each file contains at least one
record, and some files may contain a large number of records.  Each
record contains one or more fields.  Each field occupies at least one
line, and is marked by a <EM>field code</EM> at the beginning of the
line.  A field code begins with a backslash character (<CODE>\</CODE>), and
contains 1 or more printing characters (usually alphabetic) in
addition.

</P>
<P>
If the file is designed to have multiple records, then one of the field
codes must be designated to be the <EM>record marker</EM>, and every
record begins with that field, even if it is empty apart from the field
code.  If the file contains only one record, then the relative order of
the fields is constrained only by their semantics.

</P>
<P>
It is worth emphasizing that field codes must be at the
<EM>beginning</EM> of a line.  Even a single space before the backslash
character prevents it from being recognized as a field code.

</P>
<P>
It is also worth emphasizing that record markers <EM>must</EM> be present
even if that field has no information for that record.  Omitting the
record marker causes two records to be merge into a single record, with
unpredictable results.

</P>


<H1><A NAME="SEC6" HREF="stamp.html#TOC6">4  STAMP Declarations File</A></H1>

<P>
The fields that STAMP recognizes in its "declarations file" are described
below.  Fields that start with any other backslash codes are ignored by
STAMP.

</P>

<UL>
<LI><A HREF="stamp.html#SEC7">\ambig (zzSTAMP.DEC)</A>: Analytic ambiguity delimiter
<LI><A HREF="stamp.html#SEC8">\ap</A>: Allomorph property declaration
<LI><A HREF="stamp.html#SEC9">\ca</A>: Category declarations
<LI><A HREF="stamp.html#SEC10">\cat (zzSTAMP.DEC)</A>: Category output control
<LI><A HREF="stamp.html#SEC11">\ccl</A>: Category class declaration
<LI><A HREF="stamp.html#SEC12">\maxprops</A>: Maximum number of properties
<LI><A HREF="stamp.html#SEC13">\mcl</A>: Morpheme class declaration
<LI><A HREF="stamp.html#SEC14">\mp</A>: Morpheme property declaration
<LI><A HREF="stamp.html#SEC15">\pcl</A>: Punctuation class
<LI><A HREF="stamp.html#SEC16">\rd</A>: Root delimiter
<LI><A HREF="stamp.html#SEC17">\scl (zzSTAMP.DEC)</A>: String class declaration
<LI><A HREF="stamp.html#SEC18">\strcheck</A>: Valid allomorph and string environment characters
</UL>



<H2><A NAME="SEC7" HREF="stamp.html#TOC7">4.1  Analytic ambiguity delimiter: \ambig</A></H2>
<P>
<A NAME="IDX19"></A>

</P>
<P>
When AMPLE produces more than one analysis, each analysis is set off by a
unique character.  Likewise, when AMPLE fails to analyze a source
language word, it flags this word with the same character, the default
for which is a percent sign (<CODE>%</CODE>).  However, a user may override
AMPLE's default.

</P>
<P>
Like AMPLE, STAMP assumes this delimiter to be a percent sign.  If an
analyzed text does not use this character, STAMP must be informed as to
what character was used.  To do this, use the \ambig field to define the
desired character.  For example, the following would change the analytic
ambiguity delimiter to <CODE>@</CODE>:

<PRE>

\ambig @

</PRE>



<H2><A NAME="SEC8" HREF="stamp.html#TOC8">4.2  Allomorph property declaration: \ap</A></H2>
<P>
<A NAME="IDX20"></A>

</P>
<P>
Allomorph properties are defined by the field code <CODE>\ap</CODE> followed
by one or more allomorph property names.  An allomorph property name
must be a single, contiguous sequence of printing characters.
Characters and words which have special meanings in tests should not be
used.  For example, the following would declare the allomorph properties
<CODE>deletedK</CODE>, <CODE>deletedG</CODE>, and <CODE>underlyingV</CODE>:

</P>

<PRE>

\ap deletedK deletedG  | elided morpheme final velars
\ap underlyingV        | underlying long vowel

</PRE>

<P>
A maximum of 255 properties (including both allomorph and morpheme
properties) may be defined unless the <CODE>\maxprops</CODE> field is used to
define a larger number.  Any number of <CODE>\ap</CODE> fields may be
used so long as the number of property names does not exceed 255 (or the
number defined by the <CODE>\maxprops</CODE> field).  Note that any
<CODE>\maxprops</CODE> field must occur before any <CODE>\ap</CODE> or <CODE>\mp</CODE>
fields.

</P>


<H2><A NAME="SEC9" HREF="stamp.html#TOC9">4.3  Category declarations: \ca</A></H2>
<P>
<A NAME="IDX21"></A>

</P>
<P>
Categories are defined by the field code <CODE>\ca</CODE> followed by one or
more category names.  A category name must be a single, contiguous
sequence of printing characters.  Characters and words which have
special meanings in tests should not be used.

</P>
<P>
A maximum of 255 categories may be defined.  Any number of <CODE>\ca</CODE>
fields may be used so long as the number of category names does not
exceed 255.

</P>


<H2><A NAME="SEC10" HREF="stamp.html#TOC10">4.4  Category output control: \cat</A></H2>
<P>
<A NAME="IDX22"></A>

</P>
<P>
The category information to write to the analysis output file is
defined by the field code <CODE>\cat</CODE> followed by one or two words.
The first word must be either <CODE>prefix</CODE> or <CODE>suffix</CODE> (or an
abbreviation of one of those words), either capitalized or lowercase.

</P>
<P>
The <CODE>\cat</CODE> field may appear any number of times, but once is
enough.  If more than one such field occurs, the last one is the one
that is used.

</P>
<P>
NOTE: at present, this does not do anything in the code.  Is this a
feature that has never been used?  When was it introduced?  I'd be quite
willing to rip it out of the code.

</P>


<H2><A NAME="SEC11" HREF="stamp.html#TOC11">4.5  Category class declaration: \ccl</A></H2>
<P>
<A NAME="IDX23"></A>

</P>
<P>
A category class declaration has three parts: the field code <CODE>\ccl</CODE>,
the name of the class, and the list of categories in the class (separated
by spaces).  For example, the following defines the class <CODE>IVERB</CODE>
containing the categories <CODE>V1X</CODE> and <CODE>V1Y</CODE>:

<PRE>

\ccl IVERB V1X V1Y

</PRE>

<P>
The class name must be a single, contiguous sequence of printing
characters.  Characters and words which have special meanings in tests
should not be used.  The category names must have been defined by an
earlier <CODE>\ca</CODE> field; see
section <A HREF="stamp.html#SEC9">4.3  Category declarations: \ca</A>.

</P>
<P>
In transfer, category classes can only be used in the match strings of
lexical changes; see
section <A HREF="stamp.html#SEC29">5.8  Lexical change: \lc</A>.

</P>
<P>
Each <CODE>\ccl</CODE> field defines a single category class.  Any number of
<CODE>\ccl</CODE> fields may appear in the file.

</P>


<H2><A NAME="SEC12" HREF="stamp.html#TOC12">4.6  Maximum number of properties: \maxprops</A></H2>
<P>
<A NAME="IDX24"></A>

</P>
<P>
The maximum number of properties that can be defined can be increased
from the default of 255 by giving the <CODE>\maxprops</CODE> field code
followed by a number greater than or equal to 255 but less than 65536.

</P>
<P>
The <CODE>\maxprops</CODE> field may appear any number of times, but once is
enough.  If more than one such field occurs, the one containing the
largest valid value is the one that is used.

</P>
<P>
The <CODE>\maxprops</CODE> must be used before any properties are defined.
This is the case for both morpheme and allomorph properties.

</P>
<P>
If no <CODE>\maxprops</CODE> fields appear in the declarations file, then
STAMP limits the number of properties which can be defined to 255.

</P>


<H2><A NAME="SEC13" HREF="stamp.html#TOC13">4.7  Morpheme class declaration: \mcl</A></H2>
<P>
<A NAME="IDX25"></A>

</P>
<P>
A morpheme class declaration has three parts: the field code <CODE>\mcl</CODE>,
the name of the class, and the list of morphnames in the class (separated
by spaces).  For example, a morpheme class <CODE>DIRECTION</CODE> could be
defined as follows:

<PRE>

\mcl DIRECTION UP DOWN IN OUT

</PRE>

<P>
Such a class could be used in conditioning environments for lexical
changes, insertion rules, or substitution rules.  For example, the
following environment would limit the rule to apply only preceding one
of the directional morphemes:

<PRE>

/ _ [DIRECTION]

</PRE>

<P>
The class name must be a single, contiguous sequence of printing
characters.  Characters and words which have special meanings in tests
should not be used.  The morpheme names should be defined by an entry
in one of the dictionary files.

</P>
<P>
Each <CODE>\mcl</CODE> field defines a single morpheme class.  Any number of
<CODE>\mcl</CODE> fields may appear in the file.

</P>


<H2><A NAME="SEC14" HREF="stamp.html#TOC14">4.8  Morpheme property declaration: \mp</A></H2>
<P>
<A NAME="IDX26"></A>

</P>
<P>
Morpheme properties are defined by the field code <CODE>\mp</CODE> followed by
one or more morpheme property names.  A morpheme property name must be a
single, contiguous sequence of printing characters.  Characters and words
which have special meanings in tests should not be used.  For example,
the following would declare the morpheme properties <CODE>XYZ</CODE>,
<CODE>ABC</CODE>, and <CODE>DEF</CODE>:

<PRE>

\mp XYZ
\mp ABC DEF

</PRE>

<P>
A maximum of 255 properties (including both allomorph and morpheme
properties) may be defined unless the <CODE>\maxprops</CODE> field is used to
define a larger number.  Any number of <CODE>\mp</CODE> fields may be
used so long as the number of property names does not exceed 255 (or the
number defined by the <CODE>\maxprops</CODE> field).  Note that any
<CODE>\maxprops</CODE> field must occur before any <CODE>\mp</CODE> or <CODE>\ap</CODE>
fields.

</P>


<H2><A NAME="SEC15" HREF="stamp.html#TOC15">4.9  Punctuation class: \pcl</A></H2>
<P>
<A NAME="IDX27"></A>

</P>
<P>
A punctuation class is defined by the field code <CODE>\pcl</CODE> followed
by the class name, which is followed in turn by one or more
punctuation characters or (previously defined) punctuation class
names.  A punctuation class name used as part of the class definition
must be enclosed in square brackets.

</P>
<P>
The class name must be a single, contiguous sequence of printing
characters.  The individual members of the class are separated by
spaces, tabs, or newlines.

</P>
<P>
Each <CODE>\pcl</CODE> field defines a single punctuation class.  Any number of
<CODE>\pcl</CODE> fields may appear in the file.

</P>
<P>
If no <CODE>\pcl</CODE> fields appear in the declarations file, then STAMP
does not allow any punctuation classes in tests, and does not allow any
punctuation classes in punctuation environment constraints.

</P>


<H2><A NAME="SEC16" HREF="stamp.html#TOC16">4.10  Root delimiter: \rd</A></H2>
<P>
<A NAME="IDX28"></A>

</P>
<P>
For each analysis, the root (or roots), and the category of the first
root, are delimited by a pair of reserved characters.  By default, AMPLE
uses wedges (<CODE>&#60;</CODE> and <CODE>&#62;</CODE>).  If some characters other than
wedges are used for this purpose, they must be declared using the
<CODE>\rd</CODE> field.  (<CODE>\rd</CODE> is mnemonic for "root delimiter".)  For
example, the following line might be included in the input control file:

<PRE>

\rd ( )

</PRE>

<P>
Two characters are expected after the field code, optionally separated by
white space.  The first is taken to be the opening (that is, left)
delimiter and the second is taken to be the closing (that is, right)
delimiter.  Different characters must be used for the opening and
closing delimiters.

</P>
<P>
The delimiters used to set off the root should not be used for any other
purpose in the analysis field.  The following may not be used for a
delimiter: the backslash (<CODE>\</CODE>), whatever character is used to
indicate analytic failures and ambiguities, or any orthographic
character.

</P>
<P>
The <CODE>\rd</CODE> field may appear any number of times, but once is
enough.  If more than one such field occurs, the last one is the one
that is used.

</P>
<P>
If no <CODE>\rd</CODE> fields appear in the declarations file, then STAMP uses
the delimiter characters <CODE>&#60;</CODE> and <CODE>&#62;</CODE>.

</P>


<H2><A NAME="SEC17" HREF="stamp.html#TOC17">4.11  String class declaration: \scl</A></H2>
<P>
<A NAME="IDX29"></A>

</P>
<P>
A string class declaration has three parts: the field code <CODE>\scl</CODE>,
the name of the class, and the list of strings in the class (separated by
spaces).  String classes are used in synthesis in specifying string
environment constraints on regular sound changes and on allomorph entries
in the dictionaries.

</P>
<P>
The class name must be a single, contiguous sequence of printing
characters.  Characters and words which have special meanings in tests
should not be used.  The actual character strings have no such
restrictions.  The individual members of the class are separated by
spaces, tabs, or newlines.

</P>
<P>
Each <CODE>\scl</CODE> field defines a single string class.  Any number of
<CODE>\scl</CODE> fields may appear in the file.

</P>


<H2><A NAME="SEC18" HREF="stamp.html#TOC18">4.12  Valid allomorph and string environment characters: \strcheck</A></H2>
<P>
<A NAME="IDX30"></A>

</P>
<P>
The characters considered to be valid for allomorph strings and string
environment constraints are defined by a <CODE>\strcheck</CODE> field code
followed by the list of characters.  Spaces are not significant in this
list.

</P>
<P>
The <CODE>\strcheck</CODE> field may appear any number of times, but once is
enough.  If more than one such field occurs, the last one is the one
that is used.

</P>
<P>
If no <CODE>\strcheck</CODE> fields appear in the analysis data file, then
STAMP does not check allomorph strings and string environment
constraints for containing only valid characters.

</P>


<H1><A NAME="SEC19" HREF="stamp.html#TOC19">5  Transfer Control File</A></H1>

<P>
The transfer control file for the STAMP program is a standard format
file containing a single data record.  The fields that STAMP
recognizes in its "transfer control file" are described below. Fields that
start with any other backslash codes are ignored by STAMP

</P>


<UL>
<LI><A HREF="stamp.html#SEC20">\ambig (xxzzTR.CHG)</A>: Analytic ambiguity delimiter *
<LI><A HREF="stamp.html#SEC21">\ap (xxzzTR.CHG)</A>: Allomorph property declaration *
<LI><A HREF="stamp.html#SEC22">\ca (xxzzTR.CHG)</A>: Category declarations *
<LI><A HREF="stamp.html#SEC23">\ccl (xxzzTR.CHG)</A>: Category class declaration *
<LI><A HREF="stamp.html#SEC24">\cr</A>: Copy rule
<LI><A HREF="stamp.html#SEC25">\fl</A>: Flag rule
<LI><A HREF="stamp.html#SEC26">\ir</A>: Insertion rule
<LI><A HREF="stamp.html#SEC29">\lc</A>: Lexical change
<LI><A HREF="stamp.html#SEC41">\maxprops (xxzzTR.CHG)</A>: Maximum number of properties *
<LI><A HREF="stamp.html#SEC42">\mcl (xxzzTR.CHG)</A>: Morpheme class declaration *
<LI><A HREF="stamp.html#SEC43">\mp (xxzzTR.CHG)</A>: Morpheme property declaration *
<LI><A HREF="stamp.html#SEC44">\pcl (xxzzTR.CHG)</A>: Punctuation class *
<LI><A HREF="stamp.html#SEC45">\rd (xxzzTR.CHG)</A>: Root delimiter *
<LI><A HREF="stamp.html#SEC46">\scl (xxzzTR.CHG)</A>: String class declaration *
<LI><A HREF="stamp.html#SEC47">\sr</A>: Substitution rule
</UL>



<H2><A NAME="SEC20" HREF="stamp.html#TOC20">5.1  Analytic ambiguity delimiter: \ambig</A></H2>
<P>
<A NAME="IDX31"></A>

</P>
<P>
This field can also occur in the STAMP declarations file or the STAMP
synthesis control file instead; see
section <A HREF="stamp.html#SEC7">4.1  Analytic ambiguity delimiter: \ambig</A>.

</P>


<H2><A NAME="SEC21" HREF="stamp.html#TOC21">5.2  Allomorph property declaration: \ap</A></H2>
<P>
<A NAME="IDX32"></A>

</P>
<P>
This field can also occur in the STAMP declarations file or the STAMP
synthesis control file instead; see
section <A HREF="stamp.html#SEC8">4.2  Allomorph property declaration: \ap</A>.

</P>


<H2><A NAME="SEC22" HREF="stamp.html#TOC22">5.3  Category declarations: \ca</A></H2>
<P>
<A NAME="IDX33"></A>

</P>
<P>
This field can also occur in the STAMP declarations file or the STAMP
synthesis control file instead; see
section <A HREF="stamp.html#SEC9">4.3  Category declarations: \ca</A>.

</P>


<H2><A NAME="SEC23" HREF="stamp.html#TOC23">5.4  Category class declaration: \ccl</A></H2>
<P>
<A NAME="IDX34"></A>

</P>
<P>
This field can also occur in the STAMP declarations file or the STAMP
synthesis control file instead; see
section <A HREF="stamp.html#SEC11">4.5  Category class declaration: \ccl</A>.

</P>


<H2><A NAME="SEC24" HREF="stamp.html#TOC24">5.5  Copy rule: \cr</A></H2>
<P>
<A NAME="IDX35"></A>

</P>
<P>
Suppose that a single source language morpheme corresponds to either of
two target language morphemes, where the choice between them is not
determined by any contextual factor within the word.  For example,
Huallaga Quechua -ra `PAST' (simple past) corresponds to two suffixes in
Pasco Quechua, in some cases to -rqU `RECPST' (recent past) and in other
cases to -rqa `REMPST' (remote past).  Whether the recent or remote past
tense is appropriate is a semantic matter, not determinable by any
structural factor, morphological or syntactic.

</P>
<P>
The best one can do in such a case is to create ambiguous output for
every instance of the past tense morpheme and leave the choice between
them to the person who edits the computer-adapted text.  Thus, for every
Huallaga Quechua word containing -ra `PAST' (as in 1 below) the program
should produce two Pasco Quechua words (as in 2), one with -rqU `RECPST'
and the other with -rqa `SIMPST':

<PRE>

1. aywaran
2. %2%aywarqun%aywarqan%

</PRE>

<P>
This can be accomplished by means of a copying rule.  A copying rule
produces two output analyses.  It produces a copy of the input and then
the result of applying the rule as though it were a substitution rule;
see
section <A HREF="stamp.html#SEC47">5.15  Substitution rule: \sr</A>.
The only syntactic difference between a copying rule and a substitution
rule is that the former begins with the field code <CODE>\cr</CODE> and the
latter begins with a <CODE>\sr</CODE>.

</P>

<P>
Returning to the Quechua example, the copying rule in 3 would apply to
the analysis in 4 to produce the two analyses in 5:

<PRE>

3. \cr "PAST" "REMPST"
4. &#60; V1 *aywa &#62; PAST 3
5. %2%&#60; V1 *aywa &#62; PAST 3%&#60; V1 *aywa &#62; REMPST 3%

</PRE>

<P>
Copying rules apply to the output of previous rules in the transfer file,
and subsequent rules apply to each of the outputs.  Because subsequent
rules apply to each of the outputs of a copying rule, it is possible for
copying rules to feed copying rules.  For example, consider the two
hypothetical copying rules in a below.  If these are applied to a single
analysis containing A and Q (as schematized in 7 below), they would
produce the four analyses shown in 9.

<PRE>

6. \cr "A" "B"
   \cr "Q" "R"
7. ...A...Q...
8. %2%...A...Q...%...B...Q...%
9. %4%...A...Q...%...A...R...%...B...Q...%...B...R...%

</PRE>

<P>
That is, the first rule of a produces the two analyses in 8.  Then the
the second rule of a applies to each of these outputs, producing two
outputs for each as in 9.

</P>
<P>
Note that if the original analysis had been ambiguous (with two analyses
each containing A and Q), the two copying rules would have produced an
eight-way ambiguity.  The moral: if copying rules are used too liberally,
there might be a dramatic increase in the levels of ambiguity produced.
Let the user beware!

</P>


<H2><A NAME="SEC25" HREF="stamp.html#TOC25">5.6  Flag rule: \fl</A></H2>
<P>
<A NAME="IDX36"></A>

</P>
<P>
Flags are a mechanism for temporarily remembering some information about
an analysis.  A rule conditioned by one or more flags affects an analysis
only if all the conditions implied by those flags are true for that
analysis.  Flags make it possible to "insulate" source language phenomena
from target language phenomena.

</P>
<P>
The definition of a flag has three obligatory parts: (1) the field code
<CODE>\fl</CODE>, (2) the name of the flag, and (3) the list of morphnames
which trigger the raising of that flag.  For example, consider the
following definition:

<PRE>

\fl PLURAL PLIMPF PLDIR PLSTAT

</PRE>

<P>
The name of the flag is <CODE>PLURAL</CODE>.  The morphnames whose presence
causes the flag to be raised are <CODE>PLIMPF</CODE>, <CODE>PLDIR</CODE>, and
<CODE>PLSTAT</CODE>.

</P>
<P>
Flag definitions are a type of rule.  Recall that rules are applied in
the order in which they are given in the transfer file.  (This excludes
lexical changes, which are applied before all rules.)  Thus, a flag is
raised only if one of the morphnames in its definition is present in the
analysis resulting from all previous rules (in the order they are given
in the transfer file).  For example, the plural flag defined above would
be raised only if <CODE>PLIMPF</CODE>, <CODE>PLDIR</CODE>, or <CODE>PLSTAT</CODE> were
present in an analysis at the point where the rule is defined in the
transfer file.

</P>
<P>
Suppose there are two rules.  The first deletes <CODE>PLIMPF</CODE>.  The next
one is a flag definition which raises the <CODE>PLURAL</CODE> flag whenever
<CODE>PLIMPF</CODE> is present in an analysis.  This flag-raising rule only
sees the result of all previous rules.  Thus it would never raise the
<CODE>PLURAL</CODE> flag in this case, since <CODE>PLIMPF</CODE> would always have
been deleted by the preceding rule.  To get the proper effect, the flag
definition rule should be ordered before the rule which deletes the
morphname that causes the flag to be raised.

</P>
<P>
Flags cannot be used in a rule until they have been defined with a
<CODE>\fl</CODE> field.  Sometimes it is conceptually simpler to define all the
flags at the beginning of the transfer file; in other cases it is
advantageous to define each of them close to--but preceding--the rules
which use them.

</P>
<P>
Flags may be tested in copy and substitution rules following the match
and substitution strings, or in insertion rules following the string to
be inserted.  The flag names must always precede any conditioning
environments.  A flag name can be preceded by tilde to complement the
sense of the flag; that is, a rule so modified applies only if the named
flag is not raised.

</P>
<P>
When a particular analysis has undergone all the rules of the transfer
file, all the flags are automatically lowered before another analysis is
considered.  To put it another way, flags do not stay raised from one
word to another.  Many flags are raised and never lowered until the next
word, but in some cases it is desirable to have the flags lowered before
some subsequent rule.

</P>
<P>
Whenever an analysis changes as the result of a rule that tests a flag
(or flags), then that rule's flags are automatically lowered.  The user
does not have to do anything because TRANSFER is designed to
automatically lower flags under this condition.  This avoids the
application of subsequent rules on the basis of the same flag.  For
example, consider the following rules.  (Insertion rules are discussed in
the next section.)

<PRE>

\fl XFLG M1 M2       |raise flag when M1 or M2 present
\ir "X1" XFLG / M1 _ |insert X1 after M1 when XFLG up
\ir "X2" XFLG / _ M2 |insert X2 before M2 when XFLG up

</PRE>

<P>
Given an analysis with the sequence <CODE>M1 M2</CODE>, the result of these
changes is <CODE>M1 X1 M2</CODE>.  It would not be <CODE>M1 X1 X2 M2</CODE> because,
when the first insertion rule applies, it lowers <CODE>XFLG</CODE>.
Consequently, the second insertion rule does not apply.

</P>
<P>
Suppose one wished to drop a flag (say <CODE>PFLG</CODE>) whenever a particular
morpheme (say <CODE>XY</CODE>) is present in an analysis.  The following rule
would do it.  (Substitution rules are discussed below.)

<PRE>

\sr "XY" "XY" PFLG |substitute XY for XY when PFLG up

</PRE>

<P>
When this rule applies, it produces no net change in the analysis, but it
has the important side effect of dropping the <CODE>PFLG</CODE> flag.

</P>
<P>
Consider the following substitution rule, where the <CODE>FLG</CODE> flag is
followed by three environments:

<PRE>

\sr "XX" "YY" FLG / M1 _ / M2 _ / M3 _

</PRE>

<P>
This is equivalent to the following sequence of rules:

<PRE>

\sr "XX" "YY" FLG / M1 _
\sr "XX" "YY" FLG / M2 _
\sr "XX" "YY" FLG / M3 _

</PRE>

<P>
Note that if the first applies, <CODE>FLG</CODE> is lowered so the second and
third could not apply.  Likewise, if the second applies, the third could
not apply.  Only one rule could possibly apply; transfer's behavior is
the same even when multiple environments are included in a single rule or
spread across several rules.

</P>
<P>
It is possible to limit a rule by a complemented flag, in which case the
rule applies only if the flag is not raised.  For example, definition 1
would raise the flag <CODE>KUFLAG</CODE> when <CODE>REFL</CODE>, <CODE>INTNS</CODE>, or
<CODE>CMPLT</CODE> were present, and rule 2 would insert <CODE>KU</CODE> when
<CODE>KUFLAG</CODE> is not raised and <CODE>INSERTKUFLAG</CODE> is raised:

<PRE>

1. \fl KUFLAG REFL INTNS CMPLT
2. \ir "KU" ~KUFLAG INSERTKUFLAG

</PRE>

<P>
Note that the constraint imposed by each of these flags must be
simultaneously met for the rule to apply.

</P>
<P>
In general, a flag automatically lowers whenever a rule constrained by
that flag applies.  Note, however, that the converse is not true for a
complemented flag that constrains a rule that applies.  If rule 2 above
were to apply, then <CODE>INSERTKUFLAG</CODE> would be lowered but
<CODE>KUFLAG</CODE> would not be affected, that is, it would remain lowered.

</P>
<P>
Flags and morpheme classes have some interesting similarities and
differences.  Both are defined in the same way (but with different field
codes), and both are used as conditions on rules.  They differ, however,
in where they are used in rules: morpheme classes occur in environments,
whereas flags occur between the rule's main part and before any
conditioning environments.  Perhaps the most important difference is one
of persistence.  Once defined, a morpheme class persists until STAMP
finishes; there is simply no way to "undefine" a class.  But flags are
volatile: they are raised when certain morphemes are present in an
analysis and lowered when a rule having the flag applies effectively.

</P>


<H2><A NAME="SEC26" HREF="stamp.html#TOC26">5.7  Insertion rule: \ir</A></H2>
<P>
<A NAME="IDX37"></A>

</P>
<P>
Insertion rules insert morphnames into an analysis.  An insertion rule
may have (in order):

<OL>

<LI>the field code <CODE>\ir</CODE>,

<LI>the morphname to be inserted,

<LI>optionally one or more flags,

<LI>optionally one or more environments into which the morphname should be inserted, and

<LI>a comment.

</OL>

<P>
The insertion string is delimited by some printing character.  The
morphname is inserted into an analysis if all the rule's flags are
raised (or, for complemented flags, not raised) and at least one of
its environments is satisfied (if any are specified).

</P>
<P>
Of the five parts listed above, only the first two are obligatory.
However, an insertion rule comprised only of a field code and the
morphname (without any conditioning flags or environments) would insert
the morphname into every analysis.  The following example has the first
three parts; it would insert <CODE>PL</CODE> whenever the <CODE>PLFLG</CODE> flag is
up:

<PRE>

\ir "PL" PLFLG

</PRE>

<P>
(How transfer determines where to insert <CODE>PL</CODE> is discussed
below.)  The following inserts <CODE>PXT</CODE> immediately after <CODE>BDJ</CODE>:

<PRE>

\ir "PXT" / BDJ _

</PRE>

<P>
The following inserts <CODE>PLDIR</CODE> whenever both the <CODE>PLURAL</CODE> flag
is up and a directional suffix (that is, a member of the class
<CODE>DIR</CODE>) is present.  <CODE>PLDIR</CODE> is inserted immediately following
the directional morpheme.

<PRE>

\ir "PLDIR" PLURAL / [DIR] _

</PRE>

<P>
When an insertion rule has multiple environments, it applies only for the
first environment satisfied by a given analysis.  For example, consider
the following:

<PRE>

\ir "PXT" / BDJ _  / QMR _

</PRE>

<P>
This rule is applied in the following way.  Potential insertion sites in
the current analysis are considered in order from left to right.  At the
first one, if <CODE>BDJ</CODE> occurs to the left, <CODE>PXT</CODE> is inserted, and
nothing more is done by this rule.  If <CODE>BDJ</CODE> does not occur there
but <CODE>QMR</CODE> does, <CODE>PXT</CODE> is inserted and nothing more is done by
this rule.  Failing to find either <CODE>BDJ</CODE> or <CODE>QMR</CODE> to the left,
the potential insertion site is shifted one place to the right and the
process is repeated.  In this way, all potential insertion sites in the
analysis are evaluated until either an insertion is made or there are no
more potential insertion sites in the analysis.  When one of these
conditions is met, the next rule in the transfer file is applied.

</P>
<P>
Each insertion rule may affect an analysis only once.  This prevents
multiple insertions in cases where more than one environment is
satisfied.  For example, consider the following rule:

<PRE>

\ir "X" / _ Y / Z _

</PRE>

<P>
Consider how this affects an analysis with the sequence <CODE>Z Y</CODE>.  Both
environments are satisfied, so if multiple insertions were permitted by a
single rule, the result would be <CODE>Z X X Y</CODE>.  However, the desired
result is more likely to be <CODE>Z X Y</CODE>, which is what the program will
produce.  Note, it is possible to get the former result by using two
rules:

<PRE>

\ir "X" / _ Y
\ir "X" / Z _

</PRE>

<P>
Since there are two rules, both would apply to <CODE>Z Y</CODE>, the first
producing <CODE>Z X Y</CODE>, the second applying to <CODE>Z X Y</CODE> to produce
<CODE>Z X X Y</CODE>.

</P>


<H3><A NAME="SEC27" HREF="stamp.html#TOC27">5.7.1  Flags in insertion rules</A></H3>

<P>
Insertion rules are frequently conditioned by flags; thus some comments
about them are in order.  First, recall the discussion above:
the application of a rule automatically results in the lowering of any
flags in that rule.

</P>
<P>
Second, flags may be complemented by prefixing a tilde (<CODE>~</CODE>).  The
following set of rules illustrates the use of a complemented flag.  It is
motivated by a situation in Quechua, where pluralization with -pakU
occurs only in the absence of other morphemes which have kU.

<PRE>

\fl KUFLG REFL CMPL INTNS |flag for suffixes with kU
\fl PLFLG PL1 PL2         |flag for pluralizers
\sr "PL1" ""              |remove PL1
\sr "PL2" ""              |remove PL2
\ir "PLKU" PLFLG ~KUFLG   |insert if plural and no kU

</PRE>

<P>
The first line defines a flag for suffixes containing kU; the second
defines a flag for pluralizers.  The third and fourth lines delete the
pluralizers.  The last line is a rule that inserts <CODE>PLKU</CODE> if the
<CODE>PLFLG</CODE> is up and the <CODE>KUFLG</CODE> is down, that is, the original
analysis had a pluralizer and no suffix with kU is now present in the
analysis.  If <CODE>PLKU</CODE> is ever inserted by this rule, <CODE>PLFLG</CODE>
will be lowered.

</P>


<H3><A NAME="SEC28" HREF="stamp.html#TOC28">5.7.2  Determining the site for insertion</A></H3>

<P>
If an insertion rule has an environment with a simple environment bar,
then the position of the bar defines the site for insertion.  But when
the rule has no environment, or when the environment bar has ellipsis
marking, then the insertion site is not explicitly defined.  TRANSFER has
mechanisms for treating these cases.

</P>
<P>
Generally, the items to be inserted are either prefixes or suffixes.  In
the absence of an explicit environment statement, prefixes are inserted
somewhere before the leftmost root and suffixes are inserted somewhere
after the rightmost root.  TRANSFER determines whether the morpheme to be
inserted is a prefix or a suffix by determining which dictionary it
occurs in.  (For this reason each affix should have a unique morphname.)
Then it uses the orderclass of the morpheme, as defined in the dictionary
entry, to determine exactly where to insert the morpheme.

</P>
<P>
Consider an insertion rule with no environment, such as the following one
which inserts <CODE>ABC</CODE> whenever <CODE>XYZFLAG</CODE> is raised:

<PRE>

\ir "ABC" XYZFLAG

</PRE>

<P>
TRANSFER determines the orderclass of <CODE>ABC</CODE> from the affix
dictionaries of the target language.  Given an analysis, if the
<CODE>XYZFLAG</CODE> is up at the point this insertion rule is applied,
TRANSFER searches for an acceptable place to put <CODE>ABC</CODE>, attempting
to place it as far right as possible without violating orderclass, that
is, without placing it after an affix with a greater orderclass.  To
illustrate, consider an analysis like the following (with the
orderclasses given below each morphname):

<PRE>

&#60; C1 root &#62; M1 M2 M3 M4 M5
			10 20 30 40 50

</PRE>

<P>
Assuming that the orderclass of <CODE>ABC</CODE> is 40, the result of the
insertion rule would be the following:

<PRE>

&#60; C1 root &#62; M1 M2 M3 M4 ABC M5

</PRE>

<P>
If it is necessary to insert a sequence of morphnames, they can be
inserted by a sequence of insertion rules.  For example, the following
three rules insert <CODE>ABC DEF GHI</CODE> when <CODE>XYZFLAG</CODE> is up:

<PRE>

\ir "ABC" XYZFLAG
\ir "DEF" / ABC _
\ir "GHI" / DEF _

</PRE>

<P>
(A slightly more complicated solution would be needed if there were
analyses containing <CODE>ABC</CODE> or <CODE>DEF</CODE> into which these rules would
incorrectly insert <CODE>DEF</CODE> or <CODE>GHI</CODE>.)  Applied to the previous
example, the result would be:

<PRE>

&#60; C1 root &#62; M1 M2 M3 M4 ABC DEF GHI M5

</PRE>

<P>
Whenever the insertion site is not precisely defined by the environment
bar, insertion will be based on orderclass.  Therefore, ellipsis marking
can be used to constrain an insertion by the presence of one or more
morphnames and yet have the insertion based on orderclass.  For example,
either of the following rules inserts <CODE>PQR</CODE> as far right as possible
without violating orderclass whenever <CODE>M4</CODE> occurs in an analysis:

<PRE>

\ir "PQR" / _... M4
\ir "PQR" / M4 ..._

</PRE>



<H2><A NAME="SEC29" HREF="stamp.html#TOC29">5.8  Lexical change: \lc</A></H2>
<P>
<A NAME="IDX38"></A>

</P>

<UL>
<LI><A HREF="stamp.html#SEC30">Morphnames in lexical changes</A>
<LI><A HREF="stamp.html#SEC31">Categories in lexical changes</A>
<LI><A HREF="stamp.html#SEC32">Delimiters and type in lexical changes</A>
<LI><A HREF="stamp.html#SEC33">Environment conditions on lexical changes</A>
<LI><A HREF="stamp.html#SEC34">Which change applies?</A>
<LI><A HREF="stamp.html#SEC35">Common errors in lexical changes</A>
<LI><A HREF="stamp.html#SEC36">Two examples</A>
<LI><A HREF="stamp.html#SEC37">Where should lexical changes be made?</A>
</UL>

<P>
Lexical changes are similar to the string changes described in the
AMPLE Reference manual section 8.5 or Weber, Black, and McConnel
(1988:79ff), but they differ in several respects.  First, changes are
made to sequences of morphnames rather than to strings.
(Nevertheless, we use "string" in referring to parts of a lexical
change.)  Second, lexical changes must match at least one root.  (In
this they differ from substitution rules, discussed in
section <A HREF="stamp.html#SEC47">5.15  Substitution rule: \sr</A>,
which do not have this limitation.)  Third, lexical changes use a
different type of environment condition: whereas string changes may be
constrained with respect to character strings, lexical changes are
constrained with respect to morphnames.

</P>
<P>
A lexical change may have (in order):

<OL>

<LI>

the field code <CODE>\lc</CODE>;

<LI>the match string, that is, the sequence to be replaced;

<LI>

the substitution string, that is, what should be put in place of the match
string;
<A NAME="IDX39"></A>
<A NAME="IDX40"></A>

<LI>

one or more environments in which the change is to be made; and

<LI>

a comment, initiated by the comment character.
</OL>

<P>
The first three elements are obligatory; the remainder are optional.
For example, the following is an acceptable lexical change:

<PRE>

\lc "sha" "shamu" / _... AFAR |to reorder -mu

</PRE>

<P>
This would change the root sha to shamu whenever it was followed by
the suffix <CODE>AFAR</CODE> somewhere in the analysis.

</P>
<P>
The match and substitution strings must be enclosed by delimiter
characters.  Any printing character can be used as the delimiter (see
Weber, Black, and McConnel 1988:80); the first printable character
after the field code is taken to be the delimiter.  The same delimiter
must be used for both the match and substitution strings.  For
example, the change given above could just as well be expressed as
follows:

<PRE>

\lc @sha@ @shamu@ / _... AFAR |to reorder -mu

</PRE>

<P>
Below, we will use the double quote mark as the delimiter.

</P>
<P>
Only one lexical change is ever made to a given root.  If an
applicable change is discovered, the substitution is made and TRANSFER
proceeds to the next root, if any.  When there are no more roots,
TRANSFER goes on to consider rules.

</P>
<P>
A lexical change must mention at least one root.  (It may have more
than one.)  The change applies only if the root portion of the match
string and the root of an analysis are identical.  Lexical changes
never apply to anything less than a complete morphname, so there is
never a danger of matching a proper substring of a morphname.  For
example, if the root in the match string is ka, this would have no
effect on the root kanta.  Likewise, a change where the match string
contains the root allpa would have no effect on the root
wallpa.

</P>
<P>
Lexical changes included in the transfer file should express facts
about the relationship between the source and target languages; this
is discussed further in
section <A HREF="stamp.html#SEC37">5.8.8  Where should lexical changes be made?</A>.

</P>
<P>
Lexical changes make it possible to handle lexical shifts.  For
example, consider adaptation from Huaraz to Huallaga Quechua.  Both
languages have verbs <CODE>urya-</CODE>, <CODE>aru-</CODE>, and <CODE>yanukU-</CODE> but
their meanings have shifted, so that the following lexical changes are
appropriate:

<PRE>

\lc "yapya"  "urya"    |cultivate
\lc "urya"   "aru"     |work
\lc "aru"    "yanukU"  |cook

</PRE>

<P>
(Subsequently, in SYNTHESIS it is necessary to consult a dictionary
entry for <CODE>yanukU</CODE>, which has allomorphs <CODE>yanuku</CODE> and
<CODE>yanuka</CODE>, the choice being determined by properties and tests.)

</P>


<H3><A NAME="SEC30" HREF="stamp.html#TOC30">5.8.1  Morphnames in lexical changes</A></H3>

<P>
The match string of a lexical change must match -- morphname by
morphname -- the portion of any analysis to which it should apply.
Whenever there is some doubt about the exact form of morphnames in the
analysis of some word, the user should inspect an actual analysis
produced by AMPLE.

</P>
<P>
It is possible to use morpheme classes in the match string of a
lexical change.  This is useful to change various forms of a root into
a single form.  For example, in Huallaga Quechua,
`write' is written in at least four different ways; therefore changing
these to a single target language form could be accomplished by four
lexical changes.

<PRE>

\lc "eskirbi" "*qillqa" |write
\lc "eskribi" "*qillqa" |write
\lc "iskirbi" "*qillqa" |write
\lc "iskribi" "*qillqa" |write

</PRE>

<P>
However, if a morpheme class <CODE>WRITE</CODE> contains <CODE>eskirbi</CODE>,
<CODE>eskribi</CODE>, <CODE>iskirbi</CODE>, and <CODE>iskribi</CODE>, then the changes
can be made by a single lexical change which uses the class name
enclosed in square brackets:

<PRE>

\lc "[WRITE]" "*qillqa" |write

</PRE>

<P>
Morpheme classes can also be used in morpheme environment constraints,
as illustrated below.  They cannot be used in the substitution string,
since the desired result of the change would not be uniquely
determined.

</P>


<H3><A NAME="SEC31" HREF="stamp.html#TOC31">5.8.2  Categories in lexical changes</A></H3>

<P>
Each root may be accompanied in the match string by a category.  An
analysis will be changed only if explicit categories in the match
string are identical to those of the corresponding roots in the
analysis.

</P>
<P>
For example, consider Huallaga Quechua <CODE>muru</CODE>, an "ambivalent"
root: as a noun it means `seed', but as a verb it means `to plant
seeds'.  In some other Quechua languages, these correspond to the noun
root <CODE>semi:lla</CODE> `seed' (where colon represents vowel length) and
the verb root <CODE>muru</CODE> `plant or scatter seeds'.  The change of
<CODE>muru</CODE> to <CODE>semi:lla</CODE> must therefore be conditioned to apply
only when <CODE>muru</CODE> is a noun:

<PRE>

\lc "N0 *muru" "semi:lla"

</PRE>

<P>
If the category had not been included in the match string, all cases
of <CODE>muru</CODE> would be changed, giving many incorrect results.

</P>
<P>
The category is generally optional.  Therefore to change a sequence of
roots, the category between them may be present or absent.  For
example, to change <CODE>bathroom</CODE> (analyzed as in <I>a</I>) to <CODE>john</CODE>,
either <I>b</I> or <I>c</I> would work:

<PRE>

a. &#60; N bath N room &#62;
b. \lc "bath N room" "john"
c. \lc "bath room" "john"

</PRE>

<P>
Here -- as elsewhere -- if the category is not stated, the change is
simply not constrained by category; thus, <I>b</I> would apply only when
room was analyzed as a noun (category <CODE>N</CODE>) whereas <I>c</I> would
change room regardless of its category.

</P>
<P>
It is possible to include category classes in the match strings of
lexical changes. Before the class can be used, the categories it
contains must be declared (see
section <A HREF="stamp.html#SEC11">4.5  Category class declaration: \ccl</A>)
and the class must be
defined (see
section <A HREF="stamp.html#SEC9">4.3  Category declarations: \ca</A>)
For example, suppose that <CODE>kalap</CODE>
could be a noun (<CODE>N</CODE>), an intransitive verb (<CODE>V1</CODE>), or a
transitive verb (<CODE>V2</CODE>), and suppose that we wish to change
<CODE>kalap</CODE> to <CODE>pakla</CODE> only when it is a verb.  Further assume
that the category class <CODE>VERB</CODE> has been defined in the STAMP
declarations file as follows:

<PRE>

\ccl VERB V1 V2

</PRE>

<P>
Then the lexical change <I>a</I> (below) would apply to the analyses of
<I>b</I> and <I>c</I>, but not to that of <I>d</I>:

<PRE>

a. \lc "[VERB] kalap" "pakla"
b. &#60; V1 kalap &#62;
c. &#60; V2 kalap &#62;
d. &#60; N kalap &#62;

</PRE>

<P>
It is possible to change a root's category by including a new category
in the substitution string.  This might be useful when the target
language does not make the same categorial distinctions as the source
language.  For example, if the source language distinguishes nouns and
adjectives but the target language has a single class of substantives,
the following change might be useful:

<PRE>

\lc "A0 hatun" "S0 hatun" |big

</PRE>

<P>
Note that neither categories nor category classes can be included in
an environment conditioning a lexical change.

</P>
<P>
In the substitution string, when a root is given without an
accompanying category, the following rules determines its category:

<OL>
<LI>If it corresponds to a root in the match string, assign it the

category of that root.
<LI>If not, and if there are one or more roots in the match string, assign

it the category of the first one.
<LI>If there are no roots in the match string, assign it the first

category declared with <CODE>\ca</CODE>.
</OL>

<P>
For example, consider the following lexical changes:

<PRE>

a. \lc "&#60; N aibcud &#62; SX1" "paqur"
b. \lc "&#60; N aibcud &#62; SX1" "PSTPRF paqur"
c. \lc "&#62; SX1 SX2" "&#60; paqur &#62;"

</PRE>

<P>
In <I>a</I>, <CODE>paqur</CODE> would be assigned category <CODE>N</CODE> by the
first rule above because it corresponds to <CODE>aibcud</CODE>, which has
category <CODE>N</CODE>.  In <I>b</I>, <CODE>PSTPRF</CODE> would be taken as a root
corresponding to <CODE>aibcud</CODE> and assigned the category <CODE>N</CODE> by
the first rule above.  By conventions explained in
section <A HREF="stamp.html#SEC32">5.8.3  Delimiters and type in lexical changes</A>,
<CODE>paqur</CODE> would also be taken to be a root; since it does not
correspond to a root in the match string, the second rule above
assigns it the category of the first root in the match string, namely,
<CODE>N</CODE>.  In <I>c</I>, <CODE>paqur</CODE> is a root (as forced by the wedges,
see
section <A HREF="stamp.html#SEC32">5.8.3  Delimiters and type in lexical changes</A>)
but there is no root in the match string;
therefore, by the third rule above, <CODE>paqur</CODE> would be assigned
whatever category was declared first.

</P>
<P>
Note that mentioning a category always forces the following morphname
to be a root of the given category.  Thus, if the substitution string
contains "<CODE>...Npaqur...</CODE>", where <CODE>N</CODE> is a category,
then no matter what the match string is, or what precedes or follows
it in the substitution string, <CODE>paqur</CODE> is a root of category
<CODE>N</CODE>.

</P>


<H3><A NAME="SEC32" HREF="stamp.html#TOC32">5.8.3  Delimiters and type in lexical changes</A></H3>

<P>
The match string of a lexical change may contain the characters that
mark the boundaries between prefixes and roots, for which "&#60;" is the
default, and between roots and suffixes, for which "&#62;" is the
default.  (In the following discussion we simply use these default
values.)  For example, in some Quechua languages, `to leave' is
expressed by the root <CODE>ya-</CODE> followed by the suffix <CODE>-rqU</CODE>
`OUT', whereas others use the root <CODE>lluqshi-</CODE>.  Either of the
following would make this change:

<PRE>

\lc "ya &#62; OUT" "lluqshi" |leave
\lc "ya OUT"   "lluqshi" |leave

</PRE>

<P>
Likewise, if a prefix is included, the wedge and intervening category
may be included:
changes;

<PRE>

\lc "CAUSE &#60; Vi die" "Vt kill"

</PRE>

<P>
Note that it is not necessary to keep these delimiters balanced; this
change is acceptable even though the match string does not have a
corresponding right wedge.

</P>
<P>
Using wedges in the match string forces the morphnames to be assigned
a type (prefix, root, or suffix) according to the following rules:

<OL>
<LI>Any morphname to the left of <CODE>&#60;</CODE> is a prefix.

<LI>Any morphname to the right of <CODE>&#62;</CODE> is a suffix.

<LI>Otherwise, a morphname is a root.

</OL>

<P>
For a lexical change to apply, the morphnames matched in the analysis
must be consistent as to type with the corresponding morphnames in the
match string.  Furthermore, the boundaries must be present in the
analysis at the place indicated by the delimiter in the match string.
For example, consider the following:

<PRE>

a. \lc "room" "chamber"
b. \lc "N room" "chamber"
c. \lc "&#60; N room &#62;" "chamber"
d. &#60; N room &#62;
e. &#60; N bath N room &#62;

</PRE>

<P>
Changes <I>a</I>, <I>b</I>, and <I>c</I> would apply to the analysis in <I>d</I>,
changing <CODE>room</CODE> to <CODE>chamber</CODE>.  However, if <CODE>bathroom</CODE>
is analyzed as in <I>e</I>, only <I>a</I> and <I>b</I> would change it to
<CODE>bathchamber</CODE>.  Change <I>c</I> does not apply because the left
wedge in the change does not correspond to a wedge in the analysis.

</P>
<P>
We now turn to the substitution string and how its morphemes are
assigned type.  The general rule is this: counting from the left, the
morphnames of the substitution string are assigned the type of the
corresponding morphname in the match string.  For example, consider
the following lexical change:

<PRE>

\lc "PX &#60; N abcd &#62; SX1" "PY efg SY1 SY2"

</PRE>

<P>
<CODE>PY</CODE> is a prefix because <CODE>PX</CODE> (the corresponding morphname
in the match string) is a prefix; <CODE>efg</CODE> is a root because
<CODE>abcd</CODE> is a root; and <CODE>SY1</CODE> is a suffix because <CODE>SX1</CODE>
is a suffix.

</P>
<P>
And what of <CODE>SY2</CODE>?  For such cases there is another rule:
morphnames in a substitution string for which there are no
corresponding morphnames in the match string (which arise when the
substitution string is longer than the match string) are assigned the
type of the last morphname in the match string.  Thus, since
<CODE>SX1</CODE> is a suffix, <CODE>SY2</CODE> is also a suffix.

</P>
<P>
Wedges can be used in the substitution string to force morphnames to a
particular type.  The rules are the same as those given above for the
match string: anything to the left of <CODE>&#60;</CODE> is a prefix, and anything to
the right of <CODE>&#62;</CODE> is a suffix.

</P>
<P>
In formulating lexical changes, it is probably wise to err on the side
of being too specific (that is, to include wedges and categories where
they are not necessarily needed) rather than to depend entirely on
STAMP's built-in rules.  Explicitness makes the user's intentions more
intelligible to those who must subsequently read and understand the
data files, including the person who first created them!

</P>


<H3><A NAME="SEC33" HREF="stamp.html#TOC33">5.8.4  Environment conditions on lexical changes</A></H3>

<P>
A lexical change may be restricted by a morpheme environment
constraint; see Weber, Black, and McConnel (1988:74).  For example,
the following would change <CODE>allcha</CODE> to <CODE>kacha</CODE> only if
<CODE>PASS</CODE> (a passive suffix) immediately follows:

<PRE>

\lc "allcha" "kacha" / _ PASS |get well

</PRE>

<P>
The environment may contain multiple conditions; for example, in the
following, <CODE>hata</CODE> becomes <CODE>shaya</CODE> if followed by the
morphname <CODE>UP</CODE> or by <CODE>SUD</CODE>:

<PRE>

\lc "hata" "shaya" / _ UP  |hata-rI-  to shaya-rI-
				   / _ SUD |hata-ykU- to shaya-ykU-

</PRE>

<P>
And environments may contain morpheme classes; for example, if a
morpheme class called <CODE>FORCE</CODE> contains <CODE>UP</CODE> and <CODE>SUD</CODE>,
then the previous change could be stated as follows:

<PRE>

\lc "hata" "shaya" / _ [FORCE] |hata-rI-, hata-ykU-

</PRE>

<P>
An environment may not contain a category, a category class, or a
wedge.  To change <CODE>bath</CODE> to <CODE>wash</CODE> only in the context of
<CODE>room</CODE> (whereby <CODE>bathroom</CODE> would become <CODE>washroom</CODE>),
one is tempted to formulate the change as follows:

<PRE>

\lc "bath" "wash" / _ N room |**INCORRECT**

</PRE>

<P>
However, this is not correct because the environment contains the
category <CODE>N</CODE>.  The change must be given as follows:

<PRE>

\lc "bath N room" "wash N room"

</PRE>

<P>
One might also be tempted to write a rule like the following:

<PRE>

\lc "bath N" "wash" / _ room |**INCORRECT**

</PRE>

<P>
This, too, is not correct because a category can be used only
accompanied by the root for which it is a category.  In this rule,
<CODE>N</CODE> occurs in the match string without the word for which it is
the category.

</P>


<H3><A NAME="SEC34" HREF="stamp.html#TOC34">5.8.5  Which change applies?</A></H3>

<P>
If two or more lexical changes could apply to the same analysis, the
most specific should apply.  STAMP determines the most specific change
by assigning each change a weight as follows.  For each morpheme in
the match string (whether a root or an affix), add 100 points.  For
each root, add 50 if it is accompanied by a category or 25 if it is
accompanied by a category class.  Finally, add 150 if the change
contains one or more morpheme environment constraints.  The change
with the greatest number of points is judged to be the most specific,
and is thus applied in preference to changes with fewer
points.

</P>
<P>
For example, the following changes would have the number of points indicated:

<PRE>

\lc "igmo" "ingo"               |total points = 100
\lc "[AMBIV] igmo" "vago"       |total points = 125
\lc "N0 igmo" "vago"            |total points = 150
\lc "igmo &#62; BEC" "vago BEC"     |total points = 200
\lc "igmo" "vago" / _ BEC       |total points = 250
\lc "N anza V misi" "V anzasi"  |total points = 300

</PRE>

<P>
Only one lexical change ever applies to a single root.  However, if an
analysis has multiple roots, each could be modified by a different
lexical change.  For example, given changes <I>a</I> and <I>b</I>, analysis
<I>c</I> would become <I>d</I>:

<PRE>

a. \lc "alla" "oqti"  |dig
b. \lc "papa" "aqshu" |potato
c. &#60; N papa V alla &#62; PROG PAST 3
d. &#60; N aqshu V oqti &#62; PROG PAST 3

</PRE>

<P>

</P>


<H3><A NAME="SEC35" HREF="stamp.html#TOC35">5.8.6  Common errors in lexical changes</A></H3>

<P>
Capitalization is significant.  Roots must be in upper or lower case,
exactly as they appear in the analysis.  (This usually comes from the
etymology field of the source language dictionary.)  Likewise, affix
morphnames must be upper or lower case, exactly as they appear in the
analysis.  Users will make fewer errors of case if they follow some
convention, such as putting all roots entirely in lower case and all
affix morphnames entirely in upper case.

</P>
<P>
If the root of an analysis has a regular sound change identifier (see
section 7.2.3.2), then the match string of a change applying to it
must include that character.  Conversely, if the root does not have
such a character, the match string of a change applying to the
analysis must not have it.  For example, consider an analysis as in
<I>a</I> and changes as in <I>b</I> through <I>e</I>:

<PRE>

a. &#60; N0 *qasqu &#62;
b. \lc       "qasqu"        "pe:chu"
c. \lc      "*qasqu"        "pe:chu"
d. \lc   "N0 *qasqu"     "N0 pe:chu"
e. \lc "&#60; N0 *qasqu &#62;" "&#60; N0 pe:chu &#62;"

</PRE>

<P>
The change in <I>b</I> cannot apply because its match string does not
contain an asterisk, while the analysis in <I>a</I> does.  By contrast,
any of changes <I>c</I> through <I>e</I> would match the analysis in <I>a</I>
and change the root.

</P>


<H3><A NAME="SEC36" HREF="stamp.html#TOC36">5.8.7  Two examples</A></H3>

<P>
This section contains two examples.  The first serves to review many
points about lexical changes.  The second is a complete list of the
lexical changes for an actual language pair.

</P>
<P>
For the first example, consider the analysis in <I>a</I>:

<PRE>

a. M1 &#60;C1 root1 C2 root2&#62; M2

</PRE>

<P>
Either <I>b</I> or <I>c</I> would change this to <I>d</I>:

<PRE>

b. \lc "root2 &#62; M2" "root3 &#62; M2"
c. \lc "root2" "root3" / _ M2
d. M1 &#60; C1 root1 C2 root3 &#62; M2

</PRE>

<P>
Any of <I>e</I> through <I>j</I> (among other possibilities) would change
the two roots of <I>a</I> to <CODE>root3</CODE>, yielding the analysis in
<I>k</I>:

<PRE>

e. \lc "root1 root2"           "root3"
f. \lc "&#60; root1 root2 &#62;"       "root3"
g. \lc "C1 root1 root2"        "root3"
h. \lc "&#60; root1 C2 root2"      "root3"
i. \lc "C1 root1 C2 root2"     "root3"
j. \lc "&#60; C1 root1 C2 root2 &#62;" "root3"
k. M1 &#60; C1 root3 &#62; M2

</PRE>

<P>
Change <I>l</I> would change <I>a</I> to the analysis in <I>m</I>, in which the
second root and the first suffix become a single root, namely,
<CODE>root3</CODE>:

<PRE>

l. \lc "root2 &#62; M2" "root3"
m. M1 &#60; C1 root1 C2 root3 &#62;

</PRE>

<P>
Likewise, <I>n</I> would change the analysis to <I>o</I>, in which the second root
and the first suffix become a single suffix, namely, <CODE>MX</CODE>:

<PRE>

n. \lc "root2 &#62; M2" "&#62; MX"
o. M1 &#60; C1 root1 &#62; MX

</PRE>

<P>
Note that the wedge (<CODE>&#62;</CODE>) in the substitution string of <I>n</I>
forces TRANSFER to treat <CODE>MX</CODE> as a suffix.  If this wedge were
omitted, <CODE>MX</CODE> would be treated as a root, since counting from the
left it corresponds to a root.

</P>
<P>
Either <I>p</I> or <I>q</I> would change <I>a</I> to the analysis in <I>r</I>, in
which the second prefix and the first root become a single root
(namely, <CODE>root4</CODE>):

<PRE>

p. \lc "M1 &#60; root1"    "root4"
q. \lc "M1 &#60; C1 root1" "root4"
r. &#60;C1 root4 C2 root2 &#62; M2

</PRE>

<P>
Note that the category of <CODE>root4</CODE> is the same as that of
<CODE>root1</CODE>, since no category is given in the substitution string of
these changes.

</P>
<P>
The second example is given below, which contains
the lexical changes used to adapt from Huallaga Quechua to Huamalies
Quechua.  To facilitate managing these changes, it is convenient to
organize them alphabetically by the root of the match string.  This is
achieved by aligning the first character of the roots (excluding the
asterisk identifying Proto-Quechua roots) and thenperiodically
sorting the list on the column in which the roots begin (using the
appropriate switch with a sort program).

</P>

<PRE>
TRANSFER lexical changes for Huallaga to Huamalies Quechua

\co Huallaga to Huamalies Quechua lexical changes
\lc    "[WRITE]"      "*qillqa"          |eskirbi eskribi etc.
\lc "N0  a:bi"        "*pishqu"          |bird
\lc    "*allcha"      "*katra" / _ PASS  |get well
\lc     "awturida:"   "awturda:"         |authority
\lc "N0  corte"       "konsehu"          |council
\lc     "empleada"    "ashmay"           |servant
\lc     "fista"       "fyesta"           |fiesta
\lc "N0  fiyu &#62; GEN"  "R0 siqaypa"       |really
\lc "N0  ga:llu"      "kakash"           |rooster
\lc "V1 *hata &#62; PNCT" "*shaya &#62; UP"      |hata-rI- &#62; sha-rkU-
\lc "V1 *hata"        "*itri" / _ UP     |hata-rkU- &#62; ichi-rkU-
\lc    "*hawa"        "*waqta"           |outside
\lc    "*huknaylla"   "*hukllaylla"      |unique
\lc "V2  insulta"     "*ashlli"          |insult
\lc "V2 *kama"        "alista"           |prepare
\lc "N0  kantu"       "kuchu"            |bank
\lc "N0  korte"       "konsehu"          |council
\lc "N0 *llachapa"    "mu:dana"          |clothes
\lc    "*lluqshi"     "*ya &#62; OUT"        |leave
\lc "V1 *mallwa"      "*hama"            |sit
\lc    "*manacha:"    "manasay"          |(contrastive)
\lc "V2 *matanka"     "umbru"            |carry on shoulder
\lc     "mawka"       "makwa"            |worn out
\lc     "mayistru"    "mayestru"         |teacher
\lc     "mu:su"       "maqta"            |young man
\lc     "pakilla:"    "pa:kila:"         |thanks
\lc     "parasimri"   "imayyaqpis"       |forever, eternal
\lc     "pare:hu"     "patinti"          |be similar
\lc     "patinti"     "patenti"          |tax
\lc    "*patra"       "posa:da" / _ CAUS |give lodging
\lc     "primer"      "punta &#62; OBJ"      |first
\lc "N0 *puyn~u"      "*uyllu"           |jug
\lc    "*qaqlla"      "ka:ra"            |face
\lc "V1 *qatrwa"      "tu*na"            |dance (verb)(u* = uu)
\lc "N0 *qatrwa"      "tushu"            |dance (noun)
\lc     "reda"        "red"              |net
\lc     "rey"         "ray"              |king
\lc    "*rima"        "parla"            |say
\lc    "*siksik"      "suksuk"           |tremble
\lc     "tra:pu"      "ratash"           |rag
\lc     "tu:ka"       "tuka"             |to play (instrument)
\lc "V2 *uywa"        "*ashma"           |to raise
\lc     "werta"       "*qintra"          |garden
\lc    "*yanqa"       "wala:"            |in vain
\lc    "*yarqa:"      "*miku &#62; DES"      |be hungry
\lc    "*yaykU"       "*ya &#62; IN"         |enter
</PRE>

<P>
Note that the order in which the lexical changes are listed in the
file is not relevant to the program.  Recall, from
section <A HREF="stamp.html#SEC26">5.7  Insertion rule: \ir</A>,
that if more than one lexical change could match the current analysis,
the most specific one is applied.

</P>


<H3><A NAME="SEC37" HREF="stamp.html#TOC37">5.8.8  Where should lexical changes be made?</A></H3>

<P>
It is natural to ask why lexical changes can be made both by TRANSFER
and by SYNTHESIS.  The reason lies in how we wish to organize the
data.  A reasonable distribution of the data to the transfer and
synthesis files can make these files much more linguistically and
computationally useful.

</P>
<P>
For linguistic purposes, the files are more useful if all information
of a certain type, or about a certain topic, is localized in a single
place.  It would be unfortunate, for example, if information about the
target language were distributed through transfer and synthesis files,
or if information about the relationship of the source and target
languages were mixed in with the synthesis files.

</P>
<P>
For computational purposes, a careful distribution of information can
make the files more reusable.  The same synthesis file can be used
when adapting from different source languages if it contains only
information about the target language.  The transfer file can be more
easily reversed when adapting in the other direction if it includes
only information about the relationship between the source and target
languages.

</P>
<P>
Lexical changes can be used to express two types of fact: facts about
the relationship between two languages, and facts about the
distinctives of the target language.  The former should be given in
the transfer file and the latter should be given in the synthesis
file.  For example, the following are about the relationship between
two languages, so they should be given in the transfer file:

<PRE>

\lc "V1 *aru"    "V1 *urya" |work
\lc "V2 *yanuku" "V2 *aru"  |cook
\lc "*lluqshi"   "*ya OUT"  |go out

</PRE>

<P>
These change one root to another.  Of course, this list would be quite
different for each pair of source and target languages.

</P>
<P>
By contrast, the following express facts about the distinctives of the
target language, so they should be given in the synthesis file:

<PRE>

\lc "eskwela"    "eskuyla"        |exceptional loan
\lc "V1 GETWELL" "V1 *kacha PASS" |recover from illness
\lc "*killa"     "killa"          |block *ll to l

</PRE>

<P>
The first indicates the peculiar borrowing of Spanish <CODE>escuela</CODE>,
where closely-related languages have <CODE>eskwela</CODE>.  The second
indicates how this language expresses `recovery from illness'.  The
third indicates that <CODE>*killa</CODE> is an exception to the RSC
<CODE>ll</CODE> to <CODE>l</CODE> (a case to which we return later).  Note that
these changes are likely to be relevant no matter what the source
language is, and thus belong in the synthesis file.

</P>
<P>
The following subsections give guidelines for determining where a
change should be placed.  For many cases, the decision may seem rather
subjective, but with experience the user will gain an understanding of
the distinction.

</P>


<H4><A NAME="SEC38" HREF="stamp.html#TOC38">5.8.8.1  In the transfer file</A></H4>

<P>
When considering the inclusion of a change in the transfer file, the following questions should be asked:

<OL>

<LI>Does the change express a fact about the relationship between

languages?  If so, then it belongs in the transfer file.  If, however,
it expresses a fact about the target language (for example, how a loan
has been assimilated in the target language or an exception to a
regular sound change in the target language) then the change belongs
in the synthesis file.

<LI>Does the change mediate between pan-dialectal normal forms?  For

native vocabulary, the pan-dialectal normal forms might be
reconstructed proto-forms; for borrowed vocabulary, they might be the
forms of the language from which each word is borrowed.  Changes
mediating between pan-dialectal normal forms belong in the transfer
file.

<LI>Is the change reversible?  That is, if the match and substitution

strings were reversed, would the change serve for adapting in the
other direction?  By and large, changes which belong in the transfer
file are reversible.  However, this criterion is not absolute; for
example, if two lexical items are changed to a single one, simply
reversing both changes will probably not give the desired result in
the reverse adaptation path.

</OL>

<P>
For example, suppose that for `money', the source language has
<CODE>qillay</CODE> and the target has <CODE>qullqi</CODE>, which is not cognate
with <CODE>qillay</CODE>.  To introduce this change, the following lexical
change would be used:

<PRE>

\lc "*qillay" "*qullqi"

</PRE>

<P>
By all the above-mentioned criteria, the change of <CODE>*qillay</CODE> to
<CODE>*qullqi</CODE> belongs in the transfer file: it expresses a fact about
the relationship between the two languages, it mediates between two
pan-Quechua normal forms, and it is reversible.

</P>
<P>
By the way, it would be possible to make <CODE>qillay</CODE> become
<CODE>qullqi</CODE> by giving <CODE>*qullqi</CODE> as the etymology for
<CODE>qillay</CODE> in the source language dictionary.  However, this would
be an extremely bad solution because, first, it would distort the
etymology of <CODE>qillay</CODE> in the source language dictionary since
<CODE>qullqi</CODE> is not the etymology of <CODE>qillay</CODE>, and second, it
would keep a fact about the relationship between the source and target
languages from being given in the transfer file.

</P>


<H4><A NAME="SEC39" HREF="stamp.html#TOC39">5.8.8.2  In the synthesis file</A></H4>

<P>
 When considering the inclusion of a change in the synthesis file, the
following questions should be asked:

<OL>

<LI>Does it express a fact about a distinctive of the target language?  Or

to put it another way, does the change mediate between a pan-dialectal
normal form and the corresponding form in the target language?  If so,
the change belongs in the synthesis file.

<LI>Does the change contain any information about the source language?  If

so, it does not belong in the synthesis file.  The synthesis file
should not contain information about the source language because
ideally it would be used regardless of the language from which texts
are being adapted.

<LI>Would the change be appropriate for adapting from a language to

itself?  Imagine analyzing a text, whereby each root comes to be
represented by its pan-dialectal normal form, and then synthesizing
the text back to the same language, using only SYNTHESIS and TEXTOUT.
(That is, no transfer file would be loaded.)  If the change under
consideration would not contribute to this process, it probably
belongs in the transfer file.

</OL>

<P>
Returning to the case of <CODE>qellay</CODE> discussed in the previous
section, it would be possible to include the change of <CODE>*qillay</CODE>
to <CODE>*qullqi</CODE> in the synthesis file.  However, this would violate
all the above-mentioned criteria.

</P>


<H4><A NAME="SEC40" HREF="stamp.html#TOC40">5.8.8.3  Using both the transfer and synthesis files</A></H4>

<P>
The previous sections describe criteria for whether a change should be
made in the transfer file or in the synthesis file.  In this section
we will show that even for a single change it is sometimes best to
distribute the information across both files.  To show this, we
consider a single example, that of adapting North Junin Quechua
<CODE>yarpun</CODE> `he goes down' to Wanka Quechua, where the corresponding
form is <CODE>hiyalpun</CODE>.

</P>
<P>
If there were nothing to consider beyond getting the change made,
there would be many ways to do it.  But if we consider factors such as
the flexibility for adapting to and from other languages, the ease of
reversing the direction of adaptation, and the value of the data files
as representing linguistic realities, then we are lead to one solution
which seems better than the rest.

</P>
<P>
North Junin <CODE>yarpu-</CODE> analyzes as <CODE>ya DWN</CODE> (that is, as
<CODE>ya-rpU-</CODE>).  One possibility is to make the following change in
the transfer file:

<PRE>

\lc "*ya DWN" "hiyalpu"

</PRE>

<P>
However, this would not be reversible, since Wanka <CODE>hiyalpu-</CODE>
should analyze as the root <CODE>hiya-</CODE> and the suffix <CODE>-lpu</CODE>
`DWN'.  So let's consider another possibility:

<PRE>

\lc "*ya DWN" "hiya DWN"

</PRE>

<P>
However, this fails to capture a significant fact, namely, that
<CODE>hiya</CODE> is the Wanka reflex of Proto-Quechua <CODE>*hiqa</CODE>.  (Wanka
has undergone RSCs which eliminate /<CODE>*q</CODE>/; /<CODE>y</CODE>/ is inserted
between /<CODE>i</CODE>/ and /<CODE>a</CODE>/ to maintain syllable structure.)  In
light of this, another way to make the change is as follows:

<PRE>

\lc "*ya DWN" "*hiqa DWN"

</PRE>

<P>
We count on the Wanka synthesis file to contain whatever is necessary
to produce Wanka <CODE>hiya</CODE> from Proto-Quechua <CODE>*hiqa</CODE> (for
example, a RSC which deletes <CODE>q</CODE> followed by a change of
<CODE>ia</CODE> to <CODE>iya</CODE>).  Of course, such changes would be needed
independently.

</P>
<P>
The example below summarizes the steps by which <CODE>yarpun</CODE> becomes
<CODE>hiyalpun</CODE> using this final formulation.  This approach is
superior to the former ones because it meets our criteria of
flexibility, reversibility, and linguistic integrity.

<PRE>

North Junin yarpun to Wanka hiyalpun
		North Junin Quechua input:          yarpun
											  |
		ANALYSIS                              v
										  *ya  DWN 3
		TRANSFER                              v
										 *hiqa DWN 3
				  |regular sound change       v
		SYNTHESIS |                       hiya DWN 3
				  |allomorph selection        |
											  v
		Wanka Quechua output:              hiyalpun

</PRE>



<H2><A NAME="SEC41" HREF="stamp.html#TOC41">5.9  Maximum number of properties: \maxprops</A></H2>
<P>
<A NAME="IDX41"></A>

</P>
<P>
This field can also occur in the STAMP declarations file or the STAMP
synthesis file instead; see
section <A HREF="stamp.html#SEC12">4.6  Maximum number of properties: \maxprops</A>.

</P>


<H2><A NAME="SEC42" HREF="stamp.html#TOC42">5.10  Morpheme class declaration: \mcl</A></H2>
<P>
<A NAME="IDX42"></A>

</P>
<P>
This field can also occur in the STAMP declarations file or the STAMP
synthesis control file instead; see
section <A HREF="stamp.html#SEC13">4.7  Morpheme class declaration: \mcl</A>.

</P>


<H2><A NAME="SEC43" HREF="stamp.html#TOC43">5.11  Morpheme property declaration: \mp</A></H2>
<P>
<A NAME="IDX43"></A>

</P>
<P>
This field can also occur in the STAMP declarations file or the STAMP
synthesis control file instead; see
section <A HREF="stamp.html#SEC14">4.8  Morpheme property declaration: \mp</A>.

</P>


<H2><A NAME="SEC44" HREF="stamp.html#TOC44">5.12  Punctuation class: \pcl</A></H2>
<P>
<A NAME="IDX44"></A>

</P>
<P>
This field can also occur in the STAMP declarations file or the STAMP
synthesis file instead; see
section <A HREF="stamp.html#SEC15">4.9  Punctuation class: \pcl</A>.

</P>


<H2><A NAME="SEC45" HREF="stamp.html#TOC45">5.13  Root delimiter: \rd</A></H2>
<P>
<A NAME="IDX45"></A>

</P>
<P>
This field can also occur in the STAMP declarations file or the STAMP
synthesis control file instead; see
section <A HREF="stamp.html#SEC16">4.10  Root delimiter: \rd</A>.

</P>


<H2><A NAME="SEC46" HREF="stamp.html#TOC46">5.14  String class declaration: \scl</A></H2>
<P>
<A NAME="IDX46"></A>

</P>
<P>
This field can also occur in the STAMP declarations file or the STAMP
synthesis control file instead; see
section <A HREF="stamp.html#SEC17">4.11  String class declaration: \scl</A>.

</P>


<H2><A NAME="SEC47" HREF="stamp.html#TOC47">5.15  Substitution rule: \sr</A></H2>
<P>
<A NAME="IDX47"></A>

</P>
<P>
Substitution rules are similar to the string changes described in
Weber, Black, and McConnel (1988:79ff), but they differ in two
respects.  First, changes are made to sequences of morphnames rather
than to strings.  (Nevertheless, we use "string" in referring to
parts of a substitution rule.)  Second, they use a different type of
environment condition.  Whereas string changes may be constrained with
respect to character strings, conditions on substitution rules may be
constrained with respect to morphnames, flags, or some combination of
these.

</P>
<P>
Substitution rules may have (in order):

<OL>

<LI>the field code <CODE>\sr</CODE>,

<LI>the match string,

<LI>the substitution string

<LI>one or more flags,

<LI>one or more environments, and

<LI>a comment.

</OL>

<P>
The match and substitution strings are delimited by some printing
character, as described above in
section <A HREF="stamp.html#SEC29">5.8  Lexical change: \lc</A>
(see also Weber, Black, and McConnel (1988:80).  When the match string
is found in an analysis, it is replaced by the substitution string if
all the rule's flags are raised (or, for complemented flags, not
raised) and at least one of its environments is satisfied (if any are
specified).

</P>
<P>
Of the six parts listed above, only the first three are obligatory.
Thus the following is an acceptable rule to change every instance of
<CODE>3PST</CODE> (in every analysis) to <CODE>PAST3</CODE>:

<PRE>

\sr "3PST" "PAST3"

</PRE>

<P>
Here, every case of <CODE>3PST</CODE> is changed because the rule is not
conditioned.  Such rules are useful in cases where affixes which
correspond between the source and target languages have different
morphnames.

</P>
<P>
Anything between the match and substitution strings is ignored.
Therefore, any characters may be included there, such as the word
"becomes" or an arrow:

<PRE>

\sr "3PST" --&#62; "PAST3"

</PRE>

<P>
As with lexical changes, the match and substitution strings of
substitution rules may contain the markers indicating the beginning or
end of the root portion of an analysis (for which the defaults are
<CODE>&#60;</CODE> and <CODE>&#62;</CODE>).  These can be used to force morphnames to be
assigned a certain type: prefix, root, or suffix.  For example, rule
<I>a</I> would apply to a root and a suffix, while rules <I>b</I> and <I>c</I>
would apply to a prefix and a root:

<PRE>

a. \sr "*ya &#62; OUT" "*lluqshi"
b. \sr "PST &#60; *gaga" "bukaga"
c. \sr "PST &#60; *gaga" "&#60; bukaga"

</PRE>

<P>
Rules <I>b</I> and <I>c</I> differ in that <CODE>bukaga</CODE> in <I>b</I> would be
interpreted as a prefix, whereas in <I>c</I> it would be interpreted as a
root.

</P>
<P>
The rules by which a type is assigned to a morphname are as follows:

<OL>
<LI>Any morphname to the left of <CODE>&#60;</CODE> is a prefix.

<LI>Any morphname to the right of <CODE>&#62;</CODE> is a suffix.

<LI>All morphnames between <CODE>&#60;</CODE> and  <CODE>&#62;</CODE> are roots.

<LI>If the only delimiter in the match string is <CODE>&#60;</CODE>, every morphname

after it is a root.  Likewise, if the only delimiter is <CODE>&#62;</CODE>,
every morphname preceding it is a root.
</OL>

<P>
Recall that in lexical changes, morphnames that are not forced to be
prefixes or suffixes are assumed to be roots.  This is not the case
for substitution rules: if the match string does not contain a
delimiter, the type of each morphname is free to vary (that is, it can
be taken as either a prefix, a root, or a suffix) and type identity is
not imposed in determining a match to some portion of an analysis.
When a match is achieved, the morphnames of the match string inherit
the types of the matched morphnames in the analysis.  These types may
then influence the types assigned to the substitution string,
following the rules outlined in
section <A HREF="stamp.html#SEC32">5.8.3  Delimiters and type in lexical changes</A>
for lexical changes.

</P>
<P>
It is possible to make lexical changes with substitution rules; for
example,

<PRE>

\sr "*wishlla" "kucha:ra"

</PRE>

<P>
However, substitution rules are computationally more time consuming
than lexical changes, so they should be used only if there is good
reason to do so.  Here are two possible motivations for using a
substitution rule rather than a lexical change.  First, it may be
necessary to order the change after other rules of the transfer file
(for example, an insertion rule); recall that the lexical changes
apply before all other rules, so there is no control on their
ordering.  Second, it may be necessary to condition the change with a
flag; flags are not available for lexical changes.

</P>
<P>
We now proceed to illustrate some of the flexibilities afforded by
substitution rules.  The match and substitution strings may have
multiple morphnames.  For example, the following is used between
Quechua languages to reorder the pluralizer <CODE>-rka</CODE> `PLIMPF'
and the imperfective <CODE>-yka:</CODE> `IMPFV':

<PRE>

\sr "PLIMPF IMPFV" "IMPFV PLIMPF"

</PRE>

<P>
The match and substitution strings need not contain the same number of
morphnames.  For example, suppose -- as is the case in some Quechua
languages -- that in one language the reflex of <CODE>-ra</CODE> `PST3'
indicates both past tense and third person, whereas in another
language the cognate <CODE>-rqa</CODE> indicates just past tense, with third
person indicated by a following third person marker.  The following
makes the appropriate change:

<PRE>

\sr "PST3" "PST 3P" |-ra (PST3) to -rqa-n (PST 3)

</PRE>

<P>
Whereas in this case the substitution string is longer than the match
string, in the following example it is shorter.  In San Martin
Quechua, the adverbializer <CODE>-shpa</CODE> may be inflected to reflect
the person of the subject, whereas in Cuzco Quechua it is never so
inflected.  For example, San Martin <CODE>-shpa-yki</CODE> `ADVSS2P' should
become Cuzco <CODE>-spa</CODE> `ADV'.  One way to do this would be to write
a substitution rule for each case:

<PRE>

\sr "ADVSS  1P" "ADV"
\sr "ADVSS  2P" "ADV"
\sr "ADVSS  3P" "ADV"
\sr "ADVSS 12P" "ADV"

</PRE>

<P>
Alternatively, one could use a morpheme class and a single rule.  If
the morpheme class <CODE>POSS</CODE> contains <CODE>1P</CODE>, <CODE>2P</CODE>,
<CODE>3P</CODE>, and <CODE>12P</CODE>, then the following would make the desired
change:

<PRE>

\sr "ADVSS [POSS]" "ADV"

</PRE>

<P>
The substitution string may even be empty, in which case the morphname
sequence in the match string is simply deleted.  (The converse, that
is, changing an empty match string into some morphnames, is not
acceptable.  Insertion rules are provided for that purpose.)  Consider
two examples:

<OL>

<LI>Some Quechua languages have a future suffix <CODE>-paq</CODE> `FUT', which

is simply absent in others.  To adapt to the latter languages from
ones that have <CODE>-paq</CODE>, the following change is appropriate:

<PRE>

\sr "FUT" "" |delete -paq FUT

</PRE>

<LI>

Campa languages have considerable epenthesis phenomena at morpheme
boundaries.  To adapt across these, the strategy that has been taken
is to analyze the epenthesized phonemes as separate morphemes (named
"&#38;") and then to delete them in TRANSFER with the following rule:

<PRE>

\sr "&#38;" "" |remove epenthesis

</PRE>

Epenthesis is then reintroduced as appropriate for the target language
by SYNTHESIS.
</OL>

<P>
Substitution rules may be conditioned by one or more flags (discussed
in
section <A HREF="stamp.html#SEC25">5.6  Flag rule: \fl</A>).
For example, the following would substitute <CODE>-rpa</CODE> `PLSTAT' for
<CODE>-ra:</CODE> `STAT' whenever the PLURAL flag is up:

<PRE>

\sr "STAT" "PLSTAT" PLURAL

</PRE>

<P>

</P>
<P>
Substitution rules may also be conditioned by one or more environments
like those described in Weber, Black, and McConnel (1988:74ff).  An
environment must contain an environment bar and at least one
morphname, root, morpheme class, or the complement of one of these.

</P>
<P>
Let us consider three examples, each used in adapting from San Martin
to Cajamarca Quechua:

<OL>
<LI>Following <CODE>-rqa</CODE> `PST', some Quechua languages use <CODE>-yki</CODE>

`2P', the possessive form of the second person, whereas others use
<CODE>-nki</CODE> `2', the verbal form.  Therefore it is sometimes necessary
to change one into the other.  To avoid changing the second person
suffix everywhere, the rule must be constrained to apply only after
<CODE>PST</CODE>:

<PRE>

\sr "2" "2P" / PST _ |-rqa-yki to -rqa-nki

</PRE>

<LI>The following substitution rule is also used:


<PRE>

\sr "2" "3" / 2O PST _ |-shu-rqa-nki to -shu-rqa-n

</PRE>

The order of this change and the preceding change of <CODE>2</CODE> (verbal)
to <CODE>2P</CODE> (possessive) is critical.  Since both deal with morphname
<CODE>2</CODE> following <CODE>PST</CODE>, the one with the more specific
environment, that is, the one changing <CODE>2</CODE> to <CODE>3</CODE>, must be
put first.  Otherwise we have the undesirable situation in which the
more general rule would always apply, destroying the environment of
the more specific rule.

<LI>

The following rule assumes that the morpheme class <CODE>POSS</CODE>
containing <CODE>1P</CODE>, <CODE>2P</CODE>, <CODE>3P</CODE>, and <CODE>12P</CODE> has been
defined in the STAMP declarations file, and uses this class in a
morpheme environment constraint:

<PRE>

\sr "PLUR PUR" "PUR PL1" / NOM [POSS] _
		 |-NOM-POSS-PLUR-PUR --&#62; -NOM-POSS-PUR-PL1
		 |-na -yki -kuna-pa  --&#62; -na -yki -paq-llapa
		 |-na -n   -kuna-pa  --&#62; -na -n   -paq-llapa
		 |etc.

</PRE>

</OL>



<H1><A NAME="SEC48" HREF="stamp.html#TOC48">6  Synthesis Control File</A></H1>


<UL>
<LI><A HREF="stamp.html#SEC49">\ambig (zzSYNT.CHG)</A>: Analytic ambiguity delimiter
<LI><A HREF="stamp.html#SEC50">\ap (zzSYNT.CHG)</A>: Allomorph property declaration
<LI><A HREF="stamp.html#SEC51">\ca (zzSYNT.CHG)</A>: Category declarations
<LI><A HREF="stamp.html#SEC52">\ccl (zzSYNT.CHG)</A>: Category class declaration
<LI><A HREF="stamp.html#SEC53">\lc (zzSYNT.CHG)</A>: Lexical change
<LI><A HREF="stamp.html#SEC54">\maxprops (zzSYNT.CHG)</A>: Maximum number of properties
<LI><A HREF="stamp.html#SEC55">\mcl (zzSYNT.CHG)</A>: Morpheme class declaration
<LI><A HREF="stamp.html#SEC56">\mp (zzSYNT.CHG)</A>: Morpheme property declaration
<LI><A HREF="stamp.html#SEC57">\pcl (zzSYNT.CHG)</A>: Punctuation class
<LI><A HREF="stamp.html#SEC58">\rd (zzSYNT.CHG)</A>: Root delimiter
<LI><A HREF="stamp.html#SEC59">\rsc</A>: Regular sound change
<LI><A HREF="stamp.html#SEC60">\rscid</A>: Regular sound change identifiers
<LI><A HREF="stamp.html#SEC61">\scl (zzSYNT.CHG)</A>: String class declaration
<LI><A HREF="stamp.html#SEC62">\test</A>: Synthesis test
</UL>



<H2><A NAME="SEC49" HREF="stamp.html#TOC49">6.1  Analytic ambiguity delimiter: \ambig</A></H2>
<P>
<A NAME="IDX48"></A>

</P>
<P>
This field can also occur in the STAMP declarations file or the STAMP
transfer control file instead; see
section <A HREF="stamp.html#SEC7">4.1  Analytic ambiguity delimiter: \ambig</A>.

</P>


<H2><A NAME="SEC50" HREF="stamp.html#TOC50">6.2  Allomorph property declaration: \ap</A></H2>
<P>
<A NAME="IDX49"></A>

</P>
<P>
This field can also occur in the STAMP declarations file or the STAMP
transfer control file instead; see
section <A HREF="stamp.html#SEC8">4.2  Allomorph property declaration: \ap</A>.

</P>


<H2><A NAME="SEC51" HREF="stamp.html#TOC51">6.3  Category declarations: \ca</A></H2>
<P>
<A NAME="IDX50"></A>

</P>
<P>
This field can also occur in the STAMP declarations file or the STAMP
transfer control file instead; see
section <A HREF="stamp.html#SEC9">4.3  Category declarations: \ca</A>.

</P>


<H2><A NAME="SEC52" HREF="stamp.html#TOC52">6.4  Category class declaration: \ccl</A></H2>
<P>
<A NAME="IDX51"></A>

</P>
<P>
This field can also occur in the STAMP declarations file or the STAMP
transfer control file instead; see
section <A HREF="stamp.html#SEC11">4.5  Category class declaration: \ccl</A>.

</P>


<H2><A NAME="SEC53" HREF="stamp.html#TOC53">6.5  Lexical change: \lc</A></H2>
<P>
<A NAME="IDX52"></A>

</P>
<P>
The lexical changes of SYNTHESIS are like those of TRANSFER both with
respect to notation and program behavior (see
section <A HREF="stamp.html#SEC29">5.8  Lexical change: \lc</A>.)
The difference is that lexical changes included in the synthesis file
should express distinctives of the target language; this is discussed
further in
section <A HREF="stamp.html#SEC37">5.8.8  Where should lexical changes be made?</A>.
The example below contains lexical changes used for synthesizing to
Huamalies Quechua.  All lexical changes apply before any other changes
of the synthesis file.

</P>

<PRE>

SYNTHESIS lexical changes for adapting to Huamalies Quechua

\co exceptional changes from proto, not handled below
\lc "*illaqa:"    "elaqa:"      |disappear
\lc "*illaqpita"  "elaqpita"    |surprisingly
\lc "V1 *pa:ri"   "V1 paha"     |fly

\co words in which proto /s/ is lost:
\lc "*wasi"       "wayi"        |house
\lc "*masi"       "mayi"        |paisano
\lc "*masa"       "maha"        |mate

\co words which do not undergo */ll/ &#62; /l/
\lc "N0 *qillay"  "N0 qellay"   |money
\lc "*llan~u"     "llanu"       |thin

\co words which do not undergo */n~/ &#62; /n/
\lc "*pin~a"      "pin~a"       |bad, angry

\co words which do not undergo */ch/ &#62; /ts/ &#62; /s/
\lc "V1 *wacha"   "V1 wacha"    |give:birth
\lc "N0 *ichik"   "N0 ichik"    |small

\co words which have /sh/ from /*s/
\lc "*sumaq"      "shumaq"      |pretty

\co words with /e/ for /*i/, not due to phonetic lowering
\lc "*wira"       "wera"        |fat

\co words which have */aya/ &#62; /a:/
\lc "V1 *tiya"    "V1 ta:"      |reside
\lc "V1 *traya"   "V1 cha:"     |arrive
\lc "V1 *shaya"   "V1 sha:"     |stand

\co Exceptions to phonetic lowering following /q/:
\lc "V2 *ruqu"    "V2 roqu"     |sever

\co Spanish loans handled differently:
\lc "kri*yi"      "krigi"       |believe
\lc "inri*ga"     "entriga"     |turn over to
</PRE>

<P>
As illustrated above, synthesis lexical changes allow one to handle
exceptions to regular sound changes (RSCs) discussed in
section <A HREF="stamp.html#SEC59">6.11  Regular sound change: \rsc</A>.
For example, suppose that an RSC generally makes <CODE>ll</CODE> into
<CODE>l</CODE> but should not apply to <CODE>*qillay</CODE> for the target
language.  This form can be "exempted" from the application of RSCs
by omitting the RSC identifier (<CODE>*</CODE>) from the output of the
lexical change, as in the following:

<PRE>

\lc "N0 *qillay"  "N0 qellay"   |money

</PRE>

<P>
The greatest source of errors in lexical changes (both in TRANSFER and
SYNTHESIS) is the omission of the RSC identifier.  For example,
consider the following change:

<PRE>

\lc "papa" "aqshu" | potato

</PRE>

<P>
This will not work if the entry for <CODE>papa</CODE> in the source language
dictionary is either of the following, which are equivalent (see
Weber, Black, and McConnel 1988:128):

<PRE>

\w papa                \w papa
\p N0                  \p N0
\ge potato             \ge potato
\e *                   \e *papa

</PRE>

<P>
The reason is that an analysis with the root papa will come through as
follows:

<PRE>

\a &#60; N0 *papa &#62; ...

</PRE>

<P>
The solution is to make the left side of the transfer change
<CODE>*papa</CODE> rather than simply <CODE>papa</CODE>.

</P>



<H2><A NAME="SEC54" HREF="stamp.html#TOC54">6.6  Maximum number of properties: \maxprops</A></H2>
<P>
<A NAME="IDX53"></A>

</P>
<P>
This field can also occur in the STAMP declarations file or the STAMP
transfer control file instead; see
section <A HREF="stamp.html#SEC12">4.6  Maximum number of properties: \maxprops</A>.

</P>


<H2><A NAME="SEC55" HREF="stamp.html#TOC55">6.7  Morpheme class declaration: \mcl</A></H2>
<P>
<A NAME="IDX54"></A>

</P>
<P>
This field can also occur in the STAMP declarations file or the STAMP
transfer control file instead; see
section <A HREF="stamp.html#SEC13">4.7  Morpheme class declaration: \mcl</A>.

</P>


<H2><A NAME="SEC56" HREF="stamp.html#TOC56">6.8  Morpheme property declaration: \mp</A></H2>
<P>
<A NAME="IDX55"></A>

</P>
<P>
This field can also occur in the STAMP declarations file or the STAMP
transfer control file instead; see
section <A HREF="stamp.html#SEC14">4.8  Morpheme property declaration: \mp</A>.

</P>


<H2><A NAME="SEC57" HREF="stamp.html#TOC57">6.9  Punctuation class: \pcl</A></H2>
<P>
<A NAME="IDX56"></A>

</P>
<P>
This field can also occur in the STAMP declarations file or the STAMP
transfer control file instead; see
section <A HREF="stamp.html#SEC15">4.9  Punctuation class: \pcl</A>.

</P>


<H2><A NAME="SEC58" HREF="stamp.html#TOC58">6.10  Root delimiter: \rd</A></H2>
<P>
<A NAME="IDX57"></A>

</P>
<P>
This field can also occur in the STAMP declarations file or the STAMP
transfer control file instead; see
section <A HREF="stamp.html#SEC16">4.10  Root delimiter: \rd</A>.

</P>


<H2><A NAME="SEC59" HREF="stamp.html#TOC59">6.11  Regular sound change: \rsc</A></H2>
<P>
<A NAME="IDX58"></A>

</P>
<P>
The second part of a synthesis file defines regular sound changes
(RSCs).  The definition of an rsc may have five parts:

<OL>

<LI>the field code <CODE>\rsc</CODE>,

<LI>a match string,

<LI>a substitution string,

<LI>optionally, one or more one-character RSC identifiers, and

<LI>optionally, one or more string environment constraints.

</OL>

<P>
RSCs are string changes as described in Weber, Black, and McConnel
(1988:80ff), except that RSCs may have identifiers following the
substitution string.

</P>
<P>
It is possible to have different sets of regular sound changes apply
to different roots.  The rules of each set must be identified by a
distinguishing character, called an RSC identifier, and all roots
undergoing each set must also be marked with the same identifier by
putting that character in front of the etymology in the source
language dictionary.  When SYNTHESIS sees a root beginning with an RSC
identifier, it strips it off (since it is not really part of the
string), remembering the type of RSC identifier it had.  Subsequently,
only RSCs of that type are applied to it.

</P>
<P>
Any character used as an RSC identifier must be declared in the
synthesis file with the <CODE>\rscid</CODE> field.  For
instance,

<PRE>
\rscid * +
</PRE>

<P>
declares <CODE>*</CODE> and <CODE>+</CODE> as RSC identifiers.

</P>
<P>
There are three things to know about the <CODE>\rscid</CODE> field:

<OL>
<LI>There may be at most four classes of RSCs, so the <CODE>\rscid</CODE> field

may contain no more than four characters.

<LI>

If the <CODE>\rscid</CODE> field is not declared, SYNTHESIS assumes that there is a single class identified by an asterisk (<CODE>*</CODE>).  That is, no declaration is equivalent to the following declaration:

<PRE>
\rscid *
</PRE>

<LI>

An RSC identifier should not be a character that could begin a word
(although it could be a character used only medially or finally within
words), nor should it be <CODE>/</CODE> because in the RSCs this is
interpreted as initiating a string environment constraint.
</OL>

<P>
The identifiers in an RSC indicate the roots to which the change
should be applied.  The RSC applies only to roots marked by one of its
identifiers.  For example, the root in analysis <I>a</I> would undergo
the RSC defined in <I>b</I> because it is marked by the identifier
(namely, <CODE>+</CODE>) in <I>b</I>:

<PRE>
a. &#60; N +auricula &#62;
b. \rsc "au" "o" +
</PRE>

<P>
Likewise, the rsc in <I>e</I> would apply to both <I>c</I> and <I>d</I>, since both <CODE>*</CODE> and <CODE>+</CODE>
occur as identifiers in <I>e</I>:

<PRE>
c. &#60; N +gzudu &#62;
d. &#60; field V *mido &#62;
e. \rsc "d" "r" * + / [V] _ [V]
</PRE>

<P>
RSCs are applied to etymological forms to generate target language
roots in the following way:

<OL>
<LI>

An etymological form is stored in the source language dictionary.
Ordinarily, this would be a reconstructed proto form.  This form would
bear the appropriate RSC identifier.

<LI>

The etymology is put into analyses (by assigning the field code of
etymologies to internal code <CODE>M</CODE> ) and passes unchanged to the
point where RSCs apply.  (This would be the case if in TRANSFER it is
not changed by any lexical changes, if in SYNTHESIS no dictionary
entry is found for it, and if it is not changed by any synthesis
lexical changes.)

<LI>

RSCs apply, recapitulating the sound changes by which the target
language form evolved from the proto-form.  Unlike lexical changes,
only one of which ever applies to a given root, all RSCs are applied
to each susceptible root.  The RSCs are applied in the order they are
defined, with each change applying to the output of all previous ones.
And unlike lexical changes, which must match the entire root, RSCs
apply whenever they match any portion of a root.
</OL>

<P>
For example, consider the following set of rules (which assume the
default RSC identifier of <CODE>*</CODE>):

<PRE>

\rsc "ch" &#62; "ts" |(1) laminal to apical
\rsc "ts" &#62; "s"  |(2) deaffrication
\rcs "ll" &#62; "l"  |(3) depalatalization of *ll
\rcs "n~" &#62; "n"  |(4) depalatalization of *n~

</PRE>

<P>
Consider their effect on roots like <CODE>*chaki-</CODE> and <CODE>*llan~u</CODE>.

<PRE>

input  :   *chaki     *llan~u
after 1:    tsaki      llan~u
after 2:    saki       llan~u
after 3:    saki       lan~u
after 4:    saki       lanu
</PRE>

<P>
Note that each rule applies to the output of the previous rule.  (The
reader may wonder why two rules (<CODE>ch</CODE> to <CODE>ts</CODE> and then
<CODE>ts</CODE> to <CODE>s</CODE>) are used here instead of a direct change of
<CODE>ch</CODE> to <CODE>s</CODE>.  If the proto-language had <CODE>*ts</CODE> and the
change of <CODE>ts</CODE> to <CODE>s</CODE> were needed regardless of cases
produced by the first rule, this would be necessary.  However, this is
not the case in Quechua.  A single rule could have been used; two were
used for reasons of linguistic integrity: this models the actual
historical steps through which the language evolved; neighboring
dialects have undergone the first, more widespread change of <CODE>ch</CODE>
to <CODE>ts</CODE>, but not the more local change of <CODE>ts</CODE> to <CODE>s</CODE>.)

</P>
<P>
With the possible exception of a few loan words, many languages draw
their vocabulary from a single source language.  For such languages,
only one set of RSCs would be needed.  In other cases, the vocabulary
is drawn from multiple parents, and for each it might be useful to
derive target language words with different sets of RSCs.  For
Quechua, for example, in addition to deriving native roots from
Proto-Quechua forms, one could use RSCs to derive words borrowed from
Spanish, where RSCs carry out loan processes, such as changing mid
vowels to high vowels, stressed vowels to long vowels, vowel sequences
to vowel semivowel sequences, and so on.  In this case, since there
would be two sets of RSCs, it would be necessary to declare two rsc
identifiers, perhaps <CODE>*</CODE> for changes applied to Proto-Quechua
roots and <CODE>+</CODE> for changes applied to Spanish roots.

</P>
<P>
As is the case for string changes in general, RSCs may be conditioned.
The conditioning environments may make use of string classes, which
must be defined before being used.

</P>
<P>
The final example below gives the RSCs used to synthesize
Asheninca Campa:

<PRE>

Regular sound changes for Asheninca Campa

   \rsc "hi"  "ii" / #_
   \rsc "h"   " "   /a_a / a_i / e_e / i_i / o_o / o_i / a_e
   \rsc "iha" "yaa"
   \rsc "ih"  "y"
   \rsc "eh"  "y"

   \rsc "g"   ""   / a_a / o_i
   \rsc "g"   "y"  / a_i / i_ / e_
   \rsc "g"   "k"  / _o

   \rsc "iy"  "y"   |ohig &#62; oig &#62; oiy &#62; oy
					  |and rig &#62; riy &#62; ry
   \rsc "io"  "oo"  |Asheninca's Great Vowel Shift
   \rsc "oa"  "aa"
   \rsc "ei"  "ee"
   \rsc "ae"  "ai"  |so ahe &#62; ae &#62; ai
   \rsc "ch"  "tsy"
   \rsc "sh"  "sy"
   \rsc "se"  "sye"
</PRE>



<H2><A NAME="SEC60" HREF="stamp.html#TOC60">6.12  Regular sound change identifiers: \rscid</A></H2>
<P>
<A NAME="IDX59"></A>

</P>
<P>
The <CODE>\rscid</CODE> field defines an RSC identifier.  See
section <A HREF="stamp.html#SEC59">6.11  Regular sound change: \rsc</A>.

</P>



<H2><A NAME="SEC61" HREF="stamp.html#TOC61">6.13  String class declaration: \scl</A></H2>
<P>
<A NAME="IDX60"></A>

</P>
<P>
This field can also occur in the STAMP declarations file or the STAMP
transfer control file instead; see
section <A HREF="stamp.html#SEC17">4.11  String class declaration: \scl</A>.

</P>


<H2><A NAME="SEC62" HREF="stamp.html#TOC62">6.14  Synthesis test: \test</A></H2>
<P>
<A NAME="IDX61"></A>

</P>

<UL>
<LI><A HREF="stamp.html#SEC63">Campa epenthesis revisited</A>
<LI><A HREF="stamp.html#SEC64">Reporting conditions</A>
<LI><A HREF="stamp.html#SEC65">Test syntax</A>
</UL>

<P>
Some of the test mechanisms of AMPLE (Weber, Black, and McConnel
1988:149ff) have been incorporated into SYNTHESIS.  Only three of
AMPLE's built-in tests (Weber, Black, and McConnel 1988:150ff) apply
in SYNTHESIS.  These are string environment constraints (SEC_ST's,
Weber, Black, and McConnel 1988:74, 151), morpheme environment
constraints (MEC_FT's, Weber, Black, and McConnel 1988:74,
152), and punctuation environment constraints (PEC-ST's).

</P>

<P>
Like AMPLE, SYNTHESIS allows the user to define tests in terms of
information associated with a morpheme or allomorph.  The test
definitions must conform to the syntax detailed in XXXXXXXXXXXXX.
User-defined tests can be employed to constrain the selection of
allomorphs in cases that are too complex for string or morpheme
environment constraints.  Whenever a morpheme has two or more
allomorphs, the first one that passes all environmental conditions, as
well as all built-in and user-defined tests, is the one chosen as the
realization of that morpheme.  The order of tests in the synthesis
file determines the order in which they are applied.

</P>
<P>
If SYNTHESIS cannot parse a user-defined test, it reports this to
standard output as a "syntax error," followed by an identification
of the offending test.

</P>
<P>
Every test begins with a field code and must be followed by a name,
either the name of a built-in test or a user-given name.  Unless it is
a built-in test, the name must be followed by the definition of the
test.  In test definitions, <CODE>current</CODE> refers to the morpheme
whose allomorph is currently being considered, while <CODE>left</CODE>
refers to the previous morpheme and <CODE>right</CODE> refers to the
following one.  <CODE>LEFT</CODE> and <CODE>RIGHT</CODE> refer to some (or all) of
the units to the left or right, respectively, as represented in the
following diagram:

<PRE>

 MORPHNAMES:    M(1)  M(2)  M(3)  M(4) ... M(k)  M(k+1) ...
				 |     |     |     |        |      |
 CHOSEN          |     |     |     |        |      |
 ALLOMORPHS:    abc   def   ghi    ?   ...  ?      ?    ...
					 left current right
				 &#60;---LEFT         RIGHT---&#62;

</PRE>

<P>
For details, see Weber, Black, and McConnel 1988:164ff.

</P>
<P>
A test definition may be followed by an action to be taken whenever
the test succeeds.  Actions have two uses:

<OL>
<LI>

They can make late modifications to a synthesized target language word
(for example, handle Campa's epenthesis as illustrated below in
section <A HREF="stamp.html#SEC63">6.14.1  Campa epenthesis revisited</A>).

<LI>

They can monitor a particular condition (defined by the user) and,
whenever it is found, make a report to standard output (usually
redirected to a log file).
</OL>

<P>
Note that it is possible to write a test that is true for all
analyses; an action associated with such a test would apply to every
analysis.

</P>
<P>
The definition of an action must directly follow that of a test; it is
delimited by curly braces, that is, opened by <CODE>{</CODE> and closed by <CODE>}</CODE>.
Thus, a typical test with an action has the following form:

<PRE>

\test NAME
	 (...definition of test...)
	 {...definition of action...}
</PRE>

<P>
There are two kinds of actions, insertion actions and report actions.  An insertion action has one of the following forms:

<PRE>
{ insert &#60;string&#62; before &#60;position&#62; }
{ insert &#60;string&#62; after  &#60;position&#62; }
</PRE>

<P>
where <CODE>&#60;string&#62;</CODE> is what is to be inserted and <CODE>&#60;position&#62;</CODE>
indicates the position with a keyword like current.  As explained
below, insertion actions should be used only under exceptional
circumstances.

</P>
<P>
A report action has one of the following forms:

<PRE>

{ report }
{ report "&#60;message&#62;" }

</PRE>

<P>
A report always outputs the test name and the offending analysis.  The
text of <CODE>&#60;message&#62;</CODE> is output as well, if supplied as part of the
report action.  Either double quotes, periods, or apostrophes may be
used to delimit the message.

</P>
<P>
We now illustrate the use of actions.

</P>



<H3><A NAME="SEC63" HREF="stamp.html#TOC63">6.14.1  Campa epenthesis revisited</A></H3>

<P>
In synthesizing Campa words, after all allomorphs have been chosen, an
epenthetic <CODE>t</CODE> must be inserted at boundaries which satisfy certain
phonological conditions.  These conditions are defined in a test which
has an action to insert the epenthetic <CODE>t</CODE> if the conditions are met.
This test is as follows:

<PRE>

\test EPEN_t_FT
  (    NOT (left is PREFIX)
   AND (    NOT (left string matches #)
		AND NOT (right string matches #)
	   )
   AND (   (        (left string matches [V])
			AND NOT (left property is gdeleted)
			AND NOT (left property is FUC)
		   )
		OR (left string matches "N")
	   )
   AND (        (current string matches [V])
		AND NOT (current property is PUC)
	   )
  )
  { insert "t" before current }

</PRE>

<P>
An alternative approach to Campa epenthesis is possible.  The
<CODE>EPEN_t_FT</CODE> test and its insertion action could be dispensed with
if allomorphs incorporating the epenthetic segment were added to the
dictionaries, and conditions for their selection were given with
string environment constraints or tests.  This would be more in line
with STAMP's overall design, and would make it possible to simplify
the handling of epenthesis both in analysis and synthesis.

</P>
<P>
However, putting these allomorphs into the dictionaries manually would
be very tedious.  A nice alternative would be to introduce them
computationally before the dictionary is loaded.  This could be done
by the PhonRule program, for example.

</P>
<P>
An insertion action is justified in the case of Campa epenthesis
because the phenomenon is superficial (indeed, it can apply after
allomorph selection) and because it is regular and pervasive (indeed,
it would require thousands of allomorphs to handle without an
insertion rule).  Insertion actions should be used only under such
exceptional circumstances.  We strongly encourage the user to use the
allomorph selection method wherever possible.

</P>


<H3><A NAME="SEC64" HREF="stamp.html#TOC64">6.14.2  Reporting conditions</A></H3>

<P>
A test may be used as a monitor for violations of a particular
condition, reporting these to the standard output.  For example,
suppose one suspects errors in the order of morphemes for the target
language.  Assume that orderclasses for morphemes are defined in the
target language dictionaries, and that the condition should always
hold that a lesser orderclass never follows a greater one.  The
following test would monitor for violations of this
condition:

<PRE>

\test ORDER_REPORT_ST
	(left orderclass &#62; current orderclass)
	{ report "Orderclass violation" }

</PRE>

<P>
This test would cause a message like the following to be printed to
standard output, where the first line gives the test name and the
second line gives the offending analysis:

<PRE>

Report from test  ORDER_REPORT_ST
&#60; V1 aka &#62; MU IMPFV
Orderclass violation

</PRE>

<P>
Note that when the report action includes a message, the message is
printed at the end of the report.

</P>


<H3><A NAME="SEC65" HREF="stamp.html#TOC65">6.14.3  Test syntax</A></H3>
<P>
<A NAME="IDX62"></A>

</P>
<P>
The remainder of this chapter presents grammatical descriptions of the
syntax of tests in BNF notation.
The following comments explain how to read the syntax rules given
below:

<OL>

<LI>

Names shown inside wedges (<CODE>&#60;&#62;</CODE>) are nonterminal symbols.  These
must eventually be expanded into terminal symbols.

<LI>

The symbol <CODE>::=</CODE> means "is replaced by."

<LI>

Items on the righthand side of the rule (following the <CODE>::=</CODE>) that
are not enclosed in wedges are terminal symbols, and appear in the rule
exactly as they must appear in
a STAMP synthesis control file.
Whitespace is largely optional; it is required only to separate
identifiers and keywords.  (Keywords are the alphabetic terminal
symbols shown in the rules below.)

<LI>

Alternative ways of replacing a nonterminal symbol are listed on
separate lines.
</OL>


<PRE>

 1.  &#60;test&#62;          ::= &#60;identifier&#62; &#60;body&#62;
						 &#60;identifier&#62; &#60;body&#62; { &#60;actions&#62; }

 2a. &#60;body&#62;          ::= &#60;body&#62; &#60;logop&#62; &#60;factor&#62;
 2b.                     IF &#60;factor&#62; THEN &#60;factor&#62;
 2c.                     &#60;forleft&#62; &#60;factor&#62;
 2d.                     &#60;forright&#62; &#60;factor&#62;
 2e.                     &#60;factor&#62;

 3a. &#60;factor&#62;        ::= NOT &#60;factor&#62;
 3b.                     ( &#60;body&#62; )
 3c.                     &#60;property_expr&#62;
 3d.                     &#60;string_expr&#62;
 3e.                     &#60;type_expr&#62;
 3f.                     &#60;category_expr&#62;
 3g.                     &#60;order_expr&#62;
 3h.                     &#60;cap_expr&#62;
 3i.                     &#60;punct_expr&#62;

 4.  &#60;property_expr&#62; ::= &#60;position&#62; property is &#60;identifier&#62;

 5a. &#60;string_expr&#62;   ::= &#60;position&#62; morphname is &#60;identifier&#62;
 5b.                     &#60;position&#62; morphname is member &#60;identifier&#62;
 5c.                     &#60;position&#62; morphname is &#60;position&#62; morphname
 5d.                     &#60;position&#62; allomorph is &#60;identifier&#62;
 5e.                     &#60;position&#62; allomorph is member &#60;identifier&#62;
 5f.                     &#60;position&#62; allomorph is &#60;position&#62; allomorph
 5g.                     &#60;position&#62; allomorph matches &#60;identifier&#62;
 5h.                     &#60;position&#62; allomorph matches member &#60;identifier&#62;
 5i.                     &#60;position&#62; allomorph matches &#60;position&#62; allomorph
 5j.                     &#60;position&#62; surface is &#60;identifier&#62;
 5k.                     &#60;position&#62; surface is member &#60;identifier&#62;
 5l.                     &#60;position&#62; surface is &#60;position&#62; allomorph
 5m.                     &#60;position&#62; surface matches &#60;identifier&#62;
 5n.                     &#60;position&#62; surface matches member &#60;identifier&#62;
 5o.                     &#60;position&#62; surface matches &#60;position&#62; allomorph
 5p.                     &#60;neighbor&#62; word is &#60;identifier&#62;
 5q.                     &#60;neighbor&#62; word is member &#60;identifier&#62;
 5r.                     &#60;neighbor&#62; word matches &#60;identifier&#62;
 5s.                     &#60;neighbor&#62; word matches member &#60;identifier&#62;

 6.  &#60;type_expr&#62;     ::= &#60;position&#62; type is &#60;type&#62;

 7a. &#60;category_expr&#62; ::= &#60;position&#62; fromcategory is &#60;position&#62; fromcategory
 7b.                     &#60;position&#62; fromcategory is &#60;position&#62; tocategory
 7c.                     &#60;position&#62; tocategory is &#60;position&#62; fromcategory
 7d.                     &#60;position&#62; tocategory is &#60;position&#62; tocategory
 7e.                     &#60;position&#62; fromcategory is member &#60;identifier&#62;
 7f.                     &#60;position&#62; tocategory is member &#60;identifier&#62;
 7g.                     &#60;position&#62; fromcategory is &#60;identifier&#62;
 7h.                     &#60;position&#62; tocategory is &#60;identifier&#62;

 8a. &#60;cap_expr&#62;      ::= &#60;position&#62; allomorph is capitalized
 8b.                     word is capitalized

 9a. &#60;order_expr&#62;    ::= &#60;position&#62; orderclass &#60;relop&#62; &#60;position&#62; orderclass
 9b.                     &#60;position&#62; orderclass &#60;relop&#62; &#60;position&#62; orderclassmin
 9c.                     &#60;position&#62; orderclass &#60;relop&#62; &#60;position&#62; orderclassmax
 9d.                     &#60;position&#62; orderclassmin &#60;relop&#62; &#60;position&#62; orderclass
 9e.                     &#60;position&#62; orderclassmin &#60;relop&#62; &#60;position&#62; orderclassmin
 9f.                     &#60;position&#62; orderclassmin &#60;relop&#62; &#60;position&#62; orderclassmax
 9g.                     &#60;position&#62; orderclassmax &#60;relop&#62; &#60;position&#62; orderclass
 9h.                     &#60;position&#62; orderclassmax &#60;relop&#62; &#60;position&#62; orderclassmin
 9i.                     &#60;position&#62; orderclassmax &#60;relop&#62; &#60;position&#62; orderclassmax
 9j.                     &#60;position&#62; orderclass &#60;relop&#62; &#60;constant&#62;
 9k.                     &#60;position&#62; orderclassmin &#60;relop&#62; &#60;constant&#62;
 9l.                     &#60;position&#62; orderclassmax &#60;relop&#62; &#60;constant&#62;

10a. &#60;punct_expr&#62;    ::= &#60;neighbor&#62; punctuation is &#60;identifier&#62;
10b.                     &#60;neighbor&#62; punctuation is member &#60;identifier&#62;

11.  &#60;logop&#62;         ::= AND
						 OR
						 XOR
						 IFF

12.  &#60;forleft&#62;       ::= FOR_ALL_LEFT
						 FOR-ALL-LEFT
						 FORALLLEFT
						 FOR_SOME_LEFT
						 FOR-SOME-LEFT
						 FORSOMELEFT

13.  &#60;forright&#62;      ::= FOR_ALL_RIGHT
						 FOR-ALL-RIGHT
						 FORALLRIGHT
						 FOR_SOME_RIGHT
						 FOR-SOME-RIGHT
						 FORSOMERIGHT

14.  &#60;neighbor&#62;      ::= last
						 next

15.  &#60;type&#62;          ::= prefix
						 infix
						 root
						 suffix
						 initial
						 final

16.  &#60;relop&#62;        ::= =
						&#62;
						&#62;=
						&#60;=
						&#60;
						~=

17.  &#60;position&#62;     ::= left
						right
						current
						LEFT
						RIGHT
						INITIAL
						FINAL

18a. &#60;identifier&#62;   ::= "&#60;word&#62;"
18b.                    '&#60;word&#62;'
18c.                    .&#60;word&#62;.
18d.                    [&#60;word&#62;]
18e.                    &#60;word&#62;

19.  &#60;word&#62;         ::= &#60;wchar&#62;
						&#60;wchar&#62;&#60;word&#62;

20.  &#60;wchar&#62;        ::= one of the following characters:
							!"#$%&#38;'*+,-./0123456789:;?
							@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_
							`abcdefghijklmnopqrstuvwxyz{}
							\200-\376 (character codes 128-254)

21.  &#60;constant&#62;     ::= &#60;number&#62;
						-&#60;number&#62;

22.  &#60;number&#62;       ::= &#60;digit&#62;
						&#60;digit&#62;&#60;number&#62;

23.  &#60;digit&#62;        ::= one of the following characters:  0123456789

24.  &#60;actions&#62;      ::= &#60;action&#62;
						&#60;action&#62; , &#60;action&#62;

25.  &#60;action&#62;       ::= &#60;insert&#62;
						&#60;report&#62;

26.  &#60;insert&#62;       ::= insert &#60;string&#62; before &#60;position&#62;
						insert &#60;string&#62; after &#60;position&#62;

27.  &#60;report&#62;       ::= report
						report "&#60;message&#62;"
						report '&#60;message&#62;'
						report .&#60;message&#62;.

28.  &#60;message&#62;      ::= any character besides the quoting character
</PRE>


<H4>6.14.3.1  Comments on selected BNF rules</H4>
<DL COMPACT>

<DT>1.
<DD>
A test consists of an identifier followed by the body of the test.  The
identifier is the name by which a test is known.  The body consists of
the expressions which are interpreted to evaluate the test.
Actions are allowed after tests, but are optional.

<DT>4.
<DD>
The identifier in a property expression must be a property name defined
with <CODE>\mp</CODE> or <CODE>\ap</CODE> in the analysis data file.

<DT>5a.
<DD>
In a string expression involving morphnames, an identifier must be equal to
some morphname; for example, <CODE>left morphname is "PAST"</CODE> indicates that
the name of the morpheme to the left is PAST.

<DT>5b.
<DD>
A member identifier in such expressions must be the name of a class of
morphnames defined with <CODE>\mcl</CODE> in the analysis data file.

<DT>5dgjmpr.
<DD>
In a string expression involving allomorphs, surface strings, or
adjacent words, an identifier must be equal to some portion of a word after
any orthography change has been applied.  For example, <CODE>left allomorph
is "abadaba"</CODE> indicates that the allomorph of the morpheme to the left
is abadaba.

<DT>5ehknqs.
<DD>
A member identifier in such expressions must be the name of a
class of strings defined with <CODE>\scl</CODE> in the analysis data file.

<DT>5d-i.
<DD>
If reference is made to left, LEFT or INITIAL, the allomorph is tested
to see if it ends with the string; for example, <CODE>left allomorph
matches "ba"</CODE> indicates that the allomorph of the morpheme to the left
ends in ba.  If reference is made to current, right, RIGHT, or FINAL,
the allomorph is tested to see if it begins with the string.

<DT>5j-o.
<DD>
If reference is made to left, LEFT or INITIAL, the surface string is
tested to see if it ends with the given value.  If reference is made to
current, right, RIGHT, or FINAL, the surface string is tested to see if
it begins with the given value.

<DT>5p-s.
<DD>
If reference is made to last, the word is tested to see if it ends with
the string.  If reference is made to next, the word is tested to see if
it begins with the string.  (These should be avoided, and other means
used to prune analyses based on adjacent words.)

<DT>6.
<DD>
The type must be a keyword indicating whether the morpheme referred to
is a prefix, an infix, a root, and so on

<DT>7ef.
<DD>
The identifier must be the name of a class of categories defined with
<CODE>\ccl</CODE> in the analysis data file.

<DT>7gh.
<DD>
The identifier must be a category defined with <CODE>\ca</CODE> in the
analysis data file.

<DT>9a-l.
<DD>
A constant is an integer between -32767 and (positive) 32767.  The
relational operator (relop) must be among those listed in
rule 16.
The terminals <CODE>orderclass</CODE> and <CODE>orderclassmin</CODE> are
treated identically.  Both refer to the first of potentially
two order class numbers in a dictionary order class field.
The terminal <CODE>orderclassmax</CODE> refers to the second
order class number in a dictionary order class field.  If the
second number is not present, <CODE>orderclassmax</CODE> is set to
the same value as <CODE>orderclass</CODE>.

<DT>10.
<DD>
Punctuation expressions always refer to punctuation either immediately
before or after the current word.  A <CODE>&#60;neighbor&#62;</CODE> value of
<CODE>last</CODE> refers to immediately before the current word and
a <CODE>&#60;neighbor&#62;</CODE> value of <CODE>next</CODE> refers to
immediately after the current word.

<DT>18a-d.
<DD>
The quoted forms of an identifier are needed only if the identifier is
the same as one of the AMPLE test keywords.  It is recommended that the
quoted identifier not contain the closing quote character.

<DT>24.
<DD>
Multiple actions are allowed, separated by commas.

<DT>25.
<DD>
Possible actions are insertion or reporting.

<DT>26.
<DD>
Insertion is before or after some position.

<DT>27.
<DD>
Report if test succeeds.  Include optional message, quoted with
double quotes, single quotes, or periods.

<DT>28.
<DD>
A message can be any string of characters.  It can continue across
multiple lines.
</DL>



<H1><A NAME="SEC66" HREF="stamp.html#TOC66">7  Dictionary Code Table File</A></H1>
<P>
<A NAME="IDX63"></A>

</P>
<P>
The
fourth
control file read by STAMP contains the dictionary
code table.  Each entry of an STAMP dictionary (whether for
roots, prefixes, infixes, or suffixes) is structured by field codes that
indicate the type of information that follows.  The dictionary code table
maps the field codes used in the dictionary files onto the internal codes
that STAMP uses.  This allows linguists to use their favorite
dictionary field codes rather than constraining them to a predefined set.

</P>
<P>
The dictionary code table is divided into one or more sections,
one for each type of dictionary file.  Each section contains several
mappings of field codes in the form of simple changes.  The field codes
used in the dictionary code table file are described in the remainder
of this chapter.

</P>

<UL>
<LI><A HREF="stamp.html#SEC67">\ch (xxSYCD.TAB)</A>: Change standard format marker to internal code
<LI><A HREF="stamp.html#SEC68">\infix</A>: Infix dictionary fields
<LI><A HREF="stamp.html#SEC69">\prefix</A>: Prefix dictionary fields
<LI><A HREF="stamp.html#SEC70">\root</A>: Root dictionary fields
<LI><A HREF="stamp.html#SEC71">\suffix</A>: Suffix dictionary fields
<LI><A HREF="stamp.html#SEC72">\unified</A>: Unified dictionary fields
</UL>



<H2><A NAME="SEC67" HREF="stamp.html#TOC67">7.1  Change standard format marker to internal code: \ch</A></H2>
<P>
<A NAME="IDX64"></A>

</P>
<P>
A dictionary field code change is defined by <CODE>\ch</CODE> followed by two
quoted strings.  The first string is the field code used in the
dictionary (including the leading backslash character).  The second
string is the single capital letter designating the field type.  For
the lists of dictionary field type codes, see
section <A HREF="stamp.html#SEC76">9  Dictionary Files</A>.

</P>
<P>
Any character not found in either the dictionary field code string or
the dictionary field type code may be used as the quoting character.
The double quote (<CODE>"</CODE>) or single quote (<CODE>'</CODE>) are most often
used for this purpose.

</P>


<H2><A NAME="SEC68" HREF="stamp.html#TOC68">7.2  Infix dictionary fields: \infix</A></H2>
<P>
<A NAME="IDX65"></A>

</P>
<P>
The set of dictionary field code changes for an infix dictionary file
begins with <CODE>\infix</CODE>, optionally followed by the record marker
field code for the infix dictionary.  If the record marker is not
given, then the field code ("from string") from the first infix
dictionary field code change is used.
See section <A HREF="stamp.html#SEC76">9  Dictionary Files</A>,
for the set of infix dictionary field type codes.

</P>


<H2><A NAME="SEC69" HREF="stamp.html#TOC69">7.3  Prefix dictionary fields: \prefix</A></H2>
<P>
<A NAME="IDX66"></A>

</P>
<P>
The set of dictionary field code changes for a prefix dictionary file
begins with <CODE>\prefix</CODE>, optionally followed by the record marker
field code for the prefix dictionary.  If the record marker is not
given, then the field code ("from string") from the first prefix
dictionary field code change is used.
See section <A HREF="stamp.html#SEC76">9  Dictionary Files</A>,
for the set of prefix dictionary field type codes.

</P>


<H2><A NAME="SEC70" HREF="stamp.html#TOC70">7.4  Root dictionary fields: \root</A></H2>
<P>
<A NAME="IDX67"></A>

</P>
<P>
The set of dictionary field code changes for a root dictionary file
begins with <CODE>\root</CODE>, optionally followed by the record marker
field code for the root dictionary.  If the record marker is not
given, then the field code ("from string") from the first root
dictionary field code change is used.
See section <A HREF="stamp.html#SEC76">9  Dictionary Files</A>,
for the set of root dictionary field type codes.

</P>


<H2><A NAME="SEC71" HREF="stamp.html#TOC71">7.5  Suffix dictionary fields: \suffix</A></H2>
<P>
<A NAME="IDX68"></A>

</P>
<P>
The set of dictionary field code changes for a suffix dictionary file
begins with <CODE>\suffix</CODE>, optionally followed by the record marker
field code for the suffix dictionary.  If the record marker is not
given, then the field code ("from string") from the first suffix
dictionary field code change is used.
See section <A HREF="stamp.html#SEC76">9  Dictionary Files</A>,
for the set of suffix dictionary field type codes.

</P>


<H2><A NAME="SEC72" HREF="stamp.html#TOC72">7.6  Unified dictionary fields: \unified</A></H2>
<P>
<A NAME="IDX69"></A>

</P>
<P>
The set of dictionary field code changes for a unified dictionary file
begins with <CODE>\unified</CODE>, optionally followed by the record marker
field code for the unified dictionary.  If the record marker is not
given, then the field code ("from string") from the first unified
dictionary field code change is used.
See section <A HREF="stamp.html#SEC76">9  Dictionary Files</A>,
for the set of unified dictionary field type codes.

</P>


<H1><A NAME="SEC73" HREF="stamp.html#TOC73">8  Dictionary Orthography Change Table File</A></H1>
<P>
<A NAME="IDX70"></A>

</P>
<P>
The
fifth
control file read by STAMP, and the
third
optional one,
contains the dictionary orthography change table.  This table maps the
allomorph strings in the dictionary files into the internal
orthographic representation.  When the text and internal orthographies
differ, it may be desirable to have the allomorphs in the dictionaries
stored in the same orthography as the texts, or it may be desirable to
have them in the internal form, or it might even be desirable to have
them in a third form.  STAMP allows for any of these choices.

</P>
<P>
The dictionary orthography change table is defined by a special
standard format file.  This file contains a single record with two
types of fields, either of which may appear any number of times.  The
rest of this chapter describes these fields, focusing on the syntax of
the orthography changes.

</P>

<UL>
<LI><A HREF="stamp.html#SEC74">\ch (xxORDC.TAB)</A>: Dictionary orthography change
<LI><A HREF="stamp.html#SEC75">\scl (xxORDC.TAB)</A>: String class
</UL>



<H2><A NAME="SEC74" HREF="stamp.html#TOC74">8.1  Dictionary Orthography Change: \ch</A></H2>
<P>
<A NAME="IDX71"></A>

</P>
<P>
An orthography change is defined by the <CODE>\ch</CODE> field code followed
by the actual orthography change.  Any number of orthography changes
may be defined in the dictionary orthography change table.  The output
of each change serves as the input the following change.  That is, each
change is applied as many times as necessary to a dictionary allomorph
before the next change from the dictionary orthography change table is
applied.
See section <A HREF="stamp.html#SEC88">10.2  Text output orthographic changes: \ch</A>,
for the syntax of orthography changes.

</P>


<H2><A NAME="SEC75" HREF="stamp.html#TOC75">8.2  String class: \scl</A></H2>
<P>
<A NAME="IDX72"></A>

</P>
<P>
A string class is defined by the <CODE>\scl</CODE> field code followed by the
class name, which is followed in turn by one or more contiguous
character strings or (previously defined) string class names.  A string
class name used as part of the class definition must be enclosed in
square brackets.

</P>
<P>
The class name must be a single, contiguous sequence of printing
characters.  Characters and words which have special meanings in tests
should not be used.  The actual character strings have no such
restrictions.  The individual members of the class are separated by
spaces, tabs, or newlines.

</P>
<P>
Each <CODE>\scl</CODE> field defines a single string class.  Any number of
<CODE>\scl</CODE> fields may appear in the file.  The only restriction is
that a string class must be defined before it is used.

</P>
<P>
If no <CODE>\scl</CODE> fields appear in the dictionary orthography changes
file, then STAMP does not allow any string classes in dictionary
orthography change environment constraints unless they are defined in
the STAMP declarations file, the transfer control file, or the synthesis
control file.

</P>


<H1><A NAME="SEC76" HREF="stamp.html#TOC76">9  Dictionary Files</A></H1>
<P>
<A NAME="IDX73"></A>

</P>
<P>
This chapter describes the content of STAMP dictionary
files.  These are normally divided into

<OL>
<LI>

a prefix dictionary file (if needed),
<LI>

an infix dictionary file (if needed),
<LI>

an suffix dictionary file (if needed), and
<LI>

one or more root dictionary files.
</OL>

<P>
With the <SAMP>`-u'</SAMP> command line option in conjunction with the
<CODE>\unified</CODE> field in the dictionary code table file, the
dictionary can be stored as one or more files containing entries of any
type: prefix, infix, suffix, or root.

</P>
<P>
The following sections describe the different types of fields used in
the different types of dictionary files.  Remember, the mapping from
the actual field codes used in the dictionary files to the type codes
that STAMP uses internally is controlled by the dictionary code table
file
(see section <A HREF="stamp.html#SEC66">7  Dictionary Code Table File</A>).

</P>

<UL>
<LI><A HREF="stamp.html#SEC77">Allomorph</A>: Internal code A
<LI><A HREF="stamp.html#SEC78">Category</A>: Internal code C
<LI><A HREF="stamp.html#SEC79">Elsewhere allomorph</A>: Internal code E
<LI><A HREF="stamp.html#SEC80">Infix location</A>: Internal code L
<LI><A HREF="stamp.html#SEC81">Morphname</A>: Internal code M
<LI><A HREF="stamp.html#SEC82">Order class</A>: Internal code O
<LI><A HREF="stamp.html#SEC83">Morpheme property</A>: Internal code P
<LI><A HREF="stamp.html#SEC84">Morpheme type</A>: Internal code T
<LI><A HREF="stamp.html#SEC85">Do not load</A>: Internal code !
</UL>



<H2><A NAME="SEC77" HREF="stamp.html#TOC77">9.1  Allomorph (internal code A)</A></H2>

<P>
Each dictionary entry must contain one or more allomorph fields.  Each
of these contains one of the infix's allomorphs, that is, the string of
characters by which the affix is represented in text and recognized by
STAMP.

</P>
<P>
If an affix has multiple allomorphs, each one must be entered in its own
allomorph field.  These fields should be ordered with those on which the
strictest constraints have been imposed preceding those with less strict
or no constraints.  The only exception to this is the use of indexed
string classes to indicate reduplication.  (See lines 20 and 21 below.)

</P>
<P>
Properties, constraints, and comments may follow the allomorph string.
Any properties must be listed before any constraints.  String, punctuation and
morpheme environment constraints may be intermixed, but must come
before any comments.  A complete BNF grammar of an allomorph field is
given below.

</P>

<PRE>

 1a. &#60;allomorph_field&#62; ::= &#60;allomorph&#62;
 1b.                       &#60;allomorph&#62; &#60;properties&#62;
 1c.                       &#60;allomorph&#62; &#60;constraints&#62;
 1d.                       &#60;allomorph&#62; &#60;properties&#62; &#60;constraints&#62;
 1e.                       &#60;allomorph&#62; &#60;comment&#62;
 1f.                       &#60;allomorph&#62; &#60;properties&#62; &#60;comment&#62;
 1g.                       &#60;allomorph&#62; &#60;constraints&#62; &#60;comment&#62;
 1h.                       &#60;allomorph&#62; &#60;properties&#62; &#60;constraints&#62; &#60;comment&#62;

 2a. &#60;allomorph&#62;       ::= &#60;literal&#62;
 2b.                       &#60;literal&#62; { &#60;literal&#62; }
 2c.                       &#60;redup_pattern&#62;
 2d.                       &#60;redup_pattern&#62; { &#60;literal&#62; }

 3a. &#60;properties&#62;      ::= &#60;literal&#62;
 3b.                       &#60;literal&#62; &#60;properties&#62;

 4a. &#60;constraints&#62;     ::= &#60;string_constraint&#62;
 4b.                       &#60;negative_string_constraint&#62;
 4c.                       &#60;morph_constraint&#62;
 4d.                       &#60;punct_constraint&#62;
 4e.                       &#60;string_constraint&#62; &#60;constraints&#62;
 4f.                       &#60;negative_string_constraint&#62; &#60;constraints&#62;
 4g.                       &#60;morph_constraint&#62; &#60;constraints&#62;
 4h.                       &#60;punct_constraint&#62; &#60;constraints&#62;

 5.  &#60;comment&#62;         ::= &#60;comment_char&#62; anything to the end of the line

 6a. &#60;string_constraint&#62; ::= / &#60;envbar&#62; &#60;string_right&#62;
 6b.                         / &#60;string_left&#62; &#60;envbar&#62;
 6c.                         / &#60;string_left&#62; &#60;envbar&#62; &#60;string_right&#62;

 6d. &#60;negative_string_constraint&#62; ::= ~/ &#60;envbar&#62; &#60;string_right&#62;
 6e.                                  ~/ &#60;string_left&#62; &#60;envbar&#62;
 6f.                                  ~/ &#60;string_left&#62; &#60;envbar&#62; &#60;string_right&#62;

 7a. &#60;string_left&#62;       ::= &#60;string_side&#62;
 7b.                         &#60;boundary&#62;
 7c.                         &#60;boundary&#62; &#60;string_side&#62;
 7d.                         &#60;string_side&#62; # &#60;string_side&#62;
 7e.                         &#60;boundary&#62; &#60;string_side&#62; # &#60;string_side&#62;

 8a. &#60;string_right&#62;      ::= &#60;string_side&#62;
 8b.                         &#60;boundary&#62;
 8c.                         &#60;string_side&#62; &#60;boundary&#62;
 8d.                         &#60;string_side&#62; # &#60;string_side&#62;
 8e.                         &#60;string_side&#62; # &#60;string_side&#62; &#60;boundary&#62;

 9a. &#60;string_side&#62;       ::= &#60;string_item&#62;
 9b.                         &#60;string_item&#62; &#60;string_side&#62;
 9c.                         &#60;string_item&#62; ... &#60;string_side&#62;

10a. &#60;string_item&#62;       ::= &#60;string_piece&#62;
10b.                         ( &#60;string_piece&#62; )

11a. &#60;string_piece&#62;      ::= ~ &#60;string_piece&#62;
11b.                         &#60;literal&#62;
11c.                         [ &#60;literal&#62; ]
11d.                         [ &#60;indexed_literal&#62; ]

12a. &#60;morph_constraint&#62;  ::= +/ &#60;envbar&#62; &#60;morph_right&#62;
12b.                         +/ &#60;morph_left&#62; &#60;envbar&#62;
12c.                         +/ &#60;morph_left&#62; &#60;envbar&#62; &#60;morph_right&#62;

13a. &#60;morph_left&#62;        ::= &#60;morph_side&#62;
13b.                         &#60;boundary&#62;
13c.                         &#60;boundary&#62; &#60;morph_side&#62;
13d.                         &#60;morph_side&#62; # &#60;morph_side&#62;
13e.                         &#60;boundary&#62; &#60;morph_side&#62; # &#60;morph_side&#62;

14a. &#60;morph_right&#62;       ::= &#60;morph_side&#62;
14b.                         &#60;boundary&#62;
14c.                         &#60;morph_side&#62; &#60;boundary&#62;
14d.                         &#60;morph_side&#62; # &#60;morph_side&#62;
14e.                         &#60;morph_side&#62; # &#60;morph_side&#62; &#60;boundary&#62;

15a. &#60;morph_side&#62;        ::= &#60;morph_item&#62;
15b.                         &#60;morph_item&#62; &#60;morph_side&#62;
15c.                         &#60;morph_item&#62; ... &#60;morph_side&#62;

16a. &#60;morph_item&#62;        ::= &#60;morph_piece&#62;
16b.                         ( &#60;morph_piece&#62; )

17a. &#60;morph_piece&#62;       ::= ~ &#60;morph_piece&#62;
17b.                         &#60;literal&#62;
17c.                         [ &#60;literal&#62; ]
17d.                         { &#60;literal&#62; }

18a. &#60;punct_constraint&#62;  ::= ./ &#60;envbar&#62; &#60;punct_right&#62;
18b.                         ./ &#60;punct_left&#62; &#60;envbar&#62;
18c.                         ./ &#60;punct_left&#62; &#60;envbar&#62; &#60;punct_right&#62;

19a. &#60;punct_left&#62;        ::= &#60;punct_side&#62;
19b.                         &#60;boundary&#62;
19c.                         &#60;boundary&#62; &#60;punct_side&#62;

20a. &#60;punct_right&#62;       ::= &#60;punct_side&#62;
20b.                         &#60;boundary&#62;
20c.                         &#60;punct_side&#62; &#60;boundary&#62;

21a. &#60;punct_side&#62;        ::= &#60;punct_item&#62;
21b.                         &#60;punct_item&#62; &#60;punct_side&#62;

22a. &#60;punct_item&#62;        ::= &#60;punct_piece&#62;
22b.                         ( &#60;punct_piece&#62; )

23a. &#60;punct_piece&#62;       ::= ~ &#60;punct_piece&#62;
23b.                         &#60;literal&#62;
23c.                         [ &#60;literal&#62; ]

24a. &#60;envbar&#62;            ::= _
24b.                         ~_

25a. &#60;boundary&#62;          ::= #
25b.                         ~#

26a. &#60;redup_pattern&#62;     ::= [ &#60;indexed_literal&#62; ]
26b.                         &#60;literal&#62; [ &#60;indexed_literal&#62; ]
26c.                         [ &#60;indexed_literal&#62; ] &#60;literal&#62;
26d.                         [ &#60;indexed_literal&#62; ] &#60;redup_pattern&#62;
26e.                         &#60;redup_pattern&#62; [ &#60;indexed_literal&#62; ]

27.  &#60;indexed_literal&#62;   ::= &#60;literal&#62; ^ &#60;number&#62;

28.  &#60;literal&#62;           ::= one or more contiguous characters

29.  &#60;comment_char&#62;      ::= character defined by <SAMP>`-c'</SAMP> command
							 line option, or <CODE>|</CODE> by default

30.  &#60;number&#62;            ::= one or more contiguous digits (0-9)

</PRE>


<H4>9.1.0.1  Comments on selected BNF rules</H4>
<DL COMPACT>

<DT>2.
<DD>
The (first) literal string is a surface form representation of the
morpheme.  The literal string enclosed in braces is a unique allomorph
identification string.  (The identification string is a feature added
to support LinguaLinks.  It is not stored unless the <SAMP>`-b'</SAMP> command
line option is used.

<DT>3.
<DD>
Each literal string is an allomorph property defined by a <CODE>\ap</CODE>
field in the analysis data file.

<DT>4.
<DD>
String, punctuation and morpheme constraints can be mixed together, but
it is recommended that you group the string constraints together, the
punctuation constraints together and the morpheme constraints together.

<DT>5.
<DD>
A comment begins with a specified character and ends with the end of
the line.

<DT>6d.
<DD>
A negative string constraint is just like a string
constraint with two exceptions:

<OL>
<LI>

the result is negated (that is, whatever the value of the
regular string constraint would be, it takes its opposite value
as the result); and
<LI>

multiple negative string constraints are logically
ANDed together (whereas multiple regular string constraints
are logically ORed together).
</OL>

Thus one can use negative string constraints to say that a
given allomorph may not occur in environment X and it also
may not occur in environment Y.

If an allomorph has both regular and negative string
constraints, both must be met.  That is, at least one of
the regular string constraints must be true and none of the
environments described within the negative string
constraints must be true.

<DT>7-8.
<DD>
Note that what can appear to the left of the environment bar is a
mirror image of what can appear to the right.

<DT>7de.
<DD>
<DT>8de.
<DD>
These should be avoided, and other means used to prune analyses based
on adjacent words.

<DT>9c.
<DD>
An ellipsis (<CODE>...</CODE>) indicates a possible break in contiguity.

<DT>10b.
<DD>
Something enclosed in parentheses is optional.

<DT>11a.
<DD>
A tilde (<CODE>~</CODE>) reverses the desirability of an element, causing the
constraint to fail if it is found rather than fail if it is not found.

<DT>11b.
<DD>
A literal is matched against the surface form of the word.

<DT>11c.
<DD>
A literal enclosed in square brackets must be the name of a string
class defined by a <CODE>\scl</CODE> field in the analysis data file or the
dictionary orthography change table file.

<DT>11d.
<DD>
The indexed literal enclosed in square brackets must match an indexed
literal given as part of the reduplication allomorph pattern.  (See 2c,
2d, and 26.)

<DT>13-14.
<DD>
Note that what can appear to the left of the environment bar is a
mirror image of what can appear to the right.

<DT>13de.
<DD>
<DT>14de.
<DD>
These should be avoided, and other means used to prune analyses based
on adjacent words.

<DT>15c.
<DD>
An ellipsis (<CODE>...</CODE>) indicates a possible break in contiguity.

<DT>16b.
<DD>
Something enclosed in parentheses is optional.

<DT>17a.
<DD>
A tilde (<CODE>~</CODE>) reverses the desirability of an element, causing the
constraint to fail if it is found rather than fail if it is not found.

<DT>17b.
<DD>
A literal is a morphname from one of the dictionary files.

<DT>17c.
<DD>
A literal enclosed in square brackets must be the name of a morpheme
class defined by a <CODE>\mcl</CODE> field in the analysis data file.

<DT>17d.
<DD>
A literal enclosed in curly braces must be one of the following
(checked in this order):

<OL>
<LI>

one of the keywords <CODE>root</CODE>, <CODE>prefix</CODE>, <CODE>infix</CODE>, or
<CODE>suffix</CODE>
<LI>

a property name defined by an <CODE>\ap</CODE> or <CODE>\mp</CODE> field in the
analyis data file
<LI>

a category name defined by a <CODE>\ca</CODE> field in the analysis data file
<LI>

a category class name defined by a <CODE>\ccl</CODE> field in the analysis
data file
<LI>

a morpheme class name defined by a <CODE>\mcl</CODE> field in the analysis
data file
</OL>

<DT>19-20.
<DD>
Note that what can appear to the left of the environment bar is a
mirror image of what can appear to the right.

<DT>22b.
<DD>
Something enclosed in parentheses is optional.

<DT>23a.
<DD>
A tilde (<CODE>~</CODE>) reverses the desirability of an element, causing the
constraint to fail if it is found rather than fail if it is not found.

<DT>23b.
<DD>
A literal is a punctuation character.

The punctuation characters can match punctuation characters either
before or after the current word.  Unlike string constraints,
punctuation constraints effectively ignore the position of the
conditioned allomorph within the word.  All that matters are any
punctuation characters immediately preceding or following the current
word.  Further note that neither ellipsis nor cross word boundary
conditions are allowed.

<DT>24.
<DD>
A tilde (<CODE>~</CODE>) attached to the environment bar inverts the sense of
the constraint as a whole.

<DT>25b.
<DD>
The boundary marker preceded by a tilde (<CODE>~#</CODE>) indicates that it
must not be a word boundary.

<DT>26-27.
<DD>
Although the BNF has spaces in it to improve readability, these two items
cannot have embedded spaces in the dictionary file.

<DT>26.
<DD>
The reduplication allomorph pattern contains references to string classes
and possibly literal strings.  The string class names are indexed to
indicate identical shared values, either in the string environment
constraint or in more than one location in the reduplication allomorph
pattern itself.  <EM>Note: this has been implemented only for AMPLE at this
point.</EM>

<DT>27.
<DD>
The literal (without the following index given by an ASCII caret
(<CODE>^</CODE>) and a number) must be the name of a string class defined by a
<CODE>\scl</CODE> field in the analysis data file or the dictionary orthography
change table file.

<DT>28.
<DD>
The special characters used by environment constraints can be included
in a literal only if they are immediately preceded by a backslash:

<PRE>

\+  \/  \#  \~  \[  \]  \(  \)  \{  \}  \.  \_  \\

</PRE>

</DL>

<P>
The allomorph field is used in all types of dictionary entries: prefix,
infix, suffix, and root.

</P>


<H2><A NAME="SEC78" HREF="stamp.html#TOC78">9.2  Category (internal code C)</A></H2>

<P>
Each dictionary entry must contain a category field.  If multiple
category fields exist, then their contents are merged together.

</P>
<P>
For affix entries, this field must contain at least one category pair
for the morpheme, but may contain any number of category pairs
separated by spaces or tabs.  Each category pair consists of two
category names separated by a slash (<CODE>/</CODE>).  The category names
must have been defined by a <CODE>\ca</CODE> field in the analysis data
file.  The first category is the <EM>from category</EM>, that is, the
category of the unit to which this morpheme can be affixed.  The second
category is the <EM>to category</EM>, that is, the category of the result
after this morpheme has been affixed.

</P>
<P>
For root entries, this field contains one or more morphological
categories as defined by a <CODE>\ca</CODE> field in the analysis data file.
If multiple categories are listed, they should be separated by spaces
or tabs.

</P>
<P>
The category field is used in all types of dictionary entries: prefix,
infix, suffix, and root.

</P>


<H2><A NAME="SEC79" HREF="stamp.html#TOC79">9.3  Elsewhere Allomorph (internal code E)</A></H2>

<P>
WRITE ME!

</P>
<P>
The elsewhere allomorph field is used in all types of dictionary
entries: prefix, infix, suffix, and root.

</P>



<H2><A NAME="SEC80" HREF="stamp.html#TOC80">9.4  Infix location (internal code L)</A></H2>

<P>
The infix location field serves to restrict where infixes may be found,
and must be included in each infix dictionary entry.  Subject to the
constraints imposed by the infix location field, STAMP searches the
rest of the word for any occurrence of any allomorph string of the
infix.  This makes infixes rather expensive, computationally, so they
should be constrained as much as possible.

</P>

<PRE>

 1.  &#60;infix_location&#62; ::= &#60;types&#62; &#60;constraints&#62;

 2a. &#60;types&#62;          ::= &#60;type&#62;
 2b.                      &#60;type&#62; &#60;types&#62;

 3a. &#60;constraints&#62;    ::= &#60;environment&#62;
 3b.                      &#60;environment&#62; &#60;constraints&#62;

 4a. &#60;environment&#62;    ::= &#60;marker&#62; &#60;leftside&#62; &#60;envbar&#62; &#60;rightside&#62;
 4b.                      &#60;marker&#62; &#60;leftside&#62; &#60;envbar&#62;
 4c.                      &#60;marker&#62; &#60;envbar&#62; &#60;rightside&#62;

 5a. &#60;leftside&#62;       ::= &#60;side&#62;
 5b.                      &#60;boundary&#62;
 5c.                      &#60;boundary&#62; &#60;side&#62;

 6a. &#60;rightside&#62;      ::= &#60;side&#62;
 6b.                      &#60;boundary&#62;
 6c.                      &#60;side&#62; &#60;boundary&#62;

 7a. &#60;side&#62;           ::= &#60;item&#62;
 7b.                      &#60;item&#62; &#60;side&#62;
 7c.                      &#60;item&#62; ... &#60;side&#62;

 8a. &#60;item&#62;           ::= &#60;piece&#62;
 8b.                      ( &#60;piece&#62; )

 9a. &#60;piece&#62;          ::= ~ &#60;piece&#62;
 9b.                      &#60;literal&#62;
 9c.                      [ &#60;literal&#62; ]

10a. &#60;type&#62;           ::= prefix
10b.                      root
10c.                      suffix

11a. &#60;marker&#62;         ::= /
11b.                      +/

12a. &#60;envbar&#62;         ::= _
12b.                      ~_

13a. &#60;boundary&#62;       ::= #
13b.                      ~#

14.  &#60;literal&#62;        ::= one or more contiguous characters

</PRE>


<H4>9.4.0.1  Comments on selected BNF rules</H4>
<DL COMPACT>

<DT>2.
<DD>
The first part of the infix location field lists the type of morpheme
in which the infix may be hidden.  This consists of one or more of the
words <CODE>prefix</CODE>, <CODE>root</CODE>, or <CODE>suffix</CODE>.  If <CODE>prefix</CODE>
is given, then STAMP looks for infixes after exhausting the possible
prefixes at a given point in the word, and resumes looking for more
prefixes after finding an infix.  Similarly, if <CODE>root</CODE> is given,
then STAMP looks for infixes after running out of roots while parsing
the word, and if it finds an infix, it looks for more roots.  Suffixes
are treated the same way if <CODE>suffix</CODE> is given in the infix
location field.

<DT>5.
<DD>
A boundary marker (<CODE>#</CODE>) on the left side of the environment bar
refers to the place in the word which the parse has reached before
looking for infixes, not to the beginning of the word.

<DT>6.
<DD>
A boundary marker (<CODE>#</CODE>) on the right side of the environment bar
refers to the end of the word.

<DT>7c.
<DD>
An ellipsis (<CODE>...</CODE>) indicates a possible break in contiguity.

<DT>8b.
<DD>
Something enclosed in parentheses is optional.

<DT>9a.
<DD>
A tilde (<CODE>~</CODE>) reverses the desirability of an element, causing the
constraint to fail if it is found rather than fail if it is not found.

<DT>11.
<DD>
A <CODE>+/</CODE> is usually used for morpheme environment constraints, but may
used for infix location environment constraints as well.

<DT>12.
<DD>
A tilde attached to the environment bar (<CODE>~_</CODE>) inverts the sense of
the constraint as a whole.

<DT>13b.
<DD>
The boundary marker preceded by a tilde (<CODE>~#</CODE>) indicates that it
must not be a word boundary.

<DT>14.
<DD>
The special characters used by environment constraints can be included
in a literal only if they are immediately preceded by a backslash:

<PRE>

\+  \/  \#  \~  \[  \]  \(  \)  \{  \}  \.  \_  \\

</PRE>

</DL>

<P>
The infix location field is used only in infix dictionary entries.

</P>


<H2><A NAME="SEC81" HREF="stamp.html#TOC81">9.5  Morphname (internal code M)</A></H2>

<P>
A morphname is an arbitrary name for a given morpheme.  Only the first
word (string of contiguous nonspace characters) following the morphname
field code is used as the morphname.  Morphnames must be less than 64
characters long.

</P>
<P>
A morphname serves two important functions:

<OL>
<LI>

It identifies a morpheme in morpheme environment constraints, morpheme
co-occurrence constraints, ad hoc pairs, and tests.

<LI>

It is the default morpheme identifier written to the output analysis
file.
</OL>

<P>
Generally, a morphname is an identifier of a morpheme and does not
need to faithfully represent that morpheme's meaning or function.

</P>
<P>
If a dictionary entry has more than one morphname field, the morphname
from the first one is used; the others cause an error message.  The
morphname field is used in all types of dictionary entries: prefix,
infix, suffix, and root.  The usage differs somewhat between affix and
root dictionary entries, so these two types of morphnames are described
separately.

</P>

<H3>9.5.1  Affix morphnames</H3>

<P>
Every affix dictionary entry must have a morphname field.  Users are
strongly encouraged to observe the following suggestions in creating
affix morphnames:

</P>

<OL>
<LI>

Make each morphname unique.  If two morphemes have the same name, it is
impossible to refer unambiguously to them.  The same morphname should
not be used in different affix dictionaries (that is, in the prefix
dictionary and in the suffix dictionary).

<LI>

Keep morphnames short.  This reduces the size of analysis files and
makes text glossing more aesthetically pleasing.  For example, for a
verbal person marker, use simply <CODE>1</CODE> rather than <CODE>1P</CODE> unless
there is good reason to add the <CODE>P</CODE> for person or possessive.  For
a first person object marker, <CODE>1O</CODE> might serve as well as
<CODE>1OBJ</CODE>.

<LI>

Use only uppercase alphabetic characters and numbers for contrast with
root morphnames, which are generally made up of lowercase alphabetic
characters.  Be cautious in using hyphens, periods, underscores,
slashes, backslashes, or other nonalphanumeric characters.  The reason
to avoid these is that other programs which apply to the resulting
analysis may make use of nonalphanumerics in different ways.

<LI>

Design a syntax of names and stick to it for inflectional morphemes
which combine more than one semantic notion.  For example, for Latin
nominal inflections, which indicate gender, number, and case, the
syntax might be

<PRE>

MORPHNAME = GENDER CASE NUMBER

</PRE>

where <CODE>GENDER</CODE> is <CODE>M</CODE> for masculine, <CODE>F</CODE> for feminine
and <CODE>N</CODE> for neuter; <CODE>CASE</CODE> is <CODE>N</CODE> for nominative,
<CODE>A</CODE> for accusative, <CODE>G</CODE> for genitive, and so on; and <CODE>NUMBER</CODE>
is <CODE>S</CODE> for singular and <CODE>P</CODE> for plural.  The name for
masculine nominative singular would then be <CODE>MNS</CODE>.
</OL>


<H3>9.5.2  Root morphnames</H3>

<P>
Root morphnames are generally either glosses or etymologies.
Etymologies are frequently marked with a leading asterisk (<CODE>*</CODE>).
(This is used by STAMP to indicate regular sound changes.)

</P>
<P>
If the morphname field contains only an asterisk, the morphname becomes
an asterisk followed by whatever allomorph is matched.  If the
morphname field is omitted, or if it contains only a comment, STAMP
puts whatever allomorph was matched in the text into the analysis.  If
the morpheme contains any alternate forms, it is wise to include an
explicit morphname field.

</P>


<H2><A NAME="SEC82" HREF="stamp.html#TOC82">9.6  Order class (internal code O)</A></H2>

<P>
The order class of an affix is a number indicating its position
relative to other morphemes.  Prefixes should be assigned negative
numbers and suffixes should be assigned positive numbers.  Infixes
should be assigned order class values appropriate to where they can
appear in the word relative to the prefixes and suffixes.

</P>
<P>
If the order class field is omitted, then a default value of zero (0)
is assigned to the affix.  Order class values must be between -32767
and 32767.

</P>
<P>
Order classes are used only by tests in the analysis data file.  They
are needed only if appropriate tests are written to take advantage of
them.

</P>
<P>
The order class field is used only in affix type dictionary entries:
prefix, infix, and suffix.  Roots always have an implicit order class
of zero.

</P>
<P>
Beginning with AMPLE version 3.6.0, one may have up to two
order class numbers in an order class field (separated by
white space).  These represent the minimum and the maximum
values of the positions this affix can span.  The first
number is the minimum and the second is the maximum.
Therefore the first number should be less than or equal to
the second.  If only one number appears, both the minimum
and maximum values are set to that number.  If no number
appears, then both the minimum and maximum are set to zero.

</P>
<P>
Note that for STAMP, only the first order class number has
any use (it is used for transfer insertion rules whose
environments do not indicate a location where the morpheme
is to be inserted).

</P>


<H2><A NAME="SEC83" HREF="stamp.html#TOC83">9.7  Morpheme property (internal code P)</A></H2>

<P>
This field contains one or more morpheme properties.  These properties
must have been defined by a <CODE>\mp</CODE> field in the analysis data file.
A morpheme property is inherited by all allomorphs of the morpheme.

</P>
<P>
The morpheme property field is optional, and may be repeated.  If
multiple properties apply to a morpheme, they may be given all in a
single field or each in a separate field.

</P>
<P>
Morpheme properties typically indicate a characteristic of the morpheme
which conditions the occurrence of allomorphs of an adjacent morpheme.
Morpheme properties are used in tests defined in the analysis data file
and in morpheme environment constraints.

</P>
<P>
The morpheme property field is used in all types of dictionary entries:
prefix, infix, suffix, and root.

</P>


<H2><A NAME="SEC84" HREF="stamp.html#TOC84">9.8  Morpheme type (internal code T)</A></H2>

<P>
In a unified dictionary, the type of an entry is determined by the
first letter following the morpheme type field code: <CODE>p</CODE> or
<CODE>P</CODE> for prefixes, <CODE>i</CODE> or <CODE>I</CODE> for infixes, <CODE>s</CODE> or
<CODE>S</CODE> for suffixes, and <CODE>r</CODE> or <CODE>R</CODE> for roots.  The
morpheme type field is not needed for root entries because the entry
type defaults to root.

</P>
<P>
The morpheme type field is used only in unified dictionary files, since
the morpheme type is otherwise implicit.

</P>



<H2><A NAME="SEC85" HREF="stamp.html#TOC85">9.9  Do not load (internal code !)</A></H2>

<P>
When a "do not load" field is included in a record, STAMP
ignores the record altogether.  This makes it possible to include records
in the dictionary for linguistic purposes, while not needlessly taking up
memory space if the dictionary is used for some other purpose.

</P>
<P>
The "do not load" field is used in all types of dictionary entries:
prefix, infix, suffix, and root.

</P>



<H1><A NAME="SEC86" HREF="stamp.html#TOC86">10  Text Output Control File</A></H1>
<P>
<A NAME="IDX74"></A>

</P>

<UL>
<LI><A HREF="stamp.html#SEC87">\ambig</A>
<LI><A HREF="stamp.html#SEC88">\ch</A>
<LI><A HREF="stamp.html#SEC95">\dsc</A>
<LI><A HREF="stamp.html#SEC96">\format</A>
<LI><A HREF="stamp.html#SEC97">\luwfc</A>
<LI><A HREF="stamp.html#SEC98">\luwfcs</A>
<LI><A HREF="stamp.html#SEC99">\scl</A>
<LI><A HREF="stamp.html#SEC100">\wfc</A>
<LI><A HREF="stamp.html#SEC101">\wfcs</A>
<LI><A HREF="stamp.html#SEC102">Sample text output control file</A>
</UL>

<P>
The <I>text output</I> module restores a processed document from the
internal format to its textual form.  It re-imposes capitalization on
words and restores punctuation, format markers, white space, and line
breaks.  Also, orthography changes can be made, and the delimiter that
marks ambiguities and failures can be changed.  This chapter describes
the control file given to the text output module.<A NAME="DOCF1" HREF="stamp.html#FOOT1">(1)</A>

</P>


<H2><A NAME="SEC87" HREF="stamp.html#TOC87">10.1  Text output ambiguity delimiter: \ambig</A></H2>
<P>
<A NAME="IDX75"></A>

</P>
<P>
The text output module flags words that either produced no results or
multiple results when processed.  These are flagged with percent signs
(<CODE>%</CODE>) by default, but this can be changed by declaring the desired
character with the \ambig field code.  For example, the following would
change the ambiguity delimiter to <CODE>@</CODE>:

<PRE>
\ambig @
</PRE>



<H2><A NAME="SEC88" HREF="stamp.html#TOC88">10.2  Text output orthographic changes: \ch</A></H2>
<P>
<A NAME="IDX76"></A>

</P>
<P>
The text output module allows orthographic changes to be made to the
processed words.
These are given in the text output control file.

</P>
<P>
An orthography change is defined by the <CODE>\ch</CODE> field code followed
by the actual orthography change.  Any number of orthography changes
may be defined in the text output control file.  The output of each
change serves as the input the following change.  That is, each change
is applied as many times as necessary to an input word before the next
change from the text output control file is applied.

</P>

<UL>
<LI><A HREF="stamp.html#SEC89">Basic changes</A>
<LI><A HREF="stamp.html#SEC90">Environmentally constrained changes</A>
<LI><A HREF="stamp.html#SEC91">Using text orthography changes</A>
<LI><A HREF="stamp.html#SEC92">Where orthography changes apply</A>
<LI><A HREF="stamp.html#SEC93">A sample orthography change table</A>
<LI><A HREF="stamp.html#SEC94">Syntax of Orthography Changes</A>
</UL>



<H3><A NAME="SEC89" HREF="stamp.html#TOC89">10.2.1  Basic changes</A></H3>

<P>
To substitute one string of characters for another, these must be made
known to the program in a change.  (The technical term for this sort of
change is a production, but we will simply call them changes.)  In the
simplest case, a change is given in three parts: (1) the field code
<CODE>\ch</CODE> must be given at the extreme left margin to indicate that
this line contains a change; (2) the match string is the string for
which the program must search; and (3) the substitution string is the
replacement for the match string, wherever it is found.

</P>
<P>
The beginning and end of the match and substitution strings must be
marked.  The first printing character following <CODE>\ch</CODE> (with at
least one space or tab between) is used as the delimiter for that line.
The match string is taken as whatever lies between the first and second
occurrences of the delimiter on the line and the substitution string is
whatever lies between the third and fourth occurrences.  For example,
the following lines indicate the change of hi to bye, where the
delimiters are the double quote mark (<CODE>"</CODE>), the single quote mark
(<CODE>'</CODE>), the period (<CODE>.</CODE>), and the at sign (<CODE>@</CODE>).

<PRE>
\ch "hi" "bye"
\ch 'hi' 'bye'
\ch .hi. .bye.
\ch @hi@ @bye@
</PRE>

<P>
Throughout this document, we use the double quote mark as the delimiter
unless there is some reason to do otherwise.

</P>
<P>
Change tables follow these conventions:

<OL>
<LI>

Any characters (other than the delimiter) may be placed between the
match and substitution strings.  This allows various notations to
symbolize the change.  For example, the following are equivalent:

<PRE>
\ch "thou" "you"
\ch "thou" to "you"
\ch "thou" &#62; "you"
\ch "thou" --&#62; "you"
\ch "thou" becomes "you"
</PRE>

<LI>

Comments included after the substitution string are initiated by a
designated character such as a semicolon (<CODE>;</CODE>).
The following lines illustrate the use of comments:

<PRE>
\ch "qeki" "qiki" | for cases like wawqeki
\ch "thou" "you"  | for modern English
</PRE>

<LI>

A change can be ignored temporarily by turning it into a comment field.
This is done either by placing an unrecognized field code in front of
the normal <CODE>\ch</CODE>, or by placing the comment character
(<CODE>|</CODE>) in front of it.  For example, only the
first of the following three lines would effect a change:

<PRE>
\ch "nb" "mp"
\no \ch "np" "np"
|\ch "mb" "nb"
</PRE>

</OL>

<P>
The changes in the text output control file are applied as an ordered
set of changes.  The first change is applied to the entire word by
searching from left to right for any matching strings and, upon finding
any, replacing them with the substitution string.  After the first
change has been applied to the entire word, then the next change is
applied, and so on.  Thus, each change applies to the result of all
prior changes.  When all the changes have been applied, the resulting
word is returned.  For example, suppose we have the following changes:

<PRE>
\ch "aib" &#62; "ayb"
\ch "yb"  &#62; "yp"
</PRE>

<P>
Consider the effect these have on the word <I>paiba</I>.  The first
changes <I>i</I> to <I>y</I>, yielding <I>payba</I>; the second changes
<I>b</I> to <I>p</I>, to yield <I>paypa</I>.  (This would be better than the
single change of <I>aib</I> to <I>ayp</I> if there were sources of <I>yb</I>
other than the output of the first rule.)

</P>
<P>
The way in which change tables are applied allows certain
tricks.  For example, suppose that for Quechua, we wish to change
<I>hw</I> to <I>f</I>, so that <I>hwista</I> becomes <I>fista</I> and <I>hwis</I>
becomes <I>fis</I>.  However, we do not wish to change the sequence
<I>shw</I> or <I>chw</I> to <I>sf</I> or <I>cf</I> (respectively).  This could
be done by the following sequence of changes. (Note, <CODE>@</CODE> and
<CODE>$</CODE> are not otherwise used in the orthography.)

<PRE>
\ch "shw" &#62; "@"     | (1)
\ch "chw" &#62; "$"      | (2)
\ch "hw"  &#62; "f"      | (3)
\ch "@"   &#62; "shw"   | (4)
\ch "$"   &#62; "chw"    | (5)
</PRE>

<P>
Lines (1) and (2) protect the <I>sh</I> and <I>ch</I> by changing them to
distinguished symbols.  This clears the way for the change of <I>hw</I> to
<I>f</I> in (3).  Then lines (4) and (5) restore <CODE>@</CODE> and <CODE>$</CODE> to
<I>sh</I> and <I>ch</I>, respectively. (An alternative, simpler way to do
this is discussed in the next section.)

</P>


<H3><A NAME="SEC90" HREF="stamp.html#TOC90">10.2.2  Environmentally constrained changes</A></H3>

<P>
It is possible to impose string environment constraints (SECs) on
changes in the orthography change tables.  The syntax of SECs is
described in detail in section .

</P>
<P>
For example, suppose we wish to change the mid vowels (<I>e</I> and
<I>o</I>) to high vowels (<I>i</I> and <I>u</I> respectively) immediately
before and after <I>q</I>.  This could be done with the following
changes:

<PRE>
\ch "o" "u"  / _ q  / q _
\ch "e" "i"  / _ q  / q _
</PRE>

<P>
This is not entirely a hypothetical example; some Quechua practical
orthographies write the mid vowels <I>e</I> and <I>o</I>.  However, in the
environment of <I>/q/</I> these could be considered phonemically high
vowels <I>/i/</I> and <I>/u/</I>.  Changing the mid vowels to high upon
loading texts has the advantage that--for cases like <I>upun</I> "he
drinks" and <I>upoq</I> "the one who drinks"--the root needs to be
represented internally only as <I>upu</I> "drink".  But note, because
of Spanish loans, it is not possible to change all cases of <I>e</I> to
<I>i</I> and <I>o</I> to <I>u</I>.  The changes must be conditioned.

</P>
<P>
In reality, the regressive vowel-lowering effect of <I>/q/</I> can pass
over various intervening consonants, including <I>/y/</I>, <I>/w/</I>,
<I>/l/</I>, <I>/ll/</I>, <I>/r/</I>, <I>/m/</I>, <I>/n/</I>, and <I>/n/</I>.  For
example, <I>/ullq/</I> becomes <I>ollq</I>, <I>/irq/</I> becomes <I>erq</I>,
and so on.  Rather than list each of these cases as a separate constraint, it
is convenient to define a class (which we label <CODE>+resonant</CODE>) and
use this class to simplify the SEC.  Note that the string class
must be defined (with the <CODE>\scl</CODE> field code) before it is used in a
constraint.

<PRE>
\scl +resonant y w l ll r m n n~
\ch "o" "u" / q _ / _ ([+resonant]) q
\ch "e" "i" / q _ / _ ([+resonant]) q
</PRE>

<P>
This says that the mid vowels become high vowels after <I>/q/</I> and
before <I>/q/</I>, possibly with an intervening <I>/y/</I>, <I>/w/</I>,
<I>/l/</I>, <I>/ll/</I>, <I>/r/</I>, <I>/m/</I>, <I>/n/</I>, or <I>/n/</I>.

</P>
<P>
Consider the problem posed for Quechua in the previous section, that of
changing <I>hw</I> to <I>f</I>.  An alternative is to condition the change
so that it does not apply adjacent to a member of the string class
<CODE>Affric</CODE> which contains <I>s</I> and <I>c</I>.

<PRE>
\scl Affric c s
\ch "hw" "f" / [Affric] ~_
</PRE>

<P>
It is sometimes convenient to make certain changes only at word
boundaries, that is, to change a sequence of characters only if they
initiate or terminate the word.  This conditioning is easily expressed,
as shown in the following examples.

<PRE>
\ch "this" "that"           | anywhere in the word
\ch "this" "that"  / # _    | only if word initial
\ch "this" "that"  /   _ #  | only if word final
\ch "this" "that"  / # _ #  | only if entire word
</PRE>

<P>

</P>


<H3><A NAME="SEC91" HREF="stamp.html#TOC91">10.2.3  Using text orthography changes</A></H3>

<P>
The purpose of orthography change is to convert text from an external
orthography to an internal representation more suitable for
morphological analysis.  In many cases this is unnecessary, the
practical orthography being completely adequate as the internal
representation.  In other cases, the practical orthography is an
inconvenience that can be circumvented by converting to a more phonemic
representation.

</P>
<P>
Let us take a simple example from Latin.  In the Latin orthography, the
nominative singular masculine of the word "king" is <I>rex</I>.
However, phonemically, this is really <I>/reks/</I>; <I>/rek/</I> is the
root meaning king and the <I>/s/</I> is an inflectional suffix.  If
the program is to recover such an analysis, then it is necessary to
convert the <I>x</I> of the external, practical orthography into <I>ks</I>
internally.  This can be done by including the following orthography
change in the text output control file:

<PRE>
\ch  "x"  "ks"
</PRE>

<P>
In this, <I>x</I> is the match string and <I>ks</I> is the substitution
string, as discussed in section .  Whenever <I>x</I> is
found, <I>ks</I> is substituted for it.

</P>
<P>
Let us consider next an example from Huallaga Quechua.  The practical
orthography currently represents long vowels by doubling the vowel.
For example, what is written as <I>kaa</I> is <I>/ka:/</I> "I am", where
the length (represented by a colon) is the morpheme meaning "first
person subject".  Other examples, such as <I>upoo</I> <I>/upu:/</I> "I
drink" and <I>upichee</I> <I>/upi-chi-:/</I> "I extinguish", motivate us
to convert all long vowels into a vowel followed by a colon.  The
following changes do this:

<PRE>
\ch  "aa"  "a:"
\ch  "ee"  "i:"
\ch  "ii"  "i:"
\ch  "oo"  "u:"
\ch  "uu"  "u:"
</PRE>

<P>
Note that the long high vowels (<I>i</I> and <I>u</I>) have become mid vowels
(<I>e</I> and <I>o</I> respectively); consequently, the vowel in the
substitution string is not necessarily the same as that of the match
string.  What is the utility of these changes?  In the lexicon, the
morphemes can be represented in their phonemic forms; they do not have to
be represented in all their orthographic variants.  For example, the
first person subject morpheme can be represented simply as a colon
(<I>-:</I>), rather than as <I>-a</I> in cases like <I>kaa</I>, as <I>-o</I> in
cases like <I>qoo</I>, and as <I>-e</I> as in cases like <I>upichee</I>.
Further, the verb "drink" can be represented as <I>upu</I> and the
causative suffix (in <I>upichee</I>) can be represented as <I>-chi</I>; these
are the forms these morphemes have in other (nonlowered) environments.
As the next example, let us suppose that we are analyzing Spanish, and
that we wish to work internally with <I>k</I> rather than <I>c</I> (before
<I>a</I>, <I>o</I>, and <I>u</I>) and <I>qu</I> (before <I>i</I> and <I>e</I>). (Of
course, this is probably not the only change we would want to make.)
Consider the following changes:

<PRE>
\ch  "ca"  "ka"
\ch  "co"  "ko"
\ch  "cu"  "ku"
\ch  "qu"  "k"
</PRE>

<P>
The first three handle <I>c</I> and the last handles <I>qu</I>.  By virtue of
including the vowel after <I>c</I>, we avoid changing <I>ch</I> to <I>kh</I>.
There are other ways to achieve the same effect.  One way exploits the
fact that each change is applied to the output of all previous changes.
Thus, we could first protect <I>ch</I> by changing it to some distinguished
character (say <CODE>@</CODE>), then changing <I>c</I> to <I>k</I>, and then
restoring <CODE>@</CODE> to <I>ch</I>:

<PRE>
\ch  "ch"  "@"
\ch  "c"  "k"
\ch  "@"  "ch"
\ch  "qu"  "k"
</PRE>

<P>
Another approach conditions the change by the adjacent characters.  The
changes could be rewritten as

<PRE>
\ch  "c"  "k"  / _a  / _o  / _u  | only before a, o, or u
\ch  "qu"  "k"                   | in all cases
</PRE>

<P>
The first change says, "change <I>c</I> to <I>k</I> when followed by <I>a</I>,
<I>o</I>, or <I>u</I>."  (This would, for example, change <I>como</I> to
<I>komo</I>, but would not affect <I>chal</I>.)  The syntax of such conditions
is exactly that used in string environment constraints; see
section .

</P>


<H3><A NAME="SEC92" HREF="stamp.html#TOC92">10.2.4  Where orthography changes apply</A></H3>

<P>
Input orthography changes are made when the text being processed may be
written in a practical orthography.  Rather than requiring that it be
converted as a prerequisite to running the program, it is possible to
have the program convert the orthography as it loads and before it
processes each word.

</P>
<P>
The changes loaded from the text output control file are applied after all the
text is converted to lower case (and the information about upper and
lower case, along with information about format marking, punctuation
and white space, has been put to one side.)  Consequently, the match
strings of these orthography changes should be all lower case; any
change that has an uppercase character in the match string will never
apply.

</P>


<H3><A NAME="SEC93" HREF="stamp.html#TOC93">10.2.5  A sample orthography change table</A></H3>

<P>
We include here the entire orthography input change table for Caquinte
(a language of Peru).  There are basically four changes that need to be
made: (1) nasals, which in the practical orthography reflect their
assimilation to the point of articulation of a following noncontinuant,
must be changed into an unspecified nasal, represented by <I>N</I>; (2)
<I>c</I> and <I>qu</I> are changed to <I>k</I>; (3) <I>j</I> is changed to <I>h</I>;
and (4) <I>gu</I> is changed to <I>g</I> before <I>i</I> and <I>e</I>.

</P>

<PRE>
\ch  "mp"  "Np"     | for unspecified nasals
\ch  "nch" "Nch"
\ch  "nc"  "Nk"
\ch  "nqu" "Nk"
\ch  "nt"  "Nt"

\ch  "ch"  "@"     | to protect ch
\ch  "c"   "k"      | other c's to k
\ch  "@"   "ch"    | to restore ch
\ch  "qu"  "k"

\ch  "j"   "h"

\ch  "gue" "ge"
\ch  "gui" "gi"
</PRE>

<P>
This change table can be simplified by the judicious use of string
environment constraints:

</P>

<PRE>
\ch  "m"  &#62;  "N"  / _p
\ch  "n"  &#62;  "N"  / _c  / _t  / _qu

\ch  "c"  &#62;  "k"  / _~h
\ch  "qu" &#62;  "k"

\ch  "j"  &#62;  "h"

\ch  "gu" &#62;  "g"  / _e  /_i
</PRE>

<P>
As suggested by the preceding examples, the text orthography change
table is composed of all the <CODE>\ch</CODE> fields found in the
text output control file.  These may appear anywhere in the file relative to
the other fields.  It is recommended that all the orthography changes
be placed together in one section of the text output control file, rather than
being mixed in with other fields.

</P>


<H3><A NAME="SEC94" HREF="stamp.html#TOC94">10.2.6  Syntax of Orthography Changes</A></H3>

<P>
This section presents a grammatical description of the syntax of
orthography changes in BNF notation.

</P>

<PRE>

 1a. &#60;orthochange&#62;  ::= &#60;basic_change&#62;
 1b.                    &#60;basic_change&#62; &#60;constraints&#62;

 2a. &#60;basic_change&#62; ::= &#60;quote&#62;&#60;quote&#62; &#60;quote&#62;&#60;string&#62;&#60;quote&#62;
 2b.                    &#60;quote&#62;&#60;string&#62;&#60;quote&#62; &#60;quote&#62;&#60;quote&#62;
 2c.                    &#60;quote&#62;&#60;string&#62;&#60;quote&#62; &#60;quote&#62;&#60;string&#62;&#60;quote&#62;

 3.  &#60;quote&#62;        ::= any printing character not used in either
						the ``from'' string or the ``to'' string

 4.  &#60;string&#62;       ::= one or more characters other than the quote
						character used by this orthography change

 5a. &#60;constraints&#62;  ::= &#60;change_envir&#62;
 5b.                    &#60;change_envir&#62; &#60;constraints&#62;

 6a. &#60;change_envir&#62; ::= &#60;marker&#62; &#60;leftside&#62; &#60;envbar&#62; &#60;rightside&#62;
 6b.                    &#60;marker&#62; &#60;leftside&#62; &#60;envbar&#62;
 6c.                    &#60;marker&#62; &#60;envbar&#62; &#60;rightside&#62;

 7a. &#60;leftside&#62;   ::= &#60;side&#62;
 7b.                  &#60;boundary&#62;
 7c.                  &#60;boundary&#62; &#60;side&#62;

 8a. &#60;rightside&#62;  ::= &#60;side&#62;
 8b.                  &#60;boundary&#62;
 8c.                  &#60;side&#62; &#60;boundary&#62;

 9a. &#60;side&#62;       ::= &#60;item&#62;
 9b.                  &#60;item&#62; &#60;side&#62;
 9c.                  &#60;item&#62; ... &#60;side&#62;

10a. &#60;item&#62;       ::= &#60;piece&#62;
10b.                  ( &#60;piece&#62; )

11a. &#60;piece&#62;      ::= ~ &#60;piece&#62;
11b.                  &#60;literal&#62;
11c.                  [ &#60;literal&#62; ]

12.  &#60;marker&#62;     ::= /
					  +/

13.  &#60;envbar&#62;     ::= _
					  ~_

14.  &#60;boundary&#62;   ::= #
					  ~#

15.  &#60;literal&#62;    ::= one or more contiguous characters

</PRE>


<H4>10.2.6.1  Comments on selected BNF rules</H4>
<DL COMPACT>

<DT>2.
<DD>
The same <CODE>&#60;quote&#62;</CODE> character must be used at both the beginning
and the end of both the "from" string and the "to" string.

<DT>3.
<DD>
The double quote (<CODE>"</CODE>) and single quote (<CODE>'</CODE>) characters are
most often used.

<DT>7-8.
<DD>
Note that what can appear to the left of the environment bar is a
mirror image of what can appear to the right.

<DT>9c.
<DD>
An ellipsis (<CODE>...</CODE>) indicates a possible break in contiguity.

<DT>10b.
<DD>
Something enclosed in parentheses is optional.

<DT>11a.
<DD>
A tilde (<CODE>~</CODE>) reverses the desirability of an element, causing the
constraint to fail if it is found rather than fail if it is not found.

<DT>11c.
<DD>
A literal enclosed in square brackets must be the name of a string
class defined by a <CODE>\scl</CODE> field in the analysis data file, or
earlier in the dictionary orthography change file.

<DT>12.
<DD>
A <CODE>+/</CODE> is usually used for morpheme environment constraints, but may
used for change environment constraints in <CODE>\ch</CODE> fields in the
dictionary orthography change table file.

<DT>13.
<DD>
A tilde attached to the environment bar (<CODE>~_</CODE>) inverts the sense of
the constraint as a whole.

<DT>14b.
<DD>
The boundary marker preceded by a tilde (<CODE>~#</CODE>) indicates that it
must not be a word boundary.

<DT>15.
<DD>
The special characters used by environment constraints can be included
in a literal only if they are immediately preceded by a backslash:

<PRE>

\+  \/  \#  \~  \[  \]  \(  \)  \.  \_  \\

</PRE>

</DL>



<H2><A NAME="SEC95" HREF="stamp.html#TOC95">10.3  Decomposition Separation Character: \dsc</A></H2>
<P>
<A NAME="IDX77"></A>

</P>
<P>
The <CODE>\dsc</CODE> field defines the character used to separate the
morphemes in the decomposition field of the input analysis file.  For
example, to use the equal sign (<CODE>=</CODE>), the text input control file
would include:

<PRE>

\dsc  =

</PRE>

<P>
This would handle a decomposition field like the following:

<PRE>

\d %3%kay%ka=y%ka=y%

</PRE>

<P>
It makes sense to use the <CODE>\dsc</CODE> field only once in the text output
control file.  If multiple <CODE>\dsc</CODE> fields do occur in the file, the
value given in the first one is used.  If the text output control file
does not have an <CODE>\dsc</CODE> field, a dash (<CODE>-</CODE>) is used.

</P>
<P>
The first printing character following the <CODE>\dsc</CODE> field code is used
as the morpheme decomposition separator character.  The same character
cannot be used both for separating decomposed morphemes in the analysis
output file and for marking comments in the output control files.  Thus,
one normally cannot use the vertical bar (<CODE>|</CODE>) as the decomposition
separation character.

</P>
<P>
This field is provided for use by the INTERGEN program.  It is of little
use to STAMP.

</P>


<H2><A NAME="SEC96" HREF="stamp.html#TOC96">10.4  Primary format marker character: \format</A></H2>
<P>
<A NAME="IDX78"></A>

</P>
<P>
The <CODE>\format</CODE> field designates a single character to flag the
beginning of a primary format marker.  For example, if the format
markers in the text files begin with the at sign (<CODE>@</CODE>), the
following would be placed in the text input control file:

<PRE>

\format  @

</PRE>

<P>
This would be used, for example, if the text contained format markers
like the following:

<PRE>

@
@p
@sp
@make(Article)
@very-long.and;muddled/format*marker,to#be$sure

</PRE>

<P>
If a <CODE>\format</CODE> field occurs in the text input control file without
a following character to serve for flagging format markers, then the
program will not recognize any format markers and will try to parse
everything other than punctuation characters.

</P>
<P>
It makes sense to use the <CODE>\format</CODE> field only once in the text
input control file.  If multiple <CODE>\format</CODE> fields do occur in the
file, the value given in the first one is used.

</P>
<P>
The first printing character following the <CODE>\format</CODE> field code is
used to flag format markers.  The character currently used to mark
comments cannot be assigned to also flag format markers.  Thus, the
vertical bar (<CODE>|</CODE>) cannot normally be used to flag format markers.

</P>
<P>
This field is provided for use by the INTERGEN program.  It is of little
use to STAMP.

</P>


<H2><A NAME="SEC97" HREF="stamp.html#TOC97">10.5  Lowercase/uppercase character pairs: \luwfc</A></H2>
<P>
<A NAME="IDX79"></A>

</P>
<P>
To break a text into words, the program needs to know which characters
are used to form words.  It always assumes that the letters <CODE>A</CODE>
through <CODE>Z</CODE> and <CODE>a</CODE> through <CODE>z</CODE> are used as word
formation characters.  If the orthography of the language the user is
working in uses any other characters that have lowercase and uppercase
forms, these must given in a <CODE>\luwfc</CODE> field in the text input
control file.

</P>
<P>
The <CODE>\luwfc</CODE> field defines pairs of characters; the first member
of each pair is a lowercase character and the second is the
corresponding uppercase character.  Several such pairs may be placed in
the field or they may be placed on separate fields.  Whitespace may be
interspersed freely.  For example, the following three examples are
equivalent:

<PRE>

\luwfc   

</PRE>

<P>
or

<PRE>

\luwfc        | e with acute accent
\luwfc        | enyee

</PRE>

<P>
or

<PRE>

\luwfc      

</PRE>

<P>
Note that comments can be used as well (just as they can in any
STAMP control file).  This means that the comment character
cannot be designated as a word formation character.  If the orthography
includes the vertical bar (<CODE>|</CODE>), then a different comment character
must be defined with the <SAMP>`-c'</SAMP> command line option when
STAMP is initiated; see
above.
section <A HREF="stamp.html#SEC3">2.1  STAMP Command Options</A>.

</P>
<P>
The <CODE>\luwfc</CODE> field can be entered anywhere in the text input control file,
although a natural place would be before the <CODE>\wfc</CODE> (word formation
character) field.

</P>
<P>
Any standard alphabetic character (that is <CODE>a</CODE> through <CODE>z</CODE> or
<CODE>A</CODE> through <CODE>Z</CODE>) in the <CODE>\luwfc</CODE> field will override the
standard lower- upper case pairing.  For example, the following will
treat <CODE>X</CODE> as the upper case equivalent of <CODE>z</CODE>:

<PRE>

\luwfc z X

</PRE>

<P>
Note that <CODE>Z</CODE> will still have <CODE>z</CODE> as its lower-case
equivalent in this case.

</P>
<P>
The <CODE>\luwfc</CODE> field is allowed to map multiple lower case characters to
the same upper case character, and vice versa.  This is needed for
languages that do not mark tone on upper case letters.

</P>


<H2><A NAME="SEC98" HREF="stamp.html#TOC98">10.6  Multibyte lowercase/uppercase character pairs: \luwfcs</A></H2>
<P>
<A NAME="IDX80"></A>

</P>
<P>
The <CODE>\luwfcs</CODE> field extends the character pair definitions of the
<CODE>\luwfc</CODE> field to multibyte character sequences.  Like the
<CODE>\luwfc</CODE> field, the <CODE>\luwfcs</CODE> field defines pairs of
characters; the first member of each pair is a multibyte lowercase
character and the second is the corresponding multibyte uppercase
character.  Several such pairs may be placed in the field or they may be
placed on separate fields.  Whitespace separates the members of each
pair, and the pairs from each other.  For example, the following three
examples are equivalent:

<PRE>

\luwfcs  e' E` n~ N^  C&#38;

</PRE>

<P>
or

<PRE>

\luwfcs  e' E`      | e with acute accent
\luwfcs  n~ N^      | enyee
\luwfcs    C&#38;      | c cedilla

</PRE>

<P>
or

<PRE>

\luwfcs  e' E`
		 n~ N^
		   C&#38;

</PRE>

<P>
Note that comments can be used as well (just as they can in any
STAMP control file).  This means that the comment character
cannot be designated as a word formation character.  If the orthography
includes the vertical bar (<CODE>|</CODE>), then a different comment character
must be defined with the <SAMP>`-c'</SAMP> command line option when
STAMP is initiated; see
section <A HREF="stamp.html#SEC3">2.1  STAMP Command Options</A>.

</P>
<P>
Also note that there is no requirement that the lowercase form be the
same length (number of bytes) as the uppercase form.  The examples shown
above are only one or two bytes (character codes) in length, but there is
no limit placed on the length of a multibyte character.

</P>
<P>
The <CODE>\luwfcs</CODE> field can be entered anywhere in the text input
control file.  <CODE>\luwfcs</CODE> fields may be mixed with <CODE>\luwfc</CODE>
fields in the same file.

</P>
<P>
Any standard alphabetic character (that is <CODE>a</CODE> through <CODE>z</CODE> or
<CODE>A</CODE> through <CODE>Z</CODE>) in the <CODE>\luwfcs</CODE> field will override the
standard lower- upper case pairing.  For example, the following will
treat <CODE>X</CODE> as the upper case equivalent of <CODE>z</CODE>:

<PRE>

\luwfcs z X

</PRE>

<P>
Note that <CODE>Z</CODE> will still have <CODE>z</CODE> as its lowercase
equivalent in this case.

</P>
<P>
The <CODE>\luwfcs</CODE> field is allowed to map multiple multibyte lowercase
characters to the same multibyte uppercase character, and vice versa.
This may be useful in some situations, but it introduces an element of
ambiguity into the decapitalization and recapitalization processes.  If
ambiguous capitalization is supported, then for the previous example,
<CODE>z</CODE> will have both <CODE>X</CODE> and <CODE>Z</CODE> as uppercase equivalents,
and <CODE>X</CODE> will have both <CODE>x</CODE> and <CODE>Z</CODE> as lowercase
equivalents.

</P>


<H2><A NAME="SEC99" HREF="stamp.html#TOC99">10.7  Text output string classes: \scl</A></H2>
<P>
<A NAME="IDX81"></A>

</P>
<P>
section <A HREF="stamp.html#SEC99">10.7  Text output string classes: \scl</A>.
A string class is defined by the <CODE>\scl</CODE> field code followed by the
class name, which is followed in turn by one or more contiguous
character strings or (previously defined) string class names.  A string
class name used as part of the class definition must be enclosed in
square brackets.
For example, the sample text output control file given below contains
the following lines:

<PRE>
a. \scl X t s c
b. \ch "h"   "j"   / [X] ~_
</PRE>

<P>
Line a defines a string class including t, s, and c; change rule b
makes use of this class to block the change of h to j when it occurs in
the digraphs th, sh, and ch.

</P>
<P>
The class name must be a single, contiguous sequence of printing
characters.  Characters and words which have special meanings in tests
should not be used.  The actual character strings have no such
restrictions.  The individual members of the class are separated by
spaces, tabs, or newlines.

</P>
<P>
Each <CODE>\scl</CODE> field defines a single string class.  Any number of
<CODE>\scl</CODE> fields may appear in the file.  The only restriction is
that a string class must be defined before it is used.

</P>



<H2><A NAME="SEC100" HREF="stamp.html#TOC100">10.8  Caseless word formation characters: \wfc</A></H2>
<P>
<A NAME="IDX82"></A>

</P>
<P>
To break a text into words, the program needs to know which characters
are used to form words.  It always assumes that the letters <CODE>A</CODE>
through <CODE>Z</CODE> and <CODE>a</CODE> through <CODE>z</CODE> are used as word
formation characters.  If the orthography of the language the user is
working in uses any characters that do not have different lowercase and
uppercase forms, these must given in a <CODE>\wfc</CODE> field in the text
input control file.

</P>
<P>
For example, English uses an apostrophe character (<CODE>'</CODE>) that could
be considered a word formation character.  This information is provided
by the following example:

<PRE>

\wfc  '    | needed for words like don't

</PRE>

<P>
Notice that the characters in the <CODE>\wfc</CODE> field may be separated by
spaces, although it is not required to do so.  If more than one
<CODE>\wfc</CODE> field occurs in the text input control file, the program
uses the combination of all characters defined in all such fields as
word formation characters.

</P>
<P>
The comment character cannot be designated as a word formation character.
If the orthography includes the vertical bar (<CODE>|</CODE>), then a different
comment character must be defined with the <SAMP>`-c'</SAMP> command line option
when STAMP is initiated; see
section <A HREF="stamp.html#SEC3">2.1  STAMP Command Options</A>.

</P>


<H2><A NAME="SEC101" HREF="stamp.html#TOC101">10.9  Multibyte caseless word formation characters: \wfcs</A></H2>
<P>
<A NAME="IDX83"></A>

</P>
<P>
The <CODE>\wfcs</CODE> field allows multibyte characters to be defined as
"caseless" word formation characters.  It has the same relationship to
<CODE>\wfc</CODE> that <CODE>\luwfcs</CODE> has to <CODE>\luwfc</CODE>.  The multibyte word
formation characters are separated from each other by whitespace.

</P>


<H2><A NAME="SEC102" HREF="stamp.html#TOC102">10.10  A sample text output control file</A></H2>

<P>
A complete text output control file used for adapting to Asheninca
Campa is given below.

</P>

<PRE>
\id AEouttx.ctl for Asheninca Campa
\ch "N"   "m"  / _ p       | assimilates before p
\ch "N"   "n"              | otherwise becomes n
\ch "ny"  "n~"

\ch "ts"  "th" / ~_ i      | (N)tsi is unchanged
\ch "tsy" "ch"
\ch "sy"  "sh"
\ch "t"   "tz" / n _ i

\ch "k"   "qu" / _ i / _ e
\ch "k"   "q"  / _ y
\ch "k"   "c"

\scl X t s c               | define class of  t   s   c
\ch "h"   "j"   / [X] ~_   | change except in th, sh, ch

\ch "#"   " "              | remove fixed space
\ch "@"   ""              | remove blocking character
</PRE>



<H1><A NAME="SEC103" HREF="stamp.html#TOC103">11  Input Analysis Files</A></H1>
<P>
<A NAME="IDX84"></A>
<A NAME="IDX85"></A>

</P>
<P>
Analysis files are <EM>record oriented standard format files</EM>.
This means that the files are divided into records, each representing a
single word in the original input text file, and records are divided
into fields.  An analysis file contains at least one record, and may
contain a large number of records.  Each record contains one or more
fields.  Each field occupies at least one line, and is marked by a
<EM>field code</EM> at the beginning of the line.  A field code begins
with a backslash character (<CODE>\</CODE>), and contains 1 or more letters
in addition.

</P>

<UL>
<LI><A HREF="stamp.html#SEC104">Analysis file fields</A>: Description of each type of field
<LI><A HREF="stamp.html#SEC115">Ambiguous analyses</A>: How ambiguous analyses are marked
<LI><A HREF="stamp.html#SEC116">Analysis failures</A>: How analysis failures are marked
</UL>



<H2><A NAME="SEC104" HREF="stamp.html#TOC104">11.1  Analysis file fields</A></H2>

<P>
This section describes the possible fields in an analysis file.  The
only field that is guaranteed to exist is the analysis (<CODE>\a</CODE>)
field.  All other fields are either data dependent or optional.

</P>

<UL>
<LI><A HREF="stamp.html#SEC105">\a</A>: Analysis
<LI><A HREF="stamp.html#SEC106">\d</A>: Decomposition (surface forms)
<LI><A HREF="stamp.html#SEC107">\cat</A>: Category (possible word, morpheme)
<LI><A HREF="stamp.html#SEC108">\p</A>: Properties
<LI><A HREF="stamp.html#SEC109">\fd</A>: Feature Descriptors
<LI><A HREF="stamp.html#SEC110">\u</A>: Underlying forms (decomposition)
<LI><A HREF="stamp.html#SEC111">\w</A>: Word (before decapitalization and orthography changes)
<LI><A HREF="stamp.html#SEC112">\f</A>: Formatting (junk before the word)
<LI><A HREF="stamp.html#SEC113">\c</A>: Capitalization flag
<LI><A HREF="stamp.html#SEC114">\n</A>: Nonalphabetic (junk after the word)
</UL>



<H3><A NAME="SEC105" HREF="stamp.html#TOC105">11.1.1  Analysis field: \a</A></H3>
<P>
<A NAME="IDX86"></A>

</P>
<P>
The analysis field (<CODE>\a</CODE>) starts each record of an analysis file.
It has the following form:

<PRE>

\a PFX IFX PFX &#60; CAT root CAT root &#62; SFX IFX SFX

</PRE>

<P>
where <CODE>PFX</CODE> is a prefix morphname, <CODE>IFX</CODE> is an infix
morphname, <CODE>SFX</CODE> is a suffix morphname, <CODE>CAT</CODE> is a root
category, and <CODE>root</CODE> is a root gloss or etymology.  In the
simplest case, an analysis field would look like this:

<PRE>

\a &#60; CAT root &#62;

</PRE>

<P>
where <CODE>CAT</CODE> is a root category and <CODE>root</CODE> is a root gloss or
etymology.

</P>



<H3><A NAME="SEC106" HREF="stamp.html#TOC106">11.1.2  Decomposition field: \d</A></H3>
<P>
<A NAME="IDX87"></A>

</P>
<P>
The morpheme decomposition field (<CODE>\d</CODE>) follows the analysis
field.  It has the following form:

<PRE>

\d anti-dis-establish-ment-arian-ism-s

</PRE>

<P>
where the hyphens separate the individual morphemes in the surface form
of the word.

</P>



<H3><A NAME="SEC107" HREF="stamp.html#TOC107">11.1.3  Category field: \cat</A></H3>
<P>
<A NAME="IDX88"></A>

</P>
<P>
The category field (<CODE>\cat</CODE>) provides rudimentary category
information.  This may be useful for sentence level parsing.  It has
the following form:

<PRE>

\cat CAT

</PRE>

<P>
where <CODE>CAT</CODE> is the word category.
section <A HREF="stamp.html#SEC107">11.1.3  Category field: \cat</A>.

</P>

<P>
If there are multiple analyses, there will be multiple categories in
the output, separated by ambiguity markers.

</P>


<H3><A NAME="SEC108" HREF="stamp.html#TOC108">11.1.4  Properties field: \p</A></H3>
<P>
<A NAME="IDX89"></A>

</P>
<P>
The properties field (<CODE>\p</CODE>) contains the names of any allomorph or
morpheme properties found in the analysis of the word.  It has the
form:

<PRE>

\p ==prop1 prop2=prop3=

</PRE>

<P>
where <CODE>prop1</CODE>, <CODE>prop2</CODE>, and <CODE>prop3</CODE> are property names.
The equal signs (<CODE>=</CODE>) serve to separate the property information
of the individual morphemes.  Note that morphemes may have more than
one property, with the names separated by spaces, or no properties at
all.

</P>



<H3><A NAME="SEC109" HREF="stamp.html#TOC109">11.1.5  Feature Descriptors field: \fd</A></H3>
<P>
<A NAME="IDX90"></A>

</P>
<P>
The feature descriptor field (<CODE>\fd</CODE>) contains the feature names
associated with each morpheme in the analysis.  It has the following
form:

<PRE>

\fd ==feat1 feat2=feat3=

</PRE>

<P>
where <CODE>feat1</CODE>, <CODE>feat2</CODE>, and <CODE>feat3</CODE> are feature
descriptors.  The equal signs (<CODE>=</CODE>) serve to separate the feature
descriptors of the individual morphemes.  Note that morphemes may have
more than one feature descriptor, with the names separated by spaces,
or no feature descriptors at all.

</P>

<P>
If there are multiple analyses, there will be multiple feature sets in
the output, separated by ambiguity markers.

</P>


<H3><A NAME="SEC110" HREF="stamp.html#TOC110">11.1.6  Underlying form field: \u</A></H3>
<P>
<A NAME="IDX91"></A>

</P>
<P>
The underlying form field (<CODE>\u</CODE>) is similar to the decomposition
field except that it shows underlying forms instead of surface forms.
It looks like this:

<PRE>

\u a-para-a-i-ri-me

</PRE>

<P>
where the hyphens separate the individual morphemes.

</P>



<H3><A NAME="SEC111" HREF="stamp.html#TOC111">11.1.7  Word field: \w</A></H3>
<P>
<A NAME="IDX92"></A>

</P>
<P>
The original word field (<CODE>\w</CODE>) contains the original input word as
it looks before decapitalization and orthography changes.  It looks
like this:

<PRE>

\w The

</PRE>

<P>
Note that this is a gratuitous change from earlier versions of AMPLE
and KTEXT, which wrote the decapitalized form.

</P>



<H3><A NAME="SEC112" HREF="stamp.html#TOC112">11.1.8  Formatting field: \f</A></H3>
<P>
<A NAME="IDX93"></A>

</P>
<P>
The format information field (<CODE>\f</CODE>) records any formatting codes
or punctuation that appeared in the input text file before the word.
It looks like this:

<PRE>

\f \\id MAT 5 HGMT05.SFM, 14-feb-84 D. Weber, Huallaga Quechua\n
		\\c 5\n\n
		\\s

</PRE>

<P>
where backslashes (<CODE>\</CODE>) in the input text are doubled, newlines
are represented by <CODE>\n</CODE>, and additional lines in the field start
with a tab character.

</P>
<P>
The format information field is written to the output analysis file
whenever it is needed, that is, whenever formatting codes or
punctuation exist before words.

</P>


<H3><A NAME="SEC113" HREF="stamp.html#TOC113">11.1.9  Capitalization field: \c</A></H3>
<P>
<A NAME="IDX94"></A>

</P>
<P>
The capitalization field (<CODE>\c</CODE>) records any capitalization of the
input word.  It looks like this:

<PRE>

\c 1

</PRE>

<P>
where the number following the field code has one of these values:
<DL COMPACT>

<DT><CODE>1</CODE>
<DD>
the first (or only) letter of the word is capitalized

<DT><CODE>2</CODE>
<DD>
all letters of the word are capitalized

<DT><CODE>4-32767</CODE>
<DD>
some letters of the word are capitalized and some are not
</DL>
<P>
Note that the third form is of limited utility, but still exists
because of words like the author's last name.

</P>
<P>
The capitalization field is written to the output analysis file
whenever any of the letters in the word are
capitalized.

</P>


<H3><A NAME="SEC114" HREF="stamp.html#TOC114">11.1.10  Nonalphabetic field: \n</A></H3>
<P>
<A NAME="IDX95"></A>

</P>
<P>
The nonalphabetic field (<CODE>\n</CODE>) records any trailing punctuation,
bar codes,
or whitespace characters.  It looks like this:

<PRE>

\n |r.\n

</PRE>

<P>
where newlines are represented by <CODE>\n</CODE>.  The nonalphabetic field
ends with the last whitespace character immediately following the word.

</P>
<P>
The nonalphabetic field is written to the output analysis file whenever
the word is followed by anything other than a single space character.
This includes the case when a word ends a file with nothing following
it.

</P>


<H2><A NAME="SEC115" HREF="stamp.html#TOC115">11.2  Ambiguous analyses</A></H2>

<P>
The previous section assumed that only one analysis is produced for
each word.  This is not always possible since words in isolation are
frequently ambiguous.  Multiple analyses are handled by writing each
analysis field in parallel, with the number of analyses at the
beginning of each output field.  For example,

<PRE>

\a %2%&#60; A0 imaika &#62; CNJT AUG%&#60; A0 imaika &#62; ADVS%
\d %2%imaika-Npa-ni%imaika-Npani%
\cat %2%A0 A0=A0/A0=A0/A0%A0 A0=A0/A0%
\p %2%==%=%
\fd %2%==%=%
\u %2%imaika-Npa-ni%imaika-Npani%
\w Imaicampani
\f \\v124
\c 1
\n \n

</PRE>

<P>
where the percent sign (<CODE>%</CODE>) separates the different analyses in
each field.  Note that only those fields which contain analysis
information are marked for ambiguity.  The other fields (<CODE>\w</CODE>,
<CODE>\f</CODE>, <CODE>\c</CODE>, and <CODE>\n</CODE>) are the same regardless of the
number of analyses.

</P>



<H2><A NAME="SEC116" HREF="stamp.html#TOC116">11.3  Analysis failures</A></H2>

<P>
The previous sections assumed that words are successfully analyzed.
This does not always happen.  Analysis failures are marked the same way
as multiple analyses, but with zero (<CODE>0</CODE>) for the ambiguity count.
For example,

<PRE>

\a %0%ta%
\d %0%ta%
\cat %0%%
\p %0%%
\fd %0%%
\u %0%%
\w TA
\f \\v 12 |b
\c 2
\n |r\n

</PRE>

<P>
Note that only the <CODE>\a</CODE> and <CODE>\d</CODE> fields contain any
information, and those both have the original word as a place
holder.  The other analysis fields (<CODE>\cat</CODE>, <CODE>\p</CODE>, <CODE>\fd</CODE>,
and <CODE>\u</CODE>) are marked for failure, but otherwise left empty.

</P>



<H1><A NAME="SEC117" HREF="stamp.html#TOC117">Bibliography</A></H1>


<OL>

<LI>

Weber, David J., H. Andrew Black, and Stephen R. McConnel. 1988.
<CITE>AMPLE: a tool for exploring morphology</CITE>.
Occasional Publications in Academic Computing No. 12.
Dallas, TX: Summer Institute of Linguistics.

<LI>

Weber, David J., H. Andrew Black, Stephen R. McConnel, and Alan Buseman. 1990.
<CITE>STAMP: a tool for dialect adaptation</CITE>.
Occasional Publications in Academic Computing No. 15.
Dallas, TX: Summer Institute of Linguistics.

</OL>



<H1><A NAME="SEC118" HREF="stamp.html#TOC118">12  Index</A></H1>

<P>
Jump to:
<A HREF="#cindex_-">-</A>
-
<A HREF="#cindex_\">\</A>
-
<A HREF="#cindex_a">a</A>
-
<A HREF="#cindex_d">d</A>
-
<A HREF="#cindex_i">i</A>
-
<A HREF="#cindex_l">l</A>
-
<A HREF="#cindex_s">s</A>
-
<A HREF="#cindex_t">t</A>
<P>
<H2><A NAME="cindex_-">-</A></H2>
<DIR>
<LI><A HREF="stamp.html#IDX15">-/</A>
<LI><A HREF="stamp.html#IDX1">-a</A>
<LI><A HREF="stamp.html#IDX2">-c character</A>
<LI><A HREF="stamp.html#IDX3">-d number</A>
<LI><A HREF="stamp.html#IDX4">-f filename</A>
<LI><A HREF="stamp.html#IDX5">-i filename</A>
<LI><A HREF="stamp.html#IDX6">-m</A>
<LI><A HREF="stamp.html#IDX7">-n</A>
<LI><A HREF="stamp.html#IDX8">-o filename</A>
<LI><A HREF="stamp.html#IDX9">-q</A>
<LI><A HREF="stamp.html#IDX10">-r</A>
<LI><A HREF="stamp.html#IDX11">-t</A>
<LI><A HREF="stamp.html#IDX12">-u</A>
<LI><A HREF="stamp.html#IDX13">-v</A>
<LI><A HREF="stamp.html#IDX14">-x</A>
<LI><A HREF="stamp.html#IDX17">-Z address,count</A>
<LI><A HREF="stamp.html#IDX16">-z filename</A>
</DIR>
<H2><A NAME="cindex_\">\</A></H2>
<DIR>
<LI><A HREF="stamp.html#IDX86">\a</A>
<LI><A HREF="stamp.html#IDX19">\ambig</A>, <A HREF="stamp.html#IDX31">\ambig</A>, <A HREF="stamp.html#IDX48">\ambig</A>, <A HREF="stamp.html#IDX75">\ambig</A>
<LI><A HREF="stamp.html#IDX20">\ap</A>, <A HREF="stamp.html#IDX32">\ap</A>, <A HREF="stamp.html#IDX49">\ap</A>
<LI><A HREF="stamp.html#IDX94">\c</A>
<LI><A HREF="stamp.html#IDX21">\ca</A>, <A HREF="stamp.html#IDX33">\ca</A>, <A HREF="stamp.html#IDX50">\ca</A>
<LI><A HREF="stamp.html#IDX22">\cat</A>, <A HREF="stamp.html#IDX88">\cat</A>
<LI><A HREF="stamp.html#IDX23">\ccl</A>, <A HREF="stamp.html#IDX34">\ccl</A>, <A HREF="stamp.html#IDX51">\ccl</A>
<LI><A HREF="stamp.html#IDX64">\ch</A>, <A HREF="stamp.html#IDX71">\ch</A>, <A HREF="stamp.html#IDX76">\ch</A>
<LI><A HREF="stamp.html#IDX35">\cr</A>
<LI><A HREF="stamp.html#IDX87">\d</A>
<LI><A HREF="stamp.html#IDX77">\dsc</A>
<LI><A HREF="stamp.html#IDX93">\f</A>
<LI><A HREF="stamp.html#IDX90">\fd</A>
<LI><A HREF="stamp.html#IDX36">\fl</A>
<LI><A HREF="stamp.html#IDX78">\format</A>
<LI><A HREF="stamp.html#IDX65">\infix</A>
<LI><A HREF="stamp.html#IDX37">\ir</A>
<LI><A HREF="stamp.html#IDX38">\lc</A>, <A HREF="stamp.html#IDX52">\lc</A>
<LI><A HREF="stamp.html#IDX79">\luwfc</A>
<LI><A HREF="stamp.html#IDX80">\luwfcs</A>
<LI><A HREF="stamp.html#IDX24">\maxprops</A>, <A HREF="stamp.html#IDX41">\maxprops</A>, <A HREF="stamp.html#IDX53">\maxprops</A>
<LI><A HREF="stamp.html#IDX25">\mcl</A>, <A HREF="stamp.html#IDX42">\mcl</A>, <A HREF="stamp.html#IDX54">\mcl</A>
<LI><A HREF="stamp.html#IDX26">\mp</A>, <A HREF="stamp.html#IDX43">\mp</A>, <A HREF="stamp.html#IDX55">\mp</A>
<LI><A HREF="stamp.html#IDX95">\n</A>
<LI><A HREF="stamp.html#IDX89">\p</A>
<LI><A HREF="stamp.html#IDX27">\pcl</A>, <A HREF="stamp.html#IDX44">\pcl</A>, <A HREF="stamp.html#IDX56">\pcl</A>
<LI><A HREF="stamp.html#IDX66">\prefix</A>
<LI><A HREF="stamp.html#IDX28">\rd</A>, <A HREF="stamp.html#IDX45">\rd</A>, <A HREF="stamp.html#IDX57">\rd</A>
<LI><A HREF="stamp.html#IDX67">\root</A>
<LI><A HREF="stamp.html#IDX58">\rsc</A>
<LI><A HREF="stamp.html#IDX59">\rscid</A>
<LI><A HREF="stamp.html#IDX29">\scl</A>, <A HREF="stamp.html#IDX46">\scl</A>, <A HREF="stamp.html#IDX60">\scl</A>, <A HREF="stamp.html#IDX72">\scl</A>, <A HREF="stamp.html#IDX81">\scl</A>
<LI><A HREF="stamp.html#IDX47">\sr</A>
<LI><A HREF="stamp.html#IDX30">\strcheck</A>
<LI><A HREF="stamp.html#IDX68">\suffix</A>
<LI><A HREF="stamp.html#IDX61">\test</A>
<LI><A HREF="stamp.html#IDX91">\u</A>
<LI><A HREF="stamp.html#IDX69">\unified</A>
<LI><A HREF="stamp.html#IDX92">\w</A>
<LI><A HREF="stamp.html#IDX82">\wfc</A>
<LI><A HREF="stamp.html#IDX83">\wfcs</A>
</DIR>
<H2><A NAME="cindex_a">a</A></H2>
<DIR>
<LI><A HREF="stamp.html#IDX85">analysis input file</A>
</DIR>
<H2><A NAME="cindex_d">d</A></H2>
<DIR>
<LI><A HREF="stamp.html#IDX63">dictionary code table</A>
<LI><A HREF="stamp.html#IDX73">dictionary files</A>
<LI><A HREF="stamp.html#IDX70">dictionary orthography change table</A>
</DIR>
<H2><A NAME="cindex_i">i</A></H2>
<DIR>
<LI><A HREF="stamp.html#IDX84">input analysis file</A>
</DIR>
<H2><A NAME="cindex_l">l</A></H2>
<DIR>
<LI><A HREF="stamp.html#IDX40">lexical changes:substitution string</A>
</DIR>
<H2><A NAME="cindex_s">s</A></H2>
<DIR>
<LI><A HREF="stamp.html#IDX18">standard format</A>
<LI><A HREF="stamp.html#IDX39">substitution string</A>
</DIR>
<H2><A NAME="cindex_t">t</A></H2>
<DIR>
<LI><A HREF="stamp.html#IDX62">Test syntax</A>
<LI><A HREF="stamp.html#IDX74">text output control</A>
</DIR>

</P>
<P><HR><P>
<H1>Footnotes</H1>
<H3><A NAME="FOOT1" HREF="stamp.html#DOCF1">(1)</A></H3>
<P>This chapter
is adapted from chapter 8 of Weber (1990).
<P><HR><P>
This document was generated on 7 January 2004 using the
<A HREF="http://wwwinfo.cern.ch/dis/texi2html/">texi2html</A>
translator version 1.52.</P>
</BODY>
</HTML>
